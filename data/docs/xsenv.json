[{"name":"CHANGELOG.md","content":"# Change Log\r\nAll notable changes to this project will be documented in this file.\r\n\r\nThis project adheres to [Semantic Versioning](http://semver.org/).\r\n\r\nThe format is based on [Keep a Changelog](http://keepachangelog.com/).\r\n\r\n## 3.3.2 - 2022-06-17\r\n\r\n### Fixed\r\n- service bindings for Kubernetes: bindings were not read because of symlinks\r\n\r\n## 3.3.1 - 2022-06-08\r\n\r\n### Fixed\r\n- change node plugin version for xmake to 10.15.0\r\n\r\n## 3.3.0 - 2022-06-06\r\n\r\n### Added\r\n- Service bindings for Kubernetes\r\n\r\n## 3.2.2 - 2022-04-11\r\n\r\n### Removed\r\n- Removed node 8.x support and tests\r\n\r\n### Changed\r\n- Changed istanbul test framework with c8\r\n\r\n## 3.2.1 - 2022-02-28\r\n\r\n### Added\r\n- Reading K8s services now caches the results to decrease file system calls.\r\n- Documentation on how to disable caching for K8s Services if needed.\r\n\r\n## 3.2.0 - 2022-01-24\r\n\r\n### Added\r\n- Support Node.js 16.x\r\n\r\n### Updated\r\n- `debug` dependency to 4.3.3.\r\n\r\n## 3.1.1 - 2021-07-01\r\n\r\n### Fixed\r\n- Reading services will now properly check for K8s services when VCAP_SERVICES is defined but contains no services.\r\n- Getting a service will now properly check in K8s services if VCAP_SERVICES does not have the service.\r\n\r\n### Updated\r\n- `debug` dependency to 4.2.0.\r\n- `lodash` dependency to 4.17.21.\r\n\r\n## 3.1.0 - 2020-11-20\r\n\r\n### Added\r\n- Support Node.js 14.x\r\n\r\n## 3.0.0 - 2020-06-05\r\n\r\n### Removed\r\n- Node.js 6 support\r\n\r\n### Changed\r\n- K8S case: nested objects in credentials are now automatically parsed (does not apply to arrays)\r\n\r\n## 2.2.0 - 2019-11-28\r\n\r\n### Added\r\n- Support Node.js 12.x\r\n\r\n## 2.1.0 - 2019-10-15\r\n\r\n### Added\r\n- Support for K8S secrets mounted as volumes.\r\n\r\n## 2.0.0 - 2019-04-22\r\n\r\n### Removed\r\n- Node.js 4 support\r\n- Remove deprecated loadCaCert function\r\n\r\n## 1.3.0 - 2018-12-18\r\n\r\n### Added\r\n- Node.js 10 support\r\n\r\n### Fixed\r\n- Update `lodash` to 4.17.11\r\n\r\n## 1.2.9 - 2018-01-18\r\n### Added\r\n- Release with npm-shrinkwrap.json\r\n\r\n\r\n## 1.2.8 - 2017-10-09\r\n### Security\r\n- Updated debug package to fix a security issue https://snyk.io/vuln/npm:debug:20170905\r\n"},{"name":"migration.md","content":"# Migration Guide\r\n\r\n## Version 2 ==> Version 3\r\n\r\n### Changes to application code\r\n\r\n#### Nested objects in credentials (K8S case only)\r\n\r\nThe following service credentials:\r\n\r\n```\r\n/etc/\r\n  /secrets/\r\n    /sapcp/\r\n      /some-service/\r\n        /some-instance/\r\n          /url   - containing https://some-service\r\n          /uaa   - containing { \"url\": \"https://uaa\", \"clientid\": \"client\", \"clientsecret\": \"secret\" }\r\n          /other - containing [1, \"two\"]\r\n```\r\n\r\nhad been provided to applications in v2 of _@sap/xsenv_ as:\r\n\r\n```js\r\n{\r\n  url: 'https://some-service',\r\n  uaa: '{ \"url\": \"https://uaa\", \"clientid\": \"client\", \"clientsecret\": \"secret\" }',\r\n  other: '[1, \"two\"]'\r\n}\r\n```\r\n\r\nThe `uaa` property requires parsing (with `JSON.parse`) in order to use its properties individually.\r\n\r\nWith v3 of _@sap/xsenv_ nested JSON objects are parsed automatically and are provided to applications as:\r\n\r\n```js\r\n{\r\n  url: 'https://some-service',\r\n  uaa:  {\r\n    url: 'https://uaa',\r\n    clientid: 'client',\r\n    clientsecret: 'secret'\r\n  },\r\n  other: '[1, \"two\"]'\r\n```\r\n\r\nInvocation to `JSON.parse` should be removed from application code.\r\n\r\n**Note**: property values representing arrays are currently not automatically parsed.\r\n"},{"name":"README.md","content":"# @sap/xsenv\r\n\r\nUtility for easily reading application configurations for bound services and certificates in the SAP Cloud Platform Cloud Foundry environment, SAP XS advanced model and Kubernetes (K8S).\r\n\r\n\r\n## Install\r\n\r\n```sh\r\nnpm install --save @sap/xsenv\r\n```\r\n\r\n## Usage\r\n\r\n```js\r\nvar xsenv = require('@sap/xsenv');\r\n\r\n// Read the configuration for all bound service instances\r\nvar services = xsenv.readServices();\r\nconsole.log(services.serviceInstance); // prints { credentials: { user: ..., pass:... }, name: 'serviceInstance', tags: [...], label: ...\r\n\r\n// Read the credentials for all bound service instances matching a given service query\r\nvar services = xsenv.filterServices({ label: 'hana' });\r\nconsole.log(services); // prints [ { credentials: { ... } }, { credentials: { ... } } ]\r\n\r\n// Read only the credentials portion of the configuration for a service instance matching a given service query\r\nvar svc = xsenv.serviceCredentials({ tag: 'hana' });\r\nconsole.log(svc); // prints { host: '...', port: '...', user: '...', password: '...', ... }\r\n\r\n// Read configuration for a service instance matching a given service query\r\nvar services = xsenv.getServices({ hana: { name: 'hanaInstance' }}); // returns { hana: { host: '...', port: '...', user: '...', password: '...', ... } }\r\nvar hanaInstanceCredentials = services.hana;\r\n\r\n```\r\nFor specifics in the usage in different environments, read below.\r\n\r\n## Usage in Cloud Foundry and SAP XS Advanced\r\n\r\nCloud Foundry and SAP XS advanced both provide application configurations via environment variables.\r\nThe properties of the bound services are in [VCAP_SERVICES](http://docs.cloudfoundry.org/devguide/deploy-apps/environment-variable.html#VCAP-SERVICES) environment variable in both cases.\r\n\r\n### Service Lookup\r\n\r\nNormally in Cloud Foundry you bind a service instance to your application with a command like this one:\r\n```sh\r\ncf bind-service my-app aservice\r\n```\r\n\r\nHere is how you can get this service configuration in your Node.js application if you don't know the instance name in advance:\r\n```js\r\nvar xsenv = require('@sap/xsenv');\r\n\r\nvar services = xsenv.readServices();\r\nvar svc = services[process.env.SERVICE_NAME];\r\n```\r\n\r\nYou can look up services based on their metadata:\r\n```js\r\nvar svc = xsenv.serviceCredentials({ tag: 'hdb' });\r\nconsole.log(svc); // prints { host: '...', port: '...', user: '...', password: '...', ... }\r\n```\r\nThis example finds a service binding with `hdb` in the tags.\r\nSee [Service Query](#service-query) below for description of the supported query values.\r\n\r\nYou can also look up multiple services in a single call:\r\n```js\r\nvar xsenv = require('@sap/xsenv');\r\n\r\nvar services = xsenv.getServices({\r\n  hana: { tag: 'hdb' },\r\n  scheduler: { label: 'jobs' }\r\n});\r\n\r\nvar hanaCredentials = services.hana;\r\nvar schedulerCredentials = services.scheduler;\r\n```\r\nThis example finds two services - one with tag `hdb` and the other with label `jobs`.\r\n`getServices` function provides additional convenience that default service configuration can be provided in a JSON file.\r\n\r\nTo test the above example locally, create a file called `default-services.json` in the working directory of your application.\r\nThis file should contain something like this:\r\n```json\r\n{\r\n  \"hana\": {\r\n    \"host\": \"localhost\",\r\n    \"port\": \"30015\",\r\n    \"user\": \"SYSTEM\",\r\n    \"password\": \"secret\"\r\n  },\r\n  \"scheduler\": {\r\n    \"host\": \"localhost\",\r\n    \"port\": \"4242\",\r\n    \"user\": \"my_user\",\r\n    \"password\": \"secret\"\r\n  }\r\n}\r\n```\r\n**Note:** The result property names (`hana` and `scheduler`) are the same as those in the query object and also those in `default-services.json`.\r\n\r\n[Local environment setup](#local-environment-setup) describes an alternative approach to provide service configurations for local testing.\r\n\r\n### User-Provided Service Instances\r\n\r\nWhile this package can look up any kind of bound service instances, you should be aware that [User-Provided Service Instances](https://docs.cloudfoundry.org/devguide/services/user-provided.html) have less properties than managed service instances. Here is an example:\r\n```json\r\n  \"VCAP_SERVICES\": {\r\n    \"user-provided\": [\r\n      {\r\n        \"name\": \"pubsub\",\r\n        \"label\": \"user-provided\",\r\n        \"tags\": [],\r\n        \"credentials\": {\r\n          \"binary\": \"pubsub.rb\",\r\n          \"host\": \"pubsub01.example.com\",\r\n          \"password\": \"p@29w0rd\",\r\n          \"port\": \"1234\",\r\n          \"username\": \"pubsubuser\"\r\n        },\r\n        \"syslog_drain_url\": \"\"\r\n\t  }\r\n    ]\r\n  }\r\n```\r\nAs you can see the only usable property is the `name`. In particular, there are no tags for a user-provided services.\r\n\r\n\r\n## Usage in Kubernetes\r\n\r\nKubernetes offers several ways of handling application configurations for bound services and certificates. @sap/xsenv expects that such configurations are handled as Kubernetes Secrets and mounted as files to the pod at a specific path. This path can be provided by the application developer, but the default is `/etc/secrets/sapcp`. From there, @sap/xsenv assumes that the directory structure is the following `/etc/secrets/sapcp/<service-name>/<instance-name>`. Here `<service-name>` and `<instance-name>` are both directories and the latter contains the credentials/configurations for the service instance as files, where the file name is the name of the configuration/credential and the content is respectively the value.\r\n\r\nFor example, the following folder structure:\r\n```sh\r\n\r\n/etc/\r\n    /secrets/\r\n            /sapcp/\r\n                 /hana/\r\n                 |    /hanaInst1/\r\n                 |    |          /user1\r\n                 |    |          /pass1\r\n                 |    /hanaInst2/\r\n                 |               /user2\r\n                 |               /pass2\r\n                 /xsuaa/\r\n                       /xsuaaInst/\r\n                                  /user\r\n                                  /pass\r\n```\r\nresembles two instances of service `hana` - `hanaInst1` and `hanaInst2` each with their own credentials/configurations and one instance of service `xsuaa` called `xsuaaInst` with its credentials.\r\n\r\nIn Kubernetes you can create and bind to a service instance in the following way using the Service Catalog:\r\n\r\n```sh\r\nsvcat provision xsuaaInst --class xsuaa --plan application\r\nsvcat bind xsuaaInst --name xsuaaBind\r\n```\r\nUpon creation of the binding, the Service Catalog will create a Kubernetes secret (by default with the same name as the binding) containing credentials, configurations and certificates. This secret can then be mounted to the pod as a volume.\r\n\r\nThe following *deployment.yml* file would generate the file structure above, assuming we have bindings `hanaBind1`, `hanaBind2` and `xsuaaBind` for service instances `hanaInst1`, `hanaInst2` and `xsuaaInst` created with Service Catalog:\r\n```sh\r\n...\r\n     containers:\r\n      - name: app\r\n        image: app-image:1.0.0\r\n        ports:\r\n          - appPort: 8080\r\n        volumeMounts:\r\n        - name: hana-volume-1\r\n          mountPath: \"/etc/secrets/sapcp/hana/hanaInst1\"\r\n          readOnly: true\r\n        - name: hana-volume-2\r\n          mountPath: \"/etc/secrets/sapcp/hana/hanaInst2\"\r\n          readOnly: true\r\n        - name: xsuaa-volume\r\n          mountPath: \"/etc/secrets/sapcp/xsuaa/xsuaaInst\"\r\n          readOnly: true\r\n      volumes:\r\n      - name: hana-volume-1\r\n        secret:\r\n          secretName: hanaBind1\r\n      - name: hana-volume-2\r\n        secret:\r\n          secretName: hanaBind2\r\n      - name: xsuaa-volume\r\n        secret:\r\n          secretName: xsuaaBind\r\n\r\n```\r\n\r\nOf course, you can also create Kubernetes secrets directly with `kubectl` and  mount them to the pod. As long as the mount path follows the `<root-path>/<service-name>/<instance-name>` pattern, @sap/xsenv will be able to read and filter the bound services configurations.\r\n\r\n**Note**: The library attempts to parse property values which represent valid JSON objects.\r\nProperty values representing arrays are not being parsed.\r\n\r\nThe following service credentials:\r\n\r\n```\r\n/etc/\r\n    /secrets/\r\n            /sapcp/\r\n                 /some-service/\r\n                       /some-instance/\r\n                                  /url   - containing https://some-service\r\n                                  /uaa   - containing { \"url\": \"https://uaa\", \"clientid\": \"client\", \"clientsecret\": \"secret\" }\r\n                                  /other - containing [1, \"two\"]\r\n```\r\n\r\nWill be available to the application as:\r\n\r\n```js\r\n{\r\n  url: 'https://some-service',\r\n  uaa: {\r\n    url: 'https://uaa',\r\n    clientid: 'client',\r\n    clientsecret: 'secret'\r\n  },\r\n  other: '[1, \"two\"]'\r\n}\r\n```\r\n\r\n### Service Lookup\r\n\r\nService look up in the Kubernetes environment looks the same way as it does in the Cloud Foundry one.\r\n\r\nLooking at the above example of bound services here is how you can get the service configuration of `hanaInst1` in your node application:\r\n\r\n```js\r\nvar xsenv = require('@sap/xsenv');\r\n\r\nvar services = xsenv.readServices();\r\nconsole.log(services.hanaInst1.credentials); // prints { user1: '...', pass1: '...', ... }\r\n```\r\n\r\nHere is how to lookup the service based on its metadata in Kubernetes:\r\n```js\r\nvar svc = xsenv.serviceCredentials({ label: 'hana' });\r\nconsole.log(svc); // prints { host: '...', port: '...', user: '...', passwrod: '...', ... }\r\n```\r\nThis example finds a service binding with `hana` as a label. Note that for Kubernetes lookup based on metadata is limited. See [Service Query](#service-query) below for description of the supported query values in Cloud Foundry and Kubernetes.\r\n\r\n\r\nIf you have mounted your secrets to a different path, you can pass it to @sap/xsenv like so:\r\n\r\n```js\r\nvar xsenv = require('@sap/xsenv');\r\n\r\nvar services = xsenv.getServices('/some/user/path', {\r\n  hana: { name: 'hanaInst1' },\r\n  xsuaa: { label: 'xsuaa' }\r\n});\r\n\r\nvar hanaCredentials = services.hana;\r\nvar schedulerCredentials = services.xsuaa;\r\n```\r\n\r\n## Local Usage\r\n\r\nFor local testing you can provide configurations by yourself. This package allows you to provide default configurations in a separate configuration file.\r\n* This reduces clutter by removing configuration data from the app code.\r\n* You don't have to set env vars manually each time you start your app.\r\n* Different developers can use their own configurations for their local tests without changing files under source control. Just add this configuration file to `.gitignore` and `.cfignore`.\r\n\r\nYou can provide default configurations on two levels:\r\n* For bound services via `getServices()` and `default-services.json`\r\n* For any environment variable via `loadEnv()` and `default-env.json`\r\n\r\n## Service Query\r\n\r\nBoth `getServices` and `filterServices` use the same service query values. Due to specifics of the environment the queries in Cloud Foundry can be richer - see property table below.\r\n\r\nQuery value | Description\r\n------------|------------\r\n{string}    | Matches the service with the same service instance name (`name` property). Same as `{ name: '<string>' }`.\r\n{object}    | All properties of the given object should match corresponding service instance properties as they appear in VCAP_SERVICES or the Kubernetes secret. See below what is supported on each platform.\r\n{function}  | A function that takes a service object as argument and returns `true`, only if it is considered a match.\r\n\r\nIf an object is given as a query value, it may have the following properties:\r\n\r\nProperty | CF  | K8S | Description\r\n---------|-----|-----|------------\r\n`name`   | yes | yes |Service instance name - the name you use to bind the service\r\n`label`  | yes | yes |Service name - the name shown by `cf marketplace`\r\n`tag`    | yes | no  |Should match any of the service tags\r\n`plan`   | yes | no  |Service instance plan - the plan you use in `cf create-service`\r\n\r\nIf multiple properties are given, _all_ of them must match.\r\n\r\n**Note:** Do not confuse the instance name (`name` property) with the service name (`label` property).\r\nSince you can have multiple instances of the same service bound to your app,\r\ninstance name is unique while service name is not.\r\n\r\nHere are some examples.\r\n\r\nFind a service instance by name:\r\n```js\r\nxsenv.serviceCredentials('hana');\r\n```\r\n\r\nLook up a service by tag:\r\n```js\r\nxsenv.serviceCredentials({ tag: 'relational' });\r\n```\r\n\r\nMatch several properties:\r\n```js\r\nxsenv.serviceCredentials({ label: 'hana', plan: 'shared' });\r\n```\r\n\r\nPass a custom filter function:\r\n```js\r\nxsenv.serviceCredentials(function(service) {\r\n  return /shared/.test(service.plan) && /hdi/.test(service.label);\r\n});\r\n```\r\nNotice that the filter function is called with the full service object as it appears in VCAP_SERVICES, but `serviceCredentials` returns only the `credentials` property of the matching service. The behaviour is the same in Kubernetes - the function will return only the contents of the `credentials` portion of the mounted secret.\r\n\r\n## API\r\n\r\n### getServices([path], query, [servicesFile])\r\n\r\nLooks up bound service instances matching the given query.\r\nIf a service is not found - returns default service configuration loaded from a JSON file. The order of lookup is VCAP_SERVICES -> mounted secrets path in K8S -> default service configuration.\r\n\r\n* `path` - (optional) A string containing the mount path where the secrets are located in Kubernetes. By default is \"/etc/secrets/sapcp\". For example, by default the credentials for an instance \"inst-name\" of service \"service-name\" would be located under \"/etc/secrets/sapcp/service-name/inst-name\".\r\n* `query` - An object describing requested services. Each property value is a filter as described in [Service Query](#service-query)\r\n* `servicesFile` - (optional) path to JSON file to load default service configuration (default is default-services.json).\r\nIf `null`, do not load default service configuration.\r\n* _returns_ - An object with the same properties as in query argument where the value of each property is the respective service credentials object\r\n* _throws_ - An error, if for some of the requested services no or multiple instances are found\r\n\r\n### serviceCredentials([path], filter)\r\n\r\nLooks up a bound service instance matching the given filter works for both the Kubernetes and Cloud Foundry environments.\r\n\r\n**Note:** This function does not load default service configuration from default-services.json.\r\n\r\n* `path` - (optional) A string containing the mount path where the secrets are located in Kubernetes. By default is \"/etc/secrets/sapcp\".\r\n* `filter` - Service lookup criteria as described in [Service Query](#service-query)\r\n* _returns_ - Credentials object of found service\r\n* _throws_ - An error in case no or multiple matching services are found\r\n\r\n### filterServices([path], filter)\r\n\r\nReturns all bound services that match the given criteria. Works in Cloud Foundry and Kubernetes.\r\n\r\n* `path` - (optional) A string containing the mount path where the secrets are located in Kubernetes. By default is \"/etc/secrets/sapcp\".\r\n* `filter` - Service lookup criteria as described in [Service Query](#service-query)\r\n* _returns_ - An array of credentials objects of matching services. Empty array, if no matches found.\r\n\r\n### readServices([path], [options])\r\n\r\n* `path` - (optional) A string containing the mount path where the secrets are located in Kubernetes. By default is \"/etc/secrets/sapcp\".\r\n* `options` - (optional) An object with options to customize behavior. Only supports field `disableCache` to disable K8s secrets caching.\r\n* _returns_ Returns an object where each service instance is mapped to its name. Works in Kubernetes and Cloud Foundry.\r\n\r\nFor example, given this VCAP_SERVICES:\r\n```\r\n  {\r\n    \"hana\" : [ {\r\n      \"credentials\" : {\r\n        ...\r\n      },\r\n      \"label\" : \"hana\",\r\n      \"name\" : \"hana1\",\r\n      \"plan\" : \"shared\",\r\n      \"tags\" : [ \"hana\", \"relational\" ]\r\n    },\r\n    {\r\n      \"credentials\" : {\r\n        ...\r\n      },\r\n      \"label\" : \"hana\",\r\n      \"name\" : \"hana2\",\r\n      \"plan\" : \"shared\",\r\n      \"tags\" : [ \"hana\", \"relational\", \"SP09\" ]\r\n    } ]\r\n  }\r\n```\r\n`readServices` would return:\r\n```\r\n{\r\n  hana1: {\r\n    \"credentials\" : {\r\n      ...\r\n    },\r\n    \"label\" : \"hana\",\r\n    \"name\" : \"hana1\",\r\n    \"plan\" : \"shared\",\r\n    \"tags\" : [ \"hana\", \"relational\" ]\r\n  },\r\n  hana2: {\r\n    \"credentials\" : {\r\n      ...\r\n    },\r\n    \"label\" : \"hana\",\r\n    \"name\" : \"hana2\",\r\n    \"plan\" : \"shared\",\r\n    \"tags\" : [ \"hana\", \"relational\", \"SP09\" ]\r\n  }\r\n}\r\n```\r\n\r\n\r\n### cfServiceCredentials(filter)\r\n\r\nSame as [serviceCredentials(filter)](#servicecredentialspath-filter) but works only in Cloud Foundry. It is recommended to use the generic function.\r\n\r\n### filterCFServices(filter)\r\n\r\nSame as [filterServices(filter)](#filterservicespath-filter) but works only in Cloud Foundry. It is recommended to use the generic function.\r\n\r\n### readCFServices()\r\n\r\nSame as [readServices()](#readservicespath) but works only in Cloud Foundry. It is recommended to use the generic function.\r\n\r\n## Local environment setup\r\n\r\nTo test your application locally you often need to setup its environment so that resembles the environment in Cloud Foundry or Kubernetes.\r\nYou can do this easily by defining the necessary environment variables in a JSON file.\r\n\r\nFor example you can create file _default-env.json_ with the following content in the working directory of the application :\r\n```json\r\n{\r\n  \"PORT\": 3000,\r\n  \"VCAP_SERVICES\": {\r\n    \"hana\": [\r\n      {\r\n        \"credentials\": {\r\n          \"host\": \"myhana\",\r\n          \"port\": \"30015\",\r\n          \"user\": \"SYSTEM\",\r\n          \"password\": \"secret\"\r\n        },\r\n        \"label\": \"hana\",\r\n        \"name\": \"hana-R90\",\r\n        \"tags\": [\r\n          \"hana\",\r\n          \"database\",\r\n          \"relational\"\r\n        ]\r\n      }\r\n    ],\r\n    \"scheduler\": [\r\n      {\r\n        \"credentials\": {\r\n          \"host\": \"localhost\",\r\n          \"port\": \"4242\",\r\n          \"user\": \"jobuser\",\r\n          \"password\": \"jobpassword\"\r\n        },\r\n        \"label\": \"scheduler\",\r\n        \"name\": \"jobscheduler\",\r\n        \"tags\": [\r\n          \"scheduler\"\r\n        ]\r\n      }\r\n    ]\r\n  }\r\n}\r\n```\r\nThen load it in your application:\r\n```js\r\nxsenv.loadEnv();\r\nconsole.log(process.env.PORT); // prints 3000\r\nconsole.log(xsenv.cfServiceCredentials('hana-R90')); // prints { host: 'myhana, port: '30015', user: 'SYSTEM', password: 'secret' }\r\n```\r\n\r\nThis way you don't need in your code conditional logic if it is running in Cloud Foundry or locally.\r\n\r\nYou can also use a different file name:\r\n```js\r\nxsenv.loadEnv('myenv.json');\r\n```\r\n\r\n### loadEnv([file])\r\n\r\nLoads the environment from a JSON file.\r\nThis function converts each top-level property to a string and sets it in the respective environment variable,\r\nunless it is already set. This function does not change existing environment variables. So the file content acts like default values for environment variables.\r\n\r\nThis function does not complain if the file does not exist.\r\n\r\n* `file` - optional name of JSON file to load, `'default-env.json'` by default. Does nothing if the file does not exist.\r\n\r\n## Loading SSL Certificates\r\n\r\nIf SSL is configured in XS advanced On-Premise Runtime, it will provide one or more\r\ntrusted CA certificates that applications can use to make SSL connections.\r\nIf present, the file paths of these certificates are listed in `XS_CACERT_PATH`\r\nenvironment variable separated by `path.delimiter` (`:` on LINUX and `;` on Windows).\r\n\r\n### loadCertificates([certPath])\r\n\r\nLoads the certificates listed in the given path.\r\nIf this argument is not provided, it uses `XS_CACERT_PATH` environment variable instead.\r\nIf that is not set either, the function returns `undefined`.\r\nThe function returns an array even if a single certificate is provided.\r\nThis function is synchronous.\r\n\r\n* `certPath` - optional string with certificate files to load. The file names are separated by `path.delimiter`. Default is `process.env.XS_CACERT_PATH`.\r\n* _returns_ - an array of loaded certificates or `undefined` if `certPath` argument is not provided\r\n* _throws_ - an error, if some of the files could not be loaded\r\n\r\nFor example, this code loads the trusted CA certificates so they are used for all\r\nsubsequent outgoing HTTPS connections:\r\n```js\r\nvar https = require('https');\r\nvar xsenv = require('@sap/xsenv');\r\n\r\nhttps.globalAgent.options.ca = xsenv.loadCertificates();\r\n```\r\n\r\nThis function can be used also to load SSL certificates for HANA like this:\r\n```js\r\nvar hdb = require('hdb');\r\nvar xsenv = require('@sap/xsenv');\r\n\r\nvar client = hdb.createClient({\r\n  host : 'hostname',\r\n  port : 30015,\r\n  ca   : xsenv.loadCertificates(),\r\n  ...\r\n});\r\n```\r\n\r\n## Debugging\r\n\r\nSet `DEBUG=xsenv` in the environment to enable debug traces. See [debug](https://www.npmjs.com/package/debug) package for details.\r\n"}]