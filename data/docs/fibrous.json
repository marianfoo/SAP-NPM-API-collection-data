[{"name":"LICENSE.md","content":"(The MIT License)\r\n\r\nCopyright (c) 2012 Good Eggs, Inc.\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining\r\na copy of this software and associated documentation files (the\r\n'Software'), to deal in the Software without restriction, including\r\nwithout limitation the rights to use, copy, modify, merge, publish,\r\ndistribute, sublicense, and/or sell copies of the Software, and to\r\npermit persons to whom the Software is furnished to do so, subject to\r\nthe following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be\r\nincluded in all copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,\r\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\r\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\r\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\r\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\r\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n\r\n\r\n"},{"name":"README.md","content":"Fibrous\r\n=======\r\n\r\nEasily mix asynchronous and synchronous programming styles in node.js.\r\n\r\n[![build status][travis-badge]][travis-link]\r\n[![npm version][npm-badge]][npm-link]\r\n[![mit license][license-badge]][license-link]\r\n[![we're hiring][hiring-badge]][hiring-link]\r\n\r\nBenefits\r\n--------\r\n\r\n* Easy-to-follow flow control for both serial and parallel execution\r\n* Complete stack traces, even for exceptions thrown within callbacks\r\n* No boilerplate code for error and exception handling\r\n* Conforms to standard node async API\r\n\r\nInstall\r\n-------\r\n\r\nFibrous requires node version 0.6.x or greater.\r\n\r\n```\r\nnpm install fibrous\r\n```\r\n\r\n\r\nExamples\r\n-----\r\n\r\nWould you rather write this:\r\n\r\n```javascript\r\nvar updateUser = function(id, attributes, callback) {\r\n  User.findOne(id, function (err, user) {\r\n    if (err) return callback(err);\r\n    \r\n    user.set(attributes);\r\n    user.save(function(err, updated) {\r\n      if (err) return callback(err);\r\n\r\n      console.log(\"Updated\", updated);\r\n      callback(null, updated);\r\n    });\r\n  });\r\n});\r\n```\r\n\r\nOr this, which behaves identically to calling code:\r\n\r\n```javascript\r\nvar updateUser = fibrous(function(id, attributes) {\r\n  user = User.sync.findOne(id);\r\n  user.set(attributes);\r\n  updated = user.sync.save();\r\n  console.log(\"Updated\", updated);\r\n  return updated;\r\n});\r\n```\r\n\r\nOr even better, with [CoffeeScript](http://coffeescript.org):\r\n\r\n```coffeescript\r\nupdateUser = fibrous (id, attributes) ->\r\n  user = User.sync.findOne(id)\r\n  user.set(attributes)\r\n  updated = user.sync.save()\r\n  console.log(\"Updated\", updated)\r\n  updated\r\n```\r\n\r\n### Without Fibrous\r\n\r\nUsing standard node callback-style APIs without fibrous, we write \r\n(from [the fs docs](http://nodejs.org/docs/v0.6.14/api/fs.html#fs_fs_readfile_filename_encoding_callback)):\r\n\r\n```javascript\r\nfs.readFile('/etc/passwd', function (err, data) {\r\n  if (err) throw err;\r\n  console.log(data);\r\n});\r\n```\r\n\r\n### Using sync\r\n\r\nUsing fibrous, we write:\r\n\r\n```javascript\r\ndata = fs.sync.readFile('/etc/passwd');\r\nconsole.log(data);\r\n```\r\n\r\n### Using future\r\n\r\nThis is the same as writing:\r\n\r\n```javascript\r\nfuture = fs.future.readFile('/etc/passwd');\r\ndata = future.wait();\r\nconsole.log(data);\r\n```\r\n\r\n### Waiting for Multiple Futures\r\n\r\nOr for multiple files read asynchronously:\r\n\r\n```javascript\r\nfutures = [\r\n  fs.future.readFile('/etc/passwd'),\r\n  fs.future.readFile('/etc/hosts')\r\n];\r\ndata = fibrous.wait(futures);\r\nconsole.log(data[0], data[1]);\r\n```\r\n\r\nNote that `fs.sync.readFile` is **not** the same as `fs.readFileSync`. The\r\nlatter blocks while the former allows the process to continue while\r\nwaiting for the file read to complete.\r\n\r\nMake It Fibrous\r\n---------------\r\n\r\nFibrous uses [node-fibers](https://github.com/laverdet/node-fibers)\r\nbehind the scenes.\r\n\r\n`wait` and `sync` (which uses `wait`\r\ninternally) require that they are called within a fiber. Fibrous\r\nprovides two easy ways to do this.\r\n\r\n### 1. fibrous Function Wrapper\r\n\r\nPass any function to `fibrous` and it returns a function that\r\nconforms to standard node async APIs with a callback as the last\r\nargument. The callback expects `err` as the first argument and the function\r\nresult as the second. Any exception thrown will be passed to the\r\ncallback as an error.\r\n\r\n```javascript\r\nvar asynFunc = fibrous(function() {\r\n  return fs.sync.readFile('/etc/passwd');\r\n});\r\n```\r\n\r\nis functionally equivalent to:\r\n\r\n```javascript\r\nvar asyncFunc = function(callback) {\r\n  fs.readFile('/etc/passwd', function(err, data) {\r\n    if (err) return callback(err);\r\n\r\n    callback(null, data);\r\n  });\r\n}\r\n```\r\n\r\nWith coffeescript, the fibrous version is even cleaner:\r\n\r\n```coffeescript\r\nasyncFunc = fibrous ->\r\n  fs.sync.readFile('/etc/passwd')\r\n```\r\n\r\n`fibrous` ensures that the passed function is\r\nrunning in an existing fiber (from higher up the call stack) or will\r\ncreate a new fiber if one does not already exist.\r\n\r\n### 2. Express/Connect Middleware\r\n\r\nFibrous provides [connect](http://www.senchalabs.org/connect/)\r\nmiddleware that ensures that every request runs in a fiber.\r\nIf you are using [express](http://expressjs.com/), you'll\r\nwant to use this middleware.\r\n\r\n```javascript\r\nvar express = require('express');\r\nvar fibrous = require('fibrous');\r\n\r\nvar app = express();\r\n\r\napp.use(fibrous.middleware);\r\n\r\napp.get('/', function(req, res){\r\n  data = fs.sync.readFile('./index.html', 'utf8');\r\n  res.send(data);\r\n});\r\n```\r\n\r\n### 3. Wrap-and-run with fibrous.run\r\n\r\n`fibrous.run` is a utility function that creates a fibrous function then executes it.\r\n\r\nProvide a callback to handle any errors and the return value of the passed function (if you need it).\r\nIf you don't provide a callback and there is an error, run will throw the error which will produce an uncaught exception.\r\nThat may be okay for quick and dirty work but is probably a bad idea in production code.\r\n\r\n```javascript\r\nfibrous.run(function() {\r\n  var data = fs.sync.readFile('/etc/passwd');\r\n  console.log(data.toString());\r\n  return data;\r\n}, function(err, returnValue) {\r\n  console.log(\"Handle both async and sync errors here\", err);\r\n});\r\n```\r\n\r\n### 4. Waiting on a callback\r\n\r\nSometimes you need to wait for a callback to happen that does not conform to `err, result` format (for example streams). In this case the following pattern works well:\r\n\r\n```javascript\r\nvar stream = <your stream>\r\n\r\nfunction wait(callback) {\r\n  stream.on('close', function(code) {\r\n    callback(null, code);\r\n  });\r\n}\r\n\r\nvar code = wait.sync();\r\n```\r\n\r\nDetails\r\n-------\r\n\r\n### Error Handling / Exceptions\r\n\r\nIn the above examples, if `readFile` produces an error, the fibrous versions\r\n(both `sync` and `wait`) will throw an exception. Additionally, the stack\r\ntrace will include the stack of the calling code unlike exceptions\r\ntypically thrown from within callback.\r\n\r\n\r\n### Testing\r\n\r\nFibrous provides a test helper for [jasmine-node](https://github.com/mhevery/jasmine-node) \r\nthat ensures that `beforeEach`, `it`, and `afterEach` run in a fiber.\r\nRequire it in your shared `spec_helper` file or in the spec files where\r\nyou want to use fibrous.\r\n\r\n```javascript\r\nrequire('fibrous/lib/jasmine_spec_helper');\r\n\r\ndescribe('My Spec', function() {\r\n  \r\n  it('tests something asynchronous', function() {\r\n    data = fs.sync.readFile('/etc/password');\r\n    expect(data.length).toBeGreaterThan(0);\r\n  });\r\n});\r\n```\r\n\r\nIf an asynchronous method called through fibrous produces an error, the\r\nspec helper will fail the spec.\r\n\r\n[mocha-fibers](https://github.com/tzeskimo/mocha-fibers) provides a fiber wrapper for [mocha](http://mochajs.org/).\r\n\r\nIf you write a helper for other testing frameworks, we'd love to include it in the project.\r\n\r\n### Console\r\n\r\nFibrous makes it much easier to work with asynchronous methods in an\r\ninteractive console, or REPL.\r\n\r\nIf you find yourself in an interactive session, you can require fibrous so that\r\nyou can use `future`.\r\n\r\n```\r\n> fs = require('fs');\r\n> require('fibrous');\r\n> data = fs.future.readFile('/etc/passwd', 'utf8');\r\n> data.get()\r\n```\r\n\r\nIn this example, `data.get()` will return the result of the future,\r\nprovided you have waited long enough for the future to complete.\r\n(The time it takes to type the next line is almost always long enough.)\r\n\r\nYou can't use `sync` in the above scenario because a fiber has not been created\r\nso you can't call `wait` on a future.\r\n\r\nFibrous does provide a bin script that creates a new interactive console where each command\r\nis run in a fiber so you can use sync. If you install fibrous with `npm install -g fibrous`\r\nor have `./node_modules/.bin` on your path, you can just run:\r\n\r\n```\r\n$ fibrous\r\nStarting fibrous node REPL...\r\n> fs = require('fs');\r\n> data = fs.sync.readFile('/etc/passwd', 'utf8');\r\n> console.log(data);\r\n##\r\n# User Database\r\n#\r\n...\r\n```\r\n\r\nOr for a CoffeeScript REPL:\r\n\r\n```\r\n$ fibrous -c [or --coffee]\r\nStarting fibrous coffee REPL...\r\ncoffee> fs = require 'fs'\r\ncoffee> data = fs.sync.readFile '/etc/passwd', 'utf8'\r\ncoffee> console.log data\r\n##\r\n# User Database\r\n#\r\n...\r\n```\r\n\r\n### Gotchas\r\n\r\n\r\nThe first time you call `sync` or `future` on an object, it builds the sync\r\nand future proxies so if you add a method to the object later, it will\r\nnot be proxied.\r\n\r\n#### With Express and `bodyParser` or `json`\r\n\r\nYou might be getting an error in Express that you are not in context of a fiber even after adding `fibrous.middleware` to your stack. This can happen if you added it before `express.json()` or `express.bodyParser()`. Here's an example:\r\n\r\n```javascript\r\n// might not work\r\napp.use(fibrous.middleware);\r\napp.use(express.bodyParser());\r\n\r\n// or\r\napp.use(fibrous.middleware);\r\napp.use(express.json());\r\n\r\n// should work\r\napp.use(express.bodyParser());\r\napp.use(fibrous.middleware);\r\n\r\n// or\r\napp.use(express.json());\r\napp.use(fibrous.middleware);\r\n```\r\n\r\nBehind The Scenes\r\n-----------------\r\n\r\n\r\n### Futures\r\n\r\nFibrous uses the `Future` implementation from [node-fibers](https://github.com/laverdet/node-fibers).\r\n\r\n`future.wait` waits for the future to resolve then returns the result while allowing the process\r\nto continue. `fibrous.wait` accepts a single future, multiple future arguments or an array of futures.\r\nIt returns the result of the future if passed just one, or an array of\r\nresults if passed multiple.\r\n\r\n`future.get` returns the result of the resolved future or throws an\r\nexception if not yet resolved.\r\n\r\n### Object & Function mixins\r\n\r\nFibrous mixes `future` and `sync` into `Function.prototype` so you can\r\nuse them directly as in:\r\n\r\n```javascript\r\nreadFile = require('fs').readFile;\r\ndata = readFile.sync('/etc/passwd');\r\n```\r\n\r\nFibrous adds `future` and `sync` to `Object.prototype` correctly so they\r\nare not enumerable.\r\n\r\nThese proxy methods also ignore all getters, even those that may\r\nreturn functions. If you need to call a getter with fibrous that returns an\r\nasynchronous function, you can do:\r\n\r\n```javascript\r\nfunc = obj.getter\r\nfunc.future.call(obj, args)\r\n```\r\n\r\n### Disclaimer\r\n\r\nSome people don't like libraries that mix in to Object.prototype\r\nand Function.prototype. If that's how you feel, then fibrous is probably\r\nnot for you. We've been careful to mix in 'right' so that we don't\r\nchange property enumeration and find that the benefits of having sync\r\nand future available without explicitly wrapping objects or functions\r\nare worth the philosophical tradeoffs.\r\n\r\n\r\nContributing\r\n------------\r\n\r\n```\r\ngit clone git://github.com/goodeggs/fibrous.git\r\nnpm install\r\nnpm test\r\n```\r\n\r\nFibrous is written in [coffeescript](http://coffeescript.org) with\r\nsource in `src/` compiled to `lib/`.\r\n\r\nTests are written with [jasmine-node](https://github.com/mhevery/jasmine-node) in `spec/`.\r\n\r\nRun tests with `npm test` which will also compile the coffeescript to\r\n`lib/`.\r\n\r\nPull requests are welcome. Please provide tests for your changes and\r\nfeatures. Thanks!\r\n\r\nContributors\r\n------------\r\n\r\n* Randy Puro ([randypuro](https://github.com/randypuro))\r\n* Alon Salant ([asalant](https://github.com/asalant))\r\n* Bob Zoller ([bobzoller](https://github.com/bobzoller))\r\n\r\n[travis-badge]: http://img.shields.io/travis/goodeggs/fibrous/master.svg?style=flat-square\r\n[travis-link]: https://travis-ci.org/goodeggs/fibrous\r\n[npm-badge]: http://img.shields.io/npm/v/fibrous.svg?style=flat-square\r\n[npm-link]: https://www.npmjs.org/package/fibrous\r\n[license-badge]: http://img.shields.io/badge/license-mit-blue.svg?style=flat-square\r\n[license-link]: LICENSE.md\r\n[hiring-badge]: https://img.shields.io/badge/we're_hiring-yes-brightgreen.svg?style=flat-square\r\n[hiring-link]: http://goodeggs.jobscore.com/?detail=Open+Source&sid=161\r\n"}]