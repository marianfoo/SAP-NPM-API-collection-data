[{"name":"CHANGELOG.md","content":"# Changelog\r\nAll notable changes to this project will be documented in this file.\r\n\r\nThe format is based on [Keep a Changelog](http://keepachangelog.com/en/1.0.0/)\r\nand this project adheres to [Semantic Versioning](http://semver.org/spec/v2.0.0.html).\r\n\r\n## [Unreleased]\r\nnothing yet\r\n\r\n## [2.3.2] - 2022-04-09\r\n### Changed\r\n- Add LICENSE file\r\n\r\n## [2.2.0] - 2018-08-15\r\n### Changed\r\n- addSubscriber and resetSubscriber operations now fail if there is no change\r\n  log modeled\r\n- changed expected metamodel version for generated NDSOs from 1.2.0 to 2.0.0.\r\n\r\n  While the metamodel itself does not contain incompatible changes,\r\n  previously deployed NDSOs won't be operable after upgrading the metdamodel\r\n  and require manual migration. This is intended but from the user's perspective\r\n  a breaking change which shall be reflected by a new major version according to\r\n  semver\r\n- getMetadata now also returns typeParam1, typeParam2 and defaultValue for\r\n  active data fields\r\n\r\n### Fixed\r\n- Fix storeCSV to only ignore actually empty rows (before, it also filtered\r\n  those only containing special characters). Also made check for line-endings\r\n  agnostic of the operating system\r\n\r\n## [2.1.0] - 2018-07-06\r\n### Added\r\n- Generated NDSOs are supported\r\n- Enhance metadata object to include sequence, procedures and metamodel information\r\n- Support generated synonyms (`DataWarehouse.DataStore` namespace) for DB objects\r\n- Implemented checkMetadataConsistency task\r\n\r\n### Changed\r\n- Added to operation storeSQL default handling for `NULL` values in columns\r\n  defined as `TIMESTAMP`\r\n\r\n### Fixed\r\n- Fix storeCSV to ignore empty lines\r\n\r\n## [2.0.2] - 2018-04-17\r\n### Fixed\r\n- Fix getRequestsFor*Deletion* to still provide loads if multiple loads are done\r\n  before a partial activation (before, the remaining loads were not returned)\r\n\r\n## [2.0.1] - 2018-04-16\r\n### Fixed\r\n- Fix getRequestsForActivation to still provide loads if multiple loads are done\r\n  before a partial activation (before, the remaining loads were not returned)\r\n- Fix repairRunningOperations to update lastTimestamp column in the\r\n  operationHistory table\r\n- Fix start messages for add-, reset- and removeSubscriber (showed '{0}' instead\r\n  of subscriber name)\r\n\r\n## [2.0.0] - 2018-04-13\r\n### Added\r\n- complete NDSO task reference on README (generated by\r\n  [`jsdoc-to-markdown`](https://www.npmjs.com/package/jsdoc-to-markdown))\r\n- support more [query options](./README.md#queryoptions)\r\n\r\n### Changed\r\n- **Incompatible:** Rewrite task getOperationInfo to now take generic query\r\n  options instead of dedicated filter parameters\r\n- **Incompatible:** Rewrite tasks getRowcountWithFilter and deleteWithFilter\r\n  to now filter by generic query options instead of using a provided where\r\n  clause\r\n- **Incompatible:** added default handling to operation storeSQL if the source\r\n  data contains `NULL` values. This required to explicitly list the columns in\r\n  the underlying SQL statement which effectively means, that the provided SQL\r\n  serving as `FROM` clause needs to provide the exact same column names as the\r\n  corresponding inbound queue has. As that was not required before, old\r\n  statements may not work anymore\r\n- deleteWithFilter now writes `filter` instead of `where` into operationDetails\r\n- Lists of request IDs are now shortened for more than 5 requests in log and\r\n  tracing messages (affects, for example, activate and rollback operations)\r\n- cleanupChangelog now writes `requestCount` and `requestList` into\r\n  operationDetails. `requestList` is shortened the same way as log entries\r\n- Reworked log messages (e.g. expanded 'lines' suffix by a dedicated detail\r\n  message listing how many rows have been inserted, updated, deleted as it has\r\n  been only for activate and rollback before)\r\n- cleanupChangelog is now rejected without writing an operation when run on NDSO\r\n  without change log\r\n- Minor performance improvement for getMetadata\r\n- Minor improvement of CSV checks (removes empty semicolons and final line breaks)\r\n\r\n### Fixed\r\n- Fix getRequestsForActivation and getRequestsForDeletion to also consider\r\n  running activations/deletions (the affected load requests are not returned\r\n  anymore)\r\n- Fix getRequestsForActivation to not fail without maxRequestId\r\n- Fix getRequestsForDeletion to also provide failed loads before last activation\r\n- Fix getRequestsForCleanup to also consider running rollbacks/clean-ups\r\n  (the affected activation requests are not returned anymore)\r\n- Fix getRequestsForRollback to exclude requests that have been extracted by\r\n  subscribers as rollbacks are just deleted from change log\r\n- Fix rollback for aggregation-related model changes. Before, when activating\r\n  with a `SUM` aggregation, then changing the model e.g. to a `MOV` aggregation\r\n  a rollback would not treat the before-image as negated because that\r\n  information was taken from active data, not the aggregation history. As a\r\n  result, data was likely corrupted after such a rollback\r\n- Fix deleteWithFilter to also write aggregation history if called with\r\n  `propagateDeletion`. In combination with the fix for rollback, this would have\r\n  resulted in data corruption after rollback of a deletion\r\n- Fix operation timestamps by updating the operation status once more before the\r\n  final commit\r\n\r\n### Removed\r\n- Remove checksum handling; hashes are neither verified nor updated anymore\r\n- Remove setConfig as there was no supported global config anymore anyway\r\n- Remove dependency to [`async`](https://www.npmjs.com/package/async)\r\n\r\n## [1.4.0] - 2018-02-06\r\n### Added\r\n- Promise support by all tasks (just omit callback to use it)\r\n- storeCSV now supports NDSOs with binary types (`VARBINARY` and `BLOB`). To\r\n  utilize this, provide data as hexadecimal strings, data is inserted via\r\n  `HEXTOBIN` SQL function\r\n\r\n### Changed\r\n- **Incompatible:** queryOption 'ord' now array as order is relevant and object\r\n  property order is unspecified\r\n- queryOption 'flt' now supports multiple values. Refer to [README](./README.md)\r\n  for details\r\n- deleteWithFilter now writes `where` instead of `sWhere` into operationDetails\r\n- Slight performance improvement overall by caching repeatedly retrieved\r\n  metadata\r\n- Complete refactoring of smokeTest, increasing coverage and significantly\r\n  improving performance\r\n- getDatastoreFeature now checks for existence of NDSO meta model instead of a\r\n  runtime environment variable. It also returns the meta model version\r\n- getMetadata now returns `defaultValue`s for inbound queue fields\r\n\r\n### Removed\r\n- setConfig option `earlyCallback`\r\n\r\n## [1.3.1] - 2017-12-18\r\n### Fixed\r\n- Fix timeout issue in smokeTest\r\n\r\n## [1.3.0] - 2017-12-15\r\n### Changed\r\n- **Incompatible**: Remove custom format `YYYYMMDDHH24MISS` for timestamps,\r\n  now ISO 8601 UTC strings (`YYYY-MM-DD\"T\"HH24:MI:SS.FF3\"Z\"`)\r\n  are sent and expected for filtering\r\n- **Incompatible**: Rewrite task getRequestInfo:\r\n  - now takes generic query options instead of multiple query parameters\r\n  - returns flat array as result instead of splitting loads and activations\r\n  - fix typo in `dependentRequests` property\r\n  - significant performance improvement by pushing whole logic to HANA\r\n\r\n### Deprecated\r\n- setConfig option `earlyCallback` shall not be used anymore and will be removed\r\n  soon.\r\n\r\n## [1.2.0] - 2017-12-12\r\n### Added\r\n- Add new task getMonitoringOverview that fetches all NDSOs of the provided\r\n  schema and provides information relevant for monitoring, like the last\r\n  operation and stats like table sizes and row count.\r\n\r\n  Note that the latter requires access to the monitoring views `SYS.M_CS_TABLE`\r\n  and `SYS.M_RS_TABLE`.\r\n- Add queryOptions to task getDataStores which support filtering, sorting and\r\n  paging. Refer to [README](./README.md) for details\r\n- Add support for drawing request IDs from sequence.\r\n\r\n  To do so the sequence must be named as annotation\r\n  `@DataStore.sequence: 'name with namespace'`. When introducing a sequence for\r\n  existing NDSOs, you should define `RESET BY` according to the maximum value\r\n  in the `idGenerator` table. Note that that table will continue to be updated\r\n  even if IDs are drawn by sequence.\r\n\r\n### Changed\r\n- Provide detail message with modified rows after operations activate and\r\n  rollback also for alternative client `@sap/hana-client`\r\n- Write application user into metadata tables, if available (falls back to the\r\n  technical `CURRENT_USER` if not)\r\n\r\n### Fixed\r\n- Fix crash in getOperationsForRequest if no operation found (may happen during\r\n  deleteAll)\r\n- Fix message logging for failed operations. It used to throw an error like\r\n  'statement.execBatch undefined'\r\n\r\n## [1.1.1] - 2017-11-20\r\n### Fixed\r\n- Fix getRequestsForActivation to return multiple requests again\r\n- Fix activation for multiple inbound queues\r\n- Fix logging of activation procedure parameters (was missing change log\r\n  info)\r\n\r\n## [1.1.0] - 2017-11-07\r\n### Added\r\n- Support for alternative HANA client `@sap/hana-client`\r\n\r\n### Changed\r\n- Improve log for activate/rollback: procedure result is now added as proper\r\n  log messages, not technical JSON (only for `node-hdb` client)\r\n- Use most recent version of `async`\r\n\r\n### Fixed\r\n- Follow-up fix of error handling if operation cannot be started\r\n- Fix rollback error if previous rollback failed\r\n\r\n## [1.0.5] - 2017-10-24\r\n### Changed\r\n- operation status of checkMetadataConsistency now reflects consistency result,\r\n  i.e., if there is an error the operation status will be FAILED\r\n- getRowcountWithFilter can now be called without the superfluous second DB\r\n  client, i.e., with `tracer, client, schema, ndso, whereClause, callback`.\r\n  The signature stays compatible though, the second client is just optional\r\n\r\n### Fixed\r\n- Fix smokeTest status polling which exited too early because smokeTest uses\r\n  the same DB connections for all operations and therefore sees status\r\n  'FINISHED' before it is committed. Now it polls for an internal indicator\r\n  instead\r\n- Fix error handling if operation cannot be started (e.g. called with not\r\n  existing NDSO name)\r\n- Fix repairRunningOperations. It used to check the runningOperations entity\r\n  but with introduction of startOperation that is written in the first commit\r\n  without locking again. The repair operation now checks the operationHistory\r\n  instead because the status update is the first update after the first commit.\r\n\r\n## [1.0.4] - 2017-10-13\r\n### Changed\r\n- Close database connections for operations when `earlyCallback` is active\r\n- Improve README.md\r\n\r\n## [1.0.3] - 2017-10-12\r\n### Fixed\r\n- Fix task smokeTest to also support `earlyCallback` option. It used to return\r\n  immediately, so the still running operations could interfere with test\r\n  clean-up procedures\r\n\r\n## [1.0.2] - 2017-10-11\r\n### Fixed\r\n- Fix number of written lines in various operation success messages\r\n- Fix list of deletable load requests (task getRequestsForDeletion); used to\r\n  return also activated and already deleted load requests\r\n- Fix list of requests for rollback (task getRequestsForRollback); used to\r\n  return also requests that the change log has meanwhile been cleared for\r\n  (resulted in technical error during rollback: 'Unique constraint violation')\r\n\r\n## [1.0.1] - 2017-10-06\r\n### Added\r\n- Add CHANGELOG.md (this file) and publishable README.md\r\n- Add new task `setConfig` that allows to set options by a key-value object.\r\n\r\n  Currently, only option `earlyCallback` is supported which makes operations\r\n  call the main callback function already after drawing IDs and writing the\r\n  operation into the history. This fixes various timeout issues when executing\r\n  operations in the HRTT Manage UI.\r\n\r\n### Fixed\r\n- Fix side-effect of disabling autocommit. In case of errors also the\r\n  affectedRequests entity was rolled back which resulted in an inconsistency and,\r\n  for example, failing load or activation requests were not shown on the UI.\r\n- Fix checksum calculation for LargeBinary (BLOB) fields as casting to VARCHAR\r\n  is invalid. As a result such NDSOs could not be activated.\r\n\r\n## [1.0.0] - 2017-09-29\r\n### Added\r\n- First release of this package; based on code from @sap/dwf-dws-client and\r\n  the Database Explorer (HANA Runtime Tools, HRTT)\r\n\r\n### Changed\r\n- Exclude internal helpers from the `tasks` folder which now only contains\r\n  real tasks to be invoked by a consumer\r\n\r\n### Fixed\r\n- Fix checksum handling in task CheckMetadataConsistency. It now works like the\r\n  check on Activate.\r\n"},{"name":"README.md","content":"# Native DataStore Object (NDSO) Service Backend\r\nThis Node.js package contains service implementations (tasks) of the Native\r\nDataStore Object. The NDSO backend is part of the SAP HANA Data Warehousing\r\nFoundation product.\r\n\r\nAs such it is used, for example, by the DataStore Manage UI of the Database\r\nExplorer or the Data Warehouse Scheduler.\r\n\r\n[Change Log](./CHANGELOG.md)\r\n\r\n**Be aware** that as this being a technical reuse package you are not supposed\r\nto consume it directly in a custom application. It is used by the aforementioned\r\nSAP products/tools though.\r\n\r\n# NDSO Task Reference\r\nNDSO tasks are exposed as simple asynchronous functions\r\n\r\n<a name=\"activate\"></a>\r\n\r\n## activate(tracer, client1, client2, schema, ndso, loadIds, [callback]) ⇒ <code>Promise</code>\r\nMoves data from inbound queue(s) to active data and change log.\r\nWriting of active data and change log is done by the HANA core procedure\r\n`SYS.DSO_ACTIVATE_CHANGES`.\r\n\r\nThis operation takes care of\r\n- verifying the provided load IDs\r\n- setting status of earlier, failed activations to 'DELETED'\r\n- compiling procedure options like aggregation behavior and before-image\r\n  handling\r\n- calling the procedure\r\n- deleting load data from inbound queue(s)\r\n\r\n**Fulfills**: [<code>ActivationResult</code>](#ActivationResult)  \r\n\r\n| Param | Type | Description |\r\n| --- | --- | --- |\r\n| tracer | <code>object</code> | tracer e.g. by @sap/logging |\r\n| client1 | <code>object</code> | DB client by node-hdb or @sap/hana-client |\r\n| client2 | <code>object</code> | DB client by node-hdb or @sap/hana-client |\r\n| schema | <code>string</code> | DB schema |\r\n| ndso | <code>string</code> | full DataStore name with namespace |\r\n| loadIds | <code>Array.&lt;integer&gt;</code> | load requests to be activated |\r\n| [callback] | <code>function</code> | callback function |\r\n\r\n<a name=\"addSubscriber\"></a>\r\n\r\n## addSubscriber(tracer, client1, client2, schema, ndso, subscriberName, [description], [callback]) ⇒ <code>Promise</code>\r\nAdds a new subscriber entry to the subscribers entity\r\n\r\n**Fulfills**: [<code>OperationResult</code>](#OperationResult)  \r\n\r\n| Param | Type | Description |\r\n| --- | --- | --- |\r\n| tracer | <code>object</code> | tracer e.g. by @sap/logging |\r\n| client1 | <code>object</code> | DB client by node-hdb or @sap/hana-client |\r\n| client2 | <code>object</code> | DB client by node-hdb or @sap/hana-client |\r\n| schema | <code>string</code> | DB schema |\r\n| ndso | <code>string</code> | full DataStore name with namespace |\r\n| subscriberName | <code>string</code> | name (and key) of the subscriber |\r\n| [description] | <code>string</code> | optional description |\r\n| [callback] | <code>function</code> | callback function |\r\n\r\n<a name=\"checkMetadataConsistency\"></a>\r\n\r\n## checkMetadataConsistency(tracer, client1, client2, schema, ndso, [callback]) ⇒ <code>Promise</code>\r\nPerforms consistency checks on the NDSO.\r\nThe operation fails, if inconsistencies are found\r\n\r\nPerformed checks ensure:\r\n- Inbound queues consistency\r\n- Change log entries deleted for cleaned up activations\r\n- Inbound queue entries deleted for finished activations\r\n- Affected requests consistency\r\n\r\n**Fulfills**: [<code>OperationResult</code>](#OperationResult)  \r\n\r\n| Param | Type | Description |\r\n| --- | --- | --- |\r\n| tracer | <code>object</code> | tracer e.g. by @sap/logging |\r\n| client1 | <code>object</code> | DB client by node-hdb or @sap/hana-client |\r\n| client2 | <code>object</code> | DB client by node-hdb or @sap/hana-client |\r\n| schema | <code>string</code> | DB schema |\r\n| ndso | <code>string</code> | full DataStore name with namespace |\r\n| [callback] | <code>function</code> | callback function |\r\n\r\n<a name=\"cleanupChangelog\"></a>\r\n\r\n## cleanupChangelog(tracer, client1, client2, schema, ndso, requestIds, [callback]) ⇒ <code>Promise</code>\r\nCleans up change log. The operation verifies, if the provided activation\r\nrequest IDs can be cleaned up and then deletes them from the change log\r\n\r\n**Fulfills**: [<code>OperationResult</code>](#OperationResult)  \r\n\r\n| Param | Type | Description |\r\n| --- | --- | --- |\r\n| tracer | <code>object</code> | tracer e.g. by @sap/logging |\r\n| client1 | <code>object</code> | DB client by node-hdb or @sap/hana-client |\r\n| client2 | <code>object</code> | DB client by node-hdb or @sap/hana-client |\r\n| schema | <code>string</code> | DB schema |\r\n| ndso | <code>string</code> | full DataStore name with namespace |\r\n| requestIds | <code>Array.&lt;integer&gt;</code> | activation requests for which change log shall be  deleted |\r\n| [callback] | <code>function</code> | callback function |\r\n\r\n<a name=\"cleanupMetadata\"></a>\r\n\r\n## cleanupMetadata(tracer, client1, client2, schema, ndso, [maxRequestId], [maxTimestamp], [callback]) ⇒ <code>Promise</code>\r\nCleans up metadata up to either the provided maximal activation request ID\r\nor corresponding creation timestamp (whichever is higher).\r\n\r\n**Fulfills**: [<code>OperationResult</code>](#OperationResult)  \r\n**Todo**\r\n\r\n- [ ] not implemented, i.e., it does not actually delete any data\r\n\r\n\r\n| Param | Type | Description |\r\n| --- | --- | --- |\r\n| tracer | <code>object</code> | tracer e.g. by @sap/logging |\r\n| client1 | <code>object</code> | DB client by node-hdb or @sap/hana-client |\r\n| client2 | <code>object</code> | DB client by node-hdb or @sap/hana-client |\r\n| schema | <code>string</code> | DB schema |\r\n| ndso | <code>string</code> | full DataStore name with namespace |\r\n| [maxRequestId] | <code>integer</code> | request ID up to which to clean up |\r\n| [maxTimestamp] | <code>string</code> | ISO 8601 UTC timestamp up to which to clean up |\r\n| [callback] | <code>function</code> | callback function |\r\n\r\n<a name=\"deleteAll\"></a>\r\n\r\n## deleteAll(tracer, client1, client2, schema, ndso, [callback]) ⇒ <code>Promise</code>\r\nDeletes all NDSO data (main and metadata entities).\r\nThe operation fails, if there are subscribers\r\n\r\n**Fulfills**: [<code>OperationResult</code>](#OperationResult)  \r\n\r\n| Param | Type | Description |\r\n| --- | --- | --- |\r\n| tracer | <code>object</code> | tracer e.g. by @sap/logging |\r\n| client1 | <code>object</code> | DB client by node-hdb or @sap/hana-client |\r\n| client2 | <code>object</code> | DB client by node-hdb or @sap/hana-client |\r\n| schema | <code>string</code> | DB schema |\r\n| ndso | <code>string</code> | full DataStore name with namespace |\r\n| [callback] | <code>function</code> | callback function |\r\n\r\n<a name=\"deleteRequest\"></a>\r\n\r\n## deleteRequest(tracer, client1, client2, schema, ndso, requestIds, [callback]) ⇒ <code>Promise</code>\r\nDeletes load requests. The operation verifies, if the provided request IDs\r\ncan be deleted and then deletes them from the inbound queue(s)\r\n\r\n**Fulfills**: [<code>OperationResult</code>](#OperationResult)  \r\n\r\n| Param | Type | Description |\r\n| --- | --- | --- |\r\n| tracer | <code>object</code> | tracer e.g. by @sap/logging |\r\n| client1 | <code>object</code> | DB client by node-hdb or @sap/hana-client |\r\n| client2 | <code>object</code> | DB client by node-hdb or @sap/hana-client |\r\n| schema | <code>string</code> | DB schema |\r\n| ndso | <code>string</code> | full DataStore name with namespace |\r\n| requestIds | <code>Array.&lt;integer&gt;</code> | load requests to be deleted |\r\n| [callback] | <code>function</code> | callback function |\r\n\r\n<a name=\"deleteWithFilter\"></a>\r\n\r\n## deleteWithFilter(tracer, client1, client2, schema, ndso, queryOptions, propagateDeletion, [callback]) ⇒ <code>Promise</code>\r\nDeletes active data by the provided query filter. Optionally writes an\r\nactivation request into the change log which allows rollback\r\n\r\n**Fulfills**: [<code>DeleteResult</code>](#DeleteResult)  \r\n\r\n| Param | Type | Description |\r\n| --- | --- | --- |\r\n| tracer | <code>object</code> | tracer e.g. by @sap/logging |\r\n| client1 | <code>object</code> | DB client by node-hdb or @sap/hana-client |\r\n| client2 | <code>object</code> | DB client by node-hdb or @sap/hana-client |\r\n| schema | <code>string</code> | DB schema |\r\n| ndso | <code>string</code> | full DataStore name with namespace |\r\n| queryOptions | [<code>QueryOptions</code>](#QueryOptions) | note that for this task, the 'options'  (and more specifically, the filter `flt`) are actually mandatory because the  context is selective deletion from active data which must not be  unrestricted (that would be deleteAll) |\r\n| propagateDeletion | <code>bool</code> | if true, deletions will be added to change log |\r\n| [callback] | <code>function</code> | callback function |\r\n\r\n<a name=\"getDataStores\"></a>\r\n\r\n## getDataStores(tracer, client, schema, [queryOptions], [callback]) ⇒ <code>Promise</code>\r\nProvides a list of NDSOs in the schema\r\n\r\n**Fulfills**: [<code>DataStores</code>](#DataStores)  \r\n\r\n| Param | Type | Description |\r\n| --- | --- | --- |\r\n| tracer | <code>object</code> | tracer e.g. by @sap/logging |\r\n| client | <code>object</code> | DB client by node-hdb or @sap/hana-client |\r\n| schema | <code>string</code> | DB schema |\r\n| [queryOptions] | [<code>QueryOptions</code>](#QueryOptions) |  |\r\n| [callback] | <code>function</code> | callback function |\r\n\r\n<a name=\"getDataStoreFeature\"></a>\r\n\r\n## getDataStoreFeature(tracer, client, schema, [callback]) ⇒ <code>Promise</code>\r\nProvides information if the NDSO metamodel exists in the schema.\r\nThe metamodel is a prerequisite to model NDSOs\r\n\r\n**Fulfills**: [<code>DataStoreFeature</code>](#DataStoreFeature)  \r\n\r\n| Param | Type | Description |\r\n| --- | --- | --- |\r\n| tracer | <code>object</code> | tracer e.g. by @sap/logging |\r\n| client | <code>object</code> | DB client by node-hdb or @sap/hana-client |\r\n| schema | <code>string</code> | DB schema |\r\n| [callback] | <code>function</code> | callback function |\r\n\r\n<a name=\"getLogForOperation\"></a>\r\n\r\n## getLogForOperation(tracer, client, schema, ndso, operationId, [callback]) ⇒ <code>Promise</code>\r\nProvides the message log for an operation\r\n\r\n**Fulfills**: [<code>LogForOperation</code>](#LogForOperation)  \r\n\r\n| Param | Type | Description |\r\n| --- | --- | --- |\r\n| tracer | <code>object</code> | tracer e.g. by @sap/logging |\r\n| client | <code>object</code> | DB client by node-hdb or @sap/hana-client |\r\n| schema | <code>string</code> | DB schema |\r\n| ndso | <code>string</code> | full DataStore name with namespace |\r\n| operationId | <code>integer</code> | ID of the operation logs shall be read for |\r\n| [callback] | <code>function</code> | callback function |\r\n\r\n<a name=\"getMetadata\"></a>\r\n\r\n## getMetadata(tracer, client, schema, ndso, [callback]) ⇒ <code>Promise</code>\r\nProvides NDSO metadata\r\n\r\n**Fulfills**: [<code>Metadata</code>](#Metadata)  \r\n\r\n| Param | Type | Description |\r\n| --- | --- | --- |\r\n| tracer | <code>object</code> | tracer e.g. by @sap/logging |\r\n| client | <code>object</code> | DB client by node-hdb or @sap/hana-client |\r\n| schema | <code>string</code> | DB schema |\r\n| ndso | <code>string</code> | full DataStore name with namespace |\r\n| [callback] | <code>function</code> | callback function |\r\n\r\n<a name=\"getMonitoringOverview\"></a>\r\n\r\n## getMonitoringOverview(tracer, client, schema, [queryOptions], [callback]) ⇒ <code>Promise</code>\r\nProvides monitoring relevant information about all NDSOs in the schema.\r\n\r\n**Fulfills**: [<code>MonitoringOverview</code>](#MonitoringOverview)  \r\n\r\n| Param | Type | Description |\r\n| --- | --- | --- |\r\n| tracer | <code>object</code> | tracer e.g. by @sap/logging |\r\n| client | <code>object</code> | DB client by node-hdb or @sap/hana-client |\r\n| schema | <code>string</code> | DB schema |\r\n| [queryOptions] | [<code>QueryOptions</code>](#QueryOptions) |  |\r\n| [callback] | <code>function</code> | callback function |\r\n\r\n<a name=\"getOperationInfo\"></a>\r\n\r\n## getOperationInfo(tracer, client, schema, ndso, [queryOptions], [callback]) ⇒ <code>Promise</code>\r\nProvides general request information\r\n\r\n**Fulfills**: [<code>OperationInfo</code>](#OperationInfo)  \r\n\r\n| Param | Type | Description |\r\n| --- | --- | --- |\r\n| tracer | <code>object</code> | tracer e.g. by @sap/logging |\r\n| client | <code>object</code> | DB client by node-hdb or @sap/hana-client |\r\n| schema | <code>string</code> | DB schema |\r\n| ndso | <code>string</code> | full DataStore name with namespace |\r\n| [queryOptions] | [<code>QueryOptions</code>](#QueryOptions) |  |\r\n| [callback] | <code>function</code> | callback function |\r\n\r\n<a name=\"getOperationsForRequest\"></a>\r\n\r\n## getOperationsForRequest(tracer, client, schema, ndso, requestId, [callback]) ⇒ <code>Promise</code>\r\nProvides the list of operations that affected a specific request\r\n\r\n**Fulfills**: [<code>OperationsForRequest</code>](#OperationsForRequest)  \r\n\r\n| Param | Type | Description |\r\n| --- | --- | --- |\r\n| tracer | <code>object</code> | tracer e.g. by @sap/logging |\r\n| client | <code>object</code> | DB client by node-hdb or @sap/hana-client |\r\n| schema | <code>string</code> | DB schema |\r\n| ndso | <code>string</code> | full DataStore name with namespace |\r\n| requestId | <code>integer</code> | request ID which to retrieve operations for |\r\n| [callback] | <code>function</code> | callback function |\r\n\r\n<a name=\"getRequestInfo\"></a>\r\n\r\n## getRequestInfo(tracer, client, schema, ndso, [queryOptions], [callback]) ⇒ <code>Promise</code>\r\nProvides general request information\r\n\r\n**Fulfills**: [<code>RequestInfo</code>](#RequestInfo)  \r\n\r\n| Param | Type | Description |\r\n| --- | --- | --- |\r\n| tracer | <code>object</code> | tracer e.g. by @sap/logging |\r\n| client | <code>object</code> | DB client by node-hdb or @sap/hana-client |\r\n| schema | <code>string</code> | DB schema |\r\n| ndso | <code>string</code> | full DataStore name with namespace |\r\n| [queryOptions] | [<code>QueryOptions</code>](#QueryOptions) |  |\r\n| [callback] | <code>function</code> | callback function |\r\n\r\n<a name=\"getRequestsForActivation\"></a>\r\n\r\n## getRequestsForActivation(tracer, client, schema, ndso, [maxRequestId], [callback]) ⇒ <code>Promise</code>\r\nProvides requests that can be activated. Condition:\r\n- finished load requests\r\n- after latest activation\r\n- not subject to a deleteRequest operation\r\n- (optional) load request ID lower than provided maxRequestId\r\n\r\n**Fulfills**: [<code>RequestsForOperation</code>](#RequestsForOperation)  \r\n\r\n| Param | Type | Description |\r\n| --- | --- | --- |\r\n| tracer | <code>object</code> | tracer e.g. by @sap/logging |\r\n| client | <code>object</code> | DB client by node-hdb or @sap/hana-client |\r\n| schema | <code>string</code> | DB schema |\r\n| ndso | <code>string</code> | full DataStore name with namespace |\r\n| [maxRequestId] | <code>integer</code> | request ID up to which to retrieve load  requests |\r\n| [callback] | <code>function</code> | callback function |\r\n\r\n<a name=\"getRequestsForCleanup\"></a>\r\n\r\n## getRequestsForCleanup(tracer, client, schema, ndso, [maxRequestId], [maxTimestamp], [callback]) ⇒ <code>Promise</code>\r\nProvides requests that can be cleaned up. Condition:\r\n- finished activation requests\r\n- not subject to rollback/clean-up operation\r\n- extracted by all subscribers\r\n- (optional) activation request ID less than or equal to provided\r\n  max ID or timestamp\r\n\r\n**Fulfills**: [<code>RequestsForOperation</code>](#RequestsForOperation)  \r\n\r\n| Param | Type | Description |\r\n| --- | --- | --- |\r\n| tracer | <code>object</code> | tracer e.g. by @sap/logging |\r\n| client | <code>object</code> | DB client by node-hdb or @sap/hana-client |\r\n| schema | <code>string</code> | DB schema |\r\n| ndso | <code>string</code> | full DataStore name with namespace |\r\n| [maxRequestId] | <code>integer</code> | request ID up to which to fetch requests |\r\n| [maxTimestamp] | <code>string</code> | ISO 8601 UTC timestamp up to which to fetch requests |\r\n| [callback] | <code>function</code> | callback function |\r\n\r\n<a name=\"getRequestsForDeletion\"></a>\r\n\r\n## getRequestsForDeletion(tracer, client, schema, ndso, [callback]) ⇒ <code>Promise</code>\r\nProvides requests that can be deleted. Condition:\r\n- load request failed OR finished and after latest activation\r\n- not subject to a deleteRequest operation\r\n\r\n**Fulfills**: [<code>RequestsForOperation</code>](#RequestsForOperation)  \r\n\r\n| Param | Type | Description |\r\n| --- | --- | --- |\r\n| tracer | <code>object</code> | tracer e.g. by @sap/logging |\r\n| client | <code>object</code> | DB client by node-hdb or @sap/hana-client |\r\n| schema | <code>string</code> | DB schema |\r\n| ndso | <code>string</code> | full DataStore name with namespace |\r\n| [callback] | <code>function</code> | callback function |\r\n\r\n<a name=\"getRequestsForRollback\"></a>\r\n\r\n## getRequestsForRollback(tracer, client, schema, ndso, minRequestId, [callback]) ⇒ <code>Promise</code>\r\nProvides requests that can be rolled back. Condition:\r\n- finished activation requests\r\n- after latest rollback/clean-up operation\r\n- not yet extracted by any subscriber (as rollbacks are just deleted from\r\n  change log, subscribers won't get a corresponding delta corrupting their\r\n  data)\r\n- (optional) load request ID greater than or equal to provided minRequestId\r\n\r\n**Fulfills**: [<code>RequestsForOperation</code>](#RequestsForOperation)  \r\n\r\n| Param | Type | Description |\r\n| --- | --- | --- |\r\n| tracer | <code>object</code> | tracer e.g. by @sap/logging |\r\n| client | <code>object</code> | DB client by node-hdb or @sap/hana-client |\r\n| schema | <code>string</code> | DB schema |\r\n| ndso | <code>string</code> | full DataStore name with namespace |\r\n| minRequestId | <code>integer</code> | request ID from which to roll back later activations |\r\n| [callback] | <code>function</code> | callback function |\r\n\r\n<a name=\"getRowcountWithFilter\"></a>\r\n\r\n## getRowcountWithFilter(tracer, client, schema, ndso, queryOptions, [callback]) ⇒ <code>Promise</code>\r\nProvides number of rows in active data filtered by the provided query filter\r\n\r\n**Fulfills**: [<code>RowcountWithFilter</code>](#RowcountWithFilter)  \r\n\r\n| Param | Type | Description |\r\n| --- | --- | --- |\r\n| tracer | <code>object</code> | tracer e.g. by @sap/logging |\r\n| client | <code>object</code> | DB client by node-hdb or @sap/hana-client |\r\n| schema | <code>string</code> | DB schema |\r\n| ndso | <code>string</code> | full DataStore name with namespace |\r\n| queryOptions | [<code>QueryOptions</code>](#QueryOptions) | note that for this task, the 'options'  (and more specifically, the filter `flt`) are actually mandatory because  this is a preview task for deleteWithFilter |\r\n| [callback] | <code>function</code> | callback function |\r\n\r\n<a name=\"getSubscribers\"></a>\r\n\r\n## getSubscribers(tracer, client, schema, ndso, [callback]) ⇒ <code>Promise</code>\r\nProvides a list of subscribers\r\n\r\n**Fulfills**: [<code>Subscribers</code>](#Subscribers)  \r\n\r\n| Param | Type | Description |\r\n| --- | --- | --- |\r\n| tracer | <code>object</code> | tracer e.g. by @sap/logging |\r\n| client | <code>object</code> | DB client by node-hdb or @sap/hana-client |\r\n| schema | <code>string</code> | DB schema |\r\n| ndso | <code>string</code> | full DataStore name with namespace |\r\n| [callback] | <code>function</code> | callback function |\r\n\r\n<a name=\"removeSubscriber\"></a>\r\n\r\n## removeSubscriber(tracer, client1, client2, schema, ndso, subscriberName, [callback]) ⇒ <code>Promise</code>\r\nRemoves a subscriber from the subscribers entity\r\n\r\n**Fulfills**: [<code>OperationResult</code>](#OperationResult)  \r\n\r\n| Param | Type | Description |\r\n| --- | --- | --- |\r\n| tracer | <code>object</code> | tracer e.g. by @sap/logging |\r\n| client1 | <code>object</code> | DB client by node-hdb or @sap/hana-client |\r\n| client2 | <code>object</code> | DB client by node-hdb or @sap/hana-client |\r\n| schema | <code>string</code> | DB schema |\r\n| ndso | <code>string</code> | full DataStore name with namespace |\r\n| subscriberName | <code>string</code> | name (and key) of the subscriber |\r\n| [callback] | <code>function</code> | callback function |\r\n\r\n<a name=\"repairRunningOperations\"></a>\r\n\r\n## repairRunningOperations(tracer, client1, client2, schema, ndso, [callback]) ⇒ <code>Promise</code>\r\nRepairs running operations that are not really running anymore and sets their\r\nstatus to failed. This is done by attempting to retrieve a lock for the\r\ncorresponding entry in the operation history\r\n\r\n**Fulfills**: [<code>OperationResult</code>](#OperationResult)  \r\n\r\n| Param | Type | Description |\r\n| --- | --- | --- |\r\n| tracer | <code>object</code> | tracer e.g. by @sap/logging |\r\n| client1 | <code>object</code> | DB client by node-hdb or @sap/hana-client |\r\n| client2 | <code>object</code> | DB client by node-hdb or @sap/hana-client |\r\n| schema | <code>string</code> | DB schema |\r\n| ndso | <code>string</code> | full DataStore name with namespace |\r\n| [callback] | <code>function</code> | callback function |\r\n\r\n<a name=\"resetSubscriber\"></a>\r\n\r\n## resetSubscriber(tracer, client1, client2, schema, ndso, subscriberName, [callback]) ⇒ <code>Promise</code>\r\nResets `maxRequestId` of a subscriber in the subscribers entity back to 0\r\n\r\n**Fulfills**: [<code>OperationResult</code>](#OperationResult)  \r\n\r\n| Param | Type | Description |\r\n| --- | --- | --- |\r\n| tracer | <code>object</code> | tracer e.g. by @sap/logging |\r\n| client1 | <code>object</code> | DB client by node-hdb or @sap/hana-client |\r\n| client2 | <code>object</code> | DB client by node-hdb or @sap/hana-client |\r\n| schema | <code>string</code> | DB schema |\r\n| ndso | <code>string</code> | full DataStore name with namespace |\r\n| subscriberName | <code>string</code> | name (and key) of the subscriber |\r\n| [callback] | <code>function</code> | callback function |\r\n\r\n<a name=\"rollback\"></a>\r\n\r\n## rollback(tracer, client1, client2, schema, ndso, activationIds, [callback]) ⇒ <code>Promise</code>\r\nRestores data from the change log back to active data.\r\nWriting of active data and change log is done by the HANA core procedure\r\n`SYS.DSO_ROLLBACK_CHANGES`.\r\n\r\nThis operation takes care of\r\n- verifying the provided activation IDs\r\n- compiling procedure options like aggregation behavior and before-image\r\n  handling\r\n- calling the procedure\r\n\r\n**Fulfills**: [<code>OperationResult</code>](#OperationResult)  \r\n\r\n| Param | Type | Description |\r\n| --- | --- | --- |\r\n| tracer | <code>object</code> | tracer e.g. by @sap/logging |\r\n| client1 | <code>object</code> | DB client by node-hdb or @sap/hana-client |\r\n| client2 | <code>object</code> | DB client by node-hdb or @sap/hana-client |\r\n| schema | <code>string</code> | DB schema |\r\n| ndso | <code>string</code> | full DataStore name with namespace |\r\n| activationIds | <code>Array.&lt;integer&gt;</code> | activation requests to roll back |\r\n| [callback] | <code>function</code> | callback function |\r\n\r\n<a name=\"storeCsv\"></a>\r\n\r\n## storeCsv(tracer, client1, client2, schema, ndso, iqName, data, withHeader, [callback]) ⇒ <code>Promise</code>\r\nLoads CSV data into the provided inbound queue.\r\n\r\nIf the data contain a header row, it is excluded from data but serves as\r\nfield list for the INSERT statement.\r\n\r\nData is generally loaded by just providing the data unaltered to the prepared\r\nstatement except for binary data types (VARBINARY, BLOB) where a hexadecimal\r\nstring is expected instead\r\n\r\n**Fulfills**: [<code>LoadResult</code>](#LoadResult)  \r\n\r\n| Param | Type | Description |\r\n| --- | --- | --- |\r\n| tracer | <code>object</code> | tracer e.g. by @sap/logging |\r\n| client1 | <code>object</code> | DB client by node-hdb or @sap/hana-client |\r\n| client2 | <code>object</code> | DB client by node-hdb or @sap/hana-client |\r\n| schema | <code>string</code> | DB schema |\r\n| ndso | <code>string</code> | full DataStore name with namespace |\r\n| iqName | <code>string</code> | inbound queue to load the data into |\r\n| data | <code>array</code> \\| <code>string</code> | CSV data as array or string |\r\n| withHeader | <code>bool</code> | load requests to be activated |\r\n| [callback] | <code>function</code> | callback function |\r\n\r\n<a name=\"storeSql\"></a>\r\n\r\n## storeSql(tracer, client1, client2, schema, ndso, iqName, externalSql, [callback]) ⇒ <code>Promise</code>\r\nLoads data into the provided inbound queue by the FROM clause provided via\r\n`externalSql`.\r\n\r\n`externalSql` needs to provide `technicalAttributes.recordMode` and all\r\nsemantical column names as the inbound queue (if the source table has\r\ndifferent column names, they must be aliased accordingly).\r\n\r\n**Fulfills**: [<code>LoadResult</code>](#LoadResult)  \r\n\r\n| Param | Type | Description |\r\n| --- | --- | --- |\r\n| tracer | <code>object</code> | tracer e.g. by @sap/logging |\r\n| client1 | <code>object</code> | DB client by node-hdb or @sap/hana-client |\r\n| client2 | <code>object</code> | DB client by node-hdb or @sap/hana-client |\r\n| schema | <code>string</code> | DB schema |\r\n| ndso | <code>string</code> | full DataStore name with namespace |\r\n| iqName | <code>string</code> | inbound queue to load the data into |\r\n| externalSql | <code>string</code> | SQL by which to load data (used as `FROM`  clause) |\r\n| [callback] | <code>function</code> | callback function |\r\n\r\n**Example**  \r\n```sql\r\n SELECT\r\n   ''    AS \"technicalAttributes.recordMode\",\r\n   CUST  AS \"CustomerName\",\r\n   PRICE AS \"Amount\"\r\n FROM CUST_PRICES\r\n```\r\n<a name=\"smokeTest\"></a>\r\n\r\n## smokeTest(tracer, client1, client2, schema, ndso, [callback]) ⇒ <code>Promise</code>\r\nPerforms a smoke test on the provided NDSO, executing all tasks, beginning\r\nwith operations related to subscribers, then deletes all of them and runs\r\ndeleteAll to have a defined start-state\r\n\r\n:warning: **Only use this in test environments!**\r\n\r\n**Fulfills**: [<code>OperationResult</code>](#OperationResult)  \r\n\r\n| Param | Type | Description |\r\n| --- | --- | --- |\r\n| tracer | <code>object</code> | tracer e.g. by @sap/logging |\r\n| client1 | <code>object</code> | DB client by node-hdb or @sap/hana-client |\r\n| client2 | <code>object</code> | DB client by node-hdb or @sap/hana-client |\r\n| schema | <code>string</code> | DB schema |\r\n| ndso | <code>string</code> | full DataStore name with namespace |\r\n| [callback] | <code>operationCallback</code> | callback function |\r\n\r\n<a name=\"ActivationResult\"></a>\r\n\r\n## ActivationResult\r\n**Properties**\r\n\r\n| Name | Type | Description |\r\n| --- | --- | --- |\r\n| operationId | <code>integer</code> | ID of the activate operation |\r\n| activationId | <code>integer</code> | ID of the resulting activation request |\r\n\r\n<a name=\"DeleteResult\"></a>\r\n\r\n## DeleteResult\r\n**Properties**\r\n\r\n| Name | Type | Description |\r\n| --- | --- | --- |\r\n| operationId | <code>integer</code> | ID of the deleteWithFilter operation |\r\n| [changeLogId] | <code>integer</code> | ID of the optional activation request |\r\n\r\n<a name=\"DataStores\"></a>\r\n\r\n## DataStores\r\n**Properties**\r\n\r\n| Name | Type | Description |\r\n| --- | --- | --- |\r\n| result | <code>Array.&lt;string&gt;</code> | NDSO names |\r\n\r\n<a name=\"DataStoreFeature\"></a>\r\n\r\n## DataStoreFeature\r\n**Properties**\r\n\r\n| Name | Type | Description |\r\n| --- | --- | --- |\r\n| isDataStoreActive | <code>bool</code> | true, if metamodel found |\r\n| [version] | <code>string</code> | model version |\r\n\r\n<a name=\"LogForOperation\"></a>\r\n\r\n## LogForOperation\r\n**Properties**\r\n\r\n| Name | Type | Description |\r\n| --- | --- | --- |\r\n| result | <code>Array.&lt;object&gt;</code> |  |\r\n| result.posit | <code>integer</code> | defines message order |\r\n| result.timestamp | <code>string</code> | ISO 8601 UTC timestamp of message  creation |\r\n| result.msgType | <code>string</code> | message severity |\r\n| result.msgNumber | <code>integer</code> | numeric message ID |\r\n| result.msgText | <code>string</code> | message text |\r\n\r\n<a name=\"MetadataMetaTable\"></a>\r\n\r\n## MetadataMetaTable\r\n**Properties**\r\n\r\n| Name | Type | Description |\r\n| --- | --- | --- |\r\n| name | <code>string</code> | entity name of the meta table |\r\n| fullName | <code>string</code> | fully qualified and quoted table name including  schema and namespace |\r\n\r\n<a name=\"MetadataActiveDataField\"></a>\r\n\r\n## MetadataActiveDataField\r\n**Properties**\r\n\r\n| Name | Type | Description |\r\n| --- | --- | --- |\r\n| name | <code>string</code> | field name |\r\n| isKey | <code>bool</code> | indicates, if field is a semantical key |\r\n| aggregation | <code>string</code> | defines before-image behavior (NOP or SUM) |\r\n| sqlDataTypename | <code>string</code> | HANA data type |\r\n| [typeParam1] | <code>integer</code> | parameter attribute 1 (e.g. length) |\r\n| [typeParam2] | <code>integer</code> | parameter attribute 2 (e.g. scale) |\r\n| [defaultValue] | <code>string</code> | default value |\r\n\r\n<a name=\"MetadataChangeLogField\"></a>\r\n\r\n## MetadataChangeLogField\r\n**Properties**\r\n\r\n| Name | Type | Description |\r\n| --- | --- | --- |\r\n| name | <code>string</code> | field name |\r\n| isKey | <code>bool</code> | indicates, if field is a semantical key |\r\n| sqlDataTypename | <code>string</code> | HANA data type |\r\n\r\n<a name=\"MetadataInboundQueueField\"></a>\r\n\r\n## MetadataInboundQueueField\r\n**Properties**\r\n\r\n| Name | Type | Description |\r\n| --- | --- | --- |\r\n| name | <code>string</code> | field name |\r\n| isKey | <code>bool</code> | indicates, if field is a semantical key |\r\n| aggregation | <code>string</code> | defines aggregation behavior (NOP, MOV, MIN,  MAX or SUM) |\r\n| sqlDataTypename | <code>string</code> | HANA data type |\r\n| [typeParam1] | <code>integer</code> | parameter attribute 1 (e.g. length) |\r\n| [typeParam2] | <code>integer</code> | parameter attribute 2 (e.g. scale) |\r\n| [defaultValue] | <code>string</code> | default value |\r\n\r\n<a name=\"MetadataProcedure\"></a>\r\n\r\n## MetadataProcedure\r\n**Properties**\r\n\r\n| Name | Type | Description |\r\n| --- | --- | --- |\r\n| name | <code>string</code> | qualified name of the procedure (with namespace,  without schema) |\r\n| ifVersion | <code>string</code> | interface version of the procedure in the form X.Y (e.g. 1.0), major version incremented for backwards incompatible changes and minor for backwards compatible changes |\r\n\r\n<a name=\"Metadata\"></a>\r\n\r\n## Metadata\r\n**Properties**\r\n\r\n| Name | Type | Description |\r\n| --- | --- | --- |\r\n| name | <code>string</code> | NDSO name |\r\n| snapshotSupport | <code>bool</code> | if true, every activation will overwrite  the complete active data table, i.e., inbound queue data is considered to  always be complete |\r\n| operationHistory | [<code>MetadataMetaTable</code>](#MetadataMetaTable) | operation history containing  operation ID, timestamp, user, status etc. |\r\n| affectedRequests | [<code>MetadataMetaTable</code>](#MetadataMetaTable) | mapping table of n:m  relation of operations to requests |\r\n| aggregationHistory | [<code>MetadataMetaTable</code>](#MetadataMetaTable) | stores aggregation  behavior on activation. Needed to account for model changes between  activation and rollback |\r\n| logMessages | [<code>MetadataMetaTable</code>](#MetadataMetaTable) | log messages per operation |\r\n| idGen | [<code>MetadataMetaTable</code>](#MetadataMetaTable) | indicates request type (load,  activation, general operation). Without sequence, new IDs are drawn based on  the content of this table |\r\n| subscribers | [<code>MetadataMetaTable</code>](#MetadataMetaTable) | stores subscribers doing  delta-extractions from the change log. The latest extracted activation  requests are written by each subscriber and affect housekeeping, like  cleanupChangelog |\r\n| activeData | <code>object</code> | main, reportable data entity |\r\n| activeData.name | <code>string</code> | entity name of the data table |\r\n| activeData.fullName | <code>string</code> | fully qualified and quoted table  name including schema and namespace |\r\n| activeData.fields | [<code>Array.&lt;MetadataActiveDataField&gt;</code>](#MetadataActiveDataField) |  |\r\n| [changeLog] | <code>object</code> | optional data entity to track changes |\r\n| changeLog.name | <code>string</code> | entity name of the data table |\r\n| changeLog.fullName | <code>string</code> | fully qualified and quoted table  name including schema and namespace |\r\n| changeLog.fields | [<code>Array.&lt;MetadataChangeLogField&gt;</code>](#MetadataChangeLogField) |  |\r\n| activationQueues | <code>Array.&lt;object&gt;</code> | one or more data entity to queue  inbound data for activation |\r\n| activationQueues.name | <code>string</code> | entity name of the data table |\r\n| activationQueues.fullName | <code>string</code> | fully qualified and quoted  table name including schema and namespace |\r\n| activationQueues.fields | [<code>Array.&lt;MetadataInboundQueueField&gt;</code>](#MetadataInboundQueueField) |  |\r\n| procedures | <code>object.&lt;string, MetadataProcedure&gt;</code> | map of supported  SQL procedures. Key is the operation identifier, e.g. LOAD |\r\n| sequence | <code>string</code> | sequence used to draw new IDs |\r\n| metaModel | <code>object</code> | information about current NDSO metamodel |\r\n| metaModel.version | <code>string</code> | metamodel version |\r\n\r\n<a name=\"MonitoringTableStats\"></a>\r\n\r\n## MonitoringTableStats\r\n**Properties**\r\n\r\n| Name | Type | Description |\r\n| --- | --- | --- |\r\n| tableName | <code>string</code> | table name |\r\n| [size] | <code>integer</code> | table estimated maximal memory size in bytes  (not provided, if user lacks authorization) |\r\n| [rows] | <code>integer</code> | table row count (not provided, if user lacks  authorization) |\r\n\r\n<a name=\"MonitoringOverview\"></a>\r\n\r\n## MonitoringOverview\r\n**Properties**\r\n\r\n| Name | Type | Description |\r\n| --- | --- | --- |\r\n| result | <code>Array.&lt;object&gt;</code> |  |\r\n| result.name | <code>string</code> | NDSO name |\r\n| result.lastOp | <code>string</code> | type of the last operation |\r\n| result.lastOpBy | <code>string</code> | user last changing the last operation |\r\n| result.lastOpAt | <code>string</code> | ISO 8601 UTC timestamp when the  last operation was last changed |\r\n| result.lastOpStatus | <code>string</code> | status of the last operation |\r\n| result.subscribers | <code>integer</code> | number of subscribers |\r\n| result.stats | <code>object</code> | table statistics |\r\n| result.stats.activeData | [<code>MonitoringTableStats</code>](#MonitoringTableStats) | stats for  active data entity |\r\n| result.stats.inboundQueues | [<code>Array.&lt;MonitoringTableStats&gt;</code>](#MonitoringTableStats) | stats for  inbound queue entities |\r\n| [result.stats.changeLog] | [<code>MonitoringTableStats</code>](#MonitoringTableStats) | optional stats  for change log entity |\r\n| [result.message] | <code>string</code> | optional warning message derived from  authorization errors by HANA; thrown, if user lacks authorization for  monitoring synonyms (e.g. M_CS_TABLES) |\r\n\r\n<a name=\"OperationInfo\"></a>\r\n\r\n## OperationInfo\r\n**Properties**\r\n\r\n| Name | Type | Description |\r\n| --- | --- | --- |\r\n| result | <code>Array.&lt;object&gt;</code> |  |\r\n| result.operationId | <code>integer</code> | operation ID |\r\n| result.operation | <code>string</code> | operation type |\r\n| result.status | <code>string</code> | operation status |\r\n| result.userName | <code>string</code> | user last changing the operation |\r\n| result.lastTimestamp | <code>string</code> | ISO 8601 UTC timestamp when the  operation was last changed |\r\n| [result.operationDetails] | <code>object</code> | optional operation details |\r\n\r\n<a name=\"OperationsForRequest\"></a>\r\n\r\n## OperationsForRequest\r\n**Properties**\r\n\r\n| Name | Type | Description |\r\n| --- | --- | --- |\r\n| result | <code>Array.&lt;object&gt;</code> |  |\r\n| result.operationId | <code>integer</code> | operation ID |\r\n| result.operation | <code>string</code> | operation type |\r\n| result.status | <code>string</code> | operation status |\r\n| result.userName | <code>string</code> | user last changing the operation |\r\n| result.lastTimestamp | <code>string</code> | ISO 8601 UTC timestamp when the  operation was last changed |\r\n| result.affectedRequests | <code>Array.&lt;integer&gt;</code> | related request IDs |\r\n\r\n<a name=\"RequestInfo\"></a>\r\n\r\n## RequestInfo\r\n**Properties**\r\n\r\n| Name | Type | Description |\r\n| --- | --- | --- |\r\n| result | <code>Array.&lt;object&gt;</code> |  |\r\n| result.operationId | <code>integer</code> | ID of the last operation affecting  the request |\r\n| result.operation | <code>string</code> | type of the last operation affecting  the request |\r\n| result.status | <code>string</code> | status of the last operation affecting  the request |\r\n| result.userName | <code>string</code> | user last changing the operation |\r\n| result.startTimestamp | <code>string</code> | ISO 8601 UTC timestamp when the  operation was started |\r\n| result.lastTimestamp | <code>string</code> | ISO 8601 UTC timestamp when the  operation was last changed |\r\n| result.dependentRequests | <code>Array.&lt;integer&gt;</code> | related request IDs |\r\n| result.requestStatus | <code>string</code> | current status of the request  (derived from the latest operation affecting it) |\r\n| [result.operationDetails] | <code>object</code> | optional operation details |\r\n\r\n<a name=\"RowcountWithFilter\"></a>\r\n\r\n## RowcountWithFilter\r\n**Properties**\r\n\r\n| Name | Type | Description |\r\n| --- | --- | --- |\r\n| result | <code>Array.&lt;object&gt;</code> |  |\r\n| result.tableName | <code>string</code> | fully qualified name of active data table |\r\n| result.rowCount | <code>integer</code> | total number of rows |\r\n\r\n<a name=\"Subscribers\"></a>\r\n\r\n## Subscribers\r\n**Properties**\r\n\r\n| Name | Type | Description |\r\n| --- | --- | --- |\r\n| result | <code>Array.&lt;object&gt;</code> |  |\r\n| result.subscriberName | <code>string</code> | subscriber name |\r\n| result.description | <code>string</code> | additional description |\r\n| result.userName | <code>string</code> | user that created the subscriber |\r\n| result.creationTimestamp | <code>string</code> | ISO 8601 UTC timestamp of the  subscriber creation |\r\n| result.maxRequest | <code>integer</code> | last activation request the  subscriber extracted from the change log |\r\n| result.pushNotification | <code>string</code> | not implemented |\r\n\r\n<a name=\"OperationResult\"></a>\r\n\r\n## OperationResult\r\n**Properties**\r\n\r\n| Name | Type | Description |\r\n| --- | --- | --- |\r\n| operationId | <code>integer</code> | ID of the operation |\r\n\r\n<a name=\"LoadResult\"></a>\r\n\r\n## LoadResult\r\n**Properties**\r\n\r\n| Name | Type | Description |\r\n| --- | --- | --- |\r\n| operationId | <code>integer</code> | ID of the load operation |\r\n| loadId | <code>integer</code> | ID of the resulting load request |\r\n\r\n<a name=\"QueryOptions\"></a>\r\n\r\n## QueryOptions\r\nSome tasks offer a parameter `queryOptions` that allow for backend-side\r\npaging, sorting and filtering. The task expects it to be an object like this:\r\n\r\n**Example**  \r\n```javascript\r\n{\r\n  lim: 100,             // LIMIT in SQL: returns up to 100 rows\r\n  off: 200,             // OFFSET in SQL: skips first 200 rows\r\n  flt: {                // builds WHERE in SQL; multiple columns are connected\r\n    COLUMN1: 'value1',  // by AND\r\n    COLUMN2: 123,\r\n    COLUMN3: [          // array elements for same column are connected by OR\r\n      {\r\n        op: 'BT',       // BT resolves to 'BETWEEN ? AND ?'\r\n        val: [10, 20]\r\n      },\r\n      {\r\n        op: 'EQ',       // EQ resolves to 'IN (?,?,?)'\r\n        val: [95, 99, 101]\r\n      },\r\n      {\r\n        op: 'LT',      // LT ('less than') resolves to '< ?'\r\n        val: 50        // there's also LE ('less or equal')\r\n      },\r\n      {\r\n        op: 'GT',      // GT ('greater than') resolves to '> ?'\r\n        val: 'abc'     // there's also GE ('greater or equal')\r\n      }\r\n    ]\r\n  },\r\n  fltMode: 'PARTIAL',   // instead of 'WHERE = ?' this resolves to 'WHERE LIKE ?'\r\n                        // and wildcards around value (e.g. '%value1%')\r\n                        // default is 'EXACT'\r\n  ord: [                // builds ORDER BY in SQL\r\n    {\r\n      col: 'COLUMN1'    // defaults to 'ASC'\r\n    },\r\n    {\r\n      col: 'COLUMN3',\r\n      dir: 'DESC'\r\n    }\r\n  ]\r\n}\r\n```\r\n<a name=\"RequestsForOperation\"></a>\r\n\r\n## RequestsForOperation\r\n**Properties**\r\n\r\n| Name | Type | Description |\r\n| --- | --- | --- |\r\n| result | <code>Array.&lt;object&gt;</code> |  |\r\n| result.requestId | <code>integer</code> | request ID |\r\n| result.userName | <code>string</code> | user last affecting the request  (by operation) |\r\n| result.timestamp | <code>string</code> | ISO 8601 UTC timestamp when the  operation was last changed |\r\n\r\n"}]