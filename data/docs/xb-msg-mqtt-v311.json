[{"name":"CHANGELOG.md","content":"# Change Log\r\n\r\nAll notable changes to this project will be documented in this file.\r\n\r\nThis project adheres to [Semantic Versioning](http://semver.org/).\r\n\r\nThe format is based on [Keep a Changelog](http://keepachangelog.com/).\r\n\r\n## [0.9.17] - 2021-12-16\r\n\r\n- fixed: oauth request, method fallback and payload length\r\n\r\n## [0.9.16] - 2021-11-15\r\n\r\n- fixed: oauth with mTLS\r\n- fixed: cleanup assert handler in examples\r\n- fixed: stream ready after client connected\r\n\r\n## [0.9.15] - 2021-10-28\r\n\r\n- added: oauth2, try legacy mode as fallback\r\n- updated dev dependencies\r\n\r\n## [0.9.13] - 2020-06-25\r\n\r\n- added: license file for new delivery channel\r\n- fixed: newer Node.js version for unit tests and coverage\r\n\r\n## [0.9.12] - 2020-06-02\r\n\r\n- fixed: always copy payload if websocket writer masks data (client to server)\r\n\r\n## [0.9.9] - 2019-11-15\r\n\r\n## [0.9.7] - 2019-02-11\r\n\r\n## [0.9.6] - 2019-02-11\r\n\r\n## [0.9.5] - 2019-02-11\r\n\r\n## [0.9.4] - 2019-02-11\r\n\r\n## [0.9.2] - 2018-05-30\r\n\r\n### Added\r\n\r\n### Changed\r\n\r\n### Removed"},{"name":"doc","nodes":[{"name":"fonts","nodes":[]},{"name":"scripts","nodes":[{"name":"prettify","nodes":[]}]},{"name":"styles","nodes":[]}]},{"name":"examples","nodes":[]},{"name":"README.md","content":"# @sap/xb-msg-mqtt-v311\r\nProvides a protocol implementation for [MQTT 3.1.1](http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html).\r\n\r\n## Table of contents\r\n* [Prerequisites](#prerequisites)\r\n* [Install](#install)\r\n* [Overview](#overview)\r\n* [Getting started](#getting-started)\r\n* [API](#api)\r\n* [Limitations](#limitations)\r\n\r\n## Prerequisites\r\nMake sure to have an message broker available, e.g. [RabbitMQ](https://www.rabbitmq.com/download.html) with enabled MQTT plugin.\r\n\r\n## Install\r\n\r\nSee also:\r\n[https://www.npmjs.com/package/@sap/xb-msg-mqtt-v311](https://www.npmjs.com/package/@sap/xb-msg-mqtt-v311)\r\n\r\nTo add it to your project run:\r\n```bash\r\nnpm i @sap/xb-msg-mqtt-v311\r\n```\r\n\r\nTo generate complete API documentation run inside the library package folder\r\n```bash\r\nnpm run doc\r\n```\r\n\r\n## Overview\r\n\r\nThis library provides a messaging client for [MQTT 3.1.1](http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html).\r\nA single client instance represents one connection to the broker.\r\n\r\nEither TLS or NET socket is used, depending on defined client options.\r\nBesides plain TCP/IP also WebSocket is supported, with and without [OAuth 2.0](https://oauth.net/2/), grant flows [ClientCredentialsFlow](https://tools.ietf.org/html/rfc6749#section-4.4) and [ResourceOwnerPasswordCredentialsFlow](https://tools.ietf.org/html/rfc6749#section-4.3).\r\n\r\nThe API works completely asynchronous based on callbacks, often providing also done (resolve) and failed (reject) callbacks.\r\nThis means it would be simple to use Promise objects in the application even if the client library so far does not use it.\r\n\r\n## Getting started\r\n\r\nThere are test programs in the package folder `./examples`:\r\n* How to use plain API directly [publisher.js](examples/publisher.js) and [subscriber.js](examples/subscriber.js)\r\n* How to use unified streams [producer.js](examples/producer.js) and [consumer.js](examples/consumer.js)\r\n\r\nIt shall run with defaults immediately if for example a RabbitMQ with active MQTT plugin is listening at `localhost:1883` with default settings.\r\n\r\nAll examples support individual settings, e.g. to use a remote host or to try different stream settings.\r\nIt can be provided with a js-file given as command line parameter.\r\nThe file shall export a client option object. Defaults will still be used for undefined fields.\r\n\r\nRun it like this if the file is stored in folder `config`, same level as `examples`.\r\n\r\n```bash\r\nnode ./examples/producer.js ../config/my-options.js\r\n```\r\n\r\nFeel free to start testing with the following file content:\r\n\r\n```bash\r\n'use strict';\r\n\r\nmodule.exports = {\r\n    net: {\r\n        host      : '127.0.0.1',\r\n        port      : 1883\r\n    },\r\n    credentials: {\r\n        user      : 'guest',\r\n        password  : 'guest'\r\n    },\r\n    data: {\r\n        payload   : Buffer.allocUnsafe(50).fill('X'),\r\n        qos       : 1,\r\n        topic     : 'sap/test/hello',\r\n        maxCount  : 50000,\r\n        logCount  : 1000\r\n    }\r\n};\r\n```\r\n\r\nThe `data` section is ignored by the client, it is just used by the example programs.\r\n\r\n## API\r\n\r\nThe library provides a client class, which is able to manage one connection.\r\n```bash\r\nconst MQTT = require('@sap/xb-msg-mqtt-v311');\r\n\r\n...\r\nconst client = new MQTT.Client(options);\r\n...\r\n```\r\n\r\n### Client Options\r\n\r\nCreate a client instance using plain TCP:\r\n```bash\r\nconst options = {\r\n    net: {\r\n        host: 'localhost',\r\n        port: 1883\r\n    },\r\n    credentials: {\r\n        user: '',\r\n        password: ''\r\n    },\r\n    mqtt: {\r\n        clientID : '',\r\n        cleanSession : true,\r\n        keepAlive : 30\r\n    }\r\n};\r\n\r\nconst client = new MQTT.Client(options);\r\n```\r\n\r\nor plain TCP with TLS connection:\r\n\r\n```bash\r\nconst options = {\r\n    tls: {\r\n        host: 'localhost',\r\n        port: 8883,\r\n        ca: [\r\n            fs.readFileSync('../../../truststore/cacert.pem'),\r\n            fs.readFileSync('../../../truststore/cert.pem')\r\n        ]\r\n    },\r\n    credentials: {\r\n        user: '',\r\n        password: ''\r\n    }\r\n};\r\n\r\nconst client = new MQTT.Client(options);\r\n```\r\nas well as MQTT over WebSocket (HTTP):\r\n \r\n```bash\r\nconst options = {\r\n    ws: {\r\n        host: 'localhost',\r\n        port: 80,\r\n        path: '/'\r\n        auth: 'webUser:webPass'\r\n    }\r\n    credentials: {\r\n        user: 'mqttUser',            // used in CONNECT packet \r\n        password: 'mqttPass'         // used in CONNECT packet\r\n    }\r\n};\r\n\r\nconst client = new MQTT.Client(options);\r\n```\r\n\r\nor MQTT over WebSocket using TLS (HTTPS):\r\n\r\n```bash\r\nconst options = {\r\n    wss: {\r\n        host: 'localhost',\r\n        port: 443,\r\n        path: '/',\r\n        ca: [\r\n            fs.readFileSync('../../../truststore/cacert.pem'),\r\n            fs.readFileSync('../../../truststore/cert.pem')\r\n        ]\r\n    },\r\n    credentials: {\r\n        user: '',\r\n        password: ''\r\n    }\r\n};\r\n\r\nconst client = new MQTT.Client(options);\r\n```\r\n\r\nEither 'tls' [attributes](https://nodejs.org/api/tls.html#tls_tls_connect_options_callback), 'net' [attributes](https://nodejs.org/api/net.html#net_socket_connect_options_connectlistener), wss [attributes](https://nodejs.org/api/https.html#https_https_request_options_callback) or ws [attributes](https://nodejs.org/api/http.html#http_http_request_options_callback) must be provided. If more than one is provided the preference is as follows: preferred 'tls' then 'net' then 'wss' then finally 'ws'.\r\n\r\nIn case of WebSocket options the client will overwrite HTTP method (GET) and all web-socket relevant header fields. Everything else is given to http.request() or https.request().\r\n\r\nIt is also possible to provide connection data as [URI](https://github.com/mqtt/mqtt.github.io/wiki/URI-Scheme):\r\n```bash\r\nconst options = {\r\n    uri: 'mqtt://user:pass@localhost:1883/?keepalive=300&clientid=abcd'\r\n};\r\nconst client = new MQTT.Client(options);\r\n```\r\nOr using 'tls' again:\r\n```bash\r\nconst options = {\r\n    uri: 'mqtts://user:pass@localhost:8883?cacertfile=cacert.pem&cacertfile=cert.pem'\r\n};\r\nconst client = new MQTT.Client(options);\r\n```\r\n\r\nFinally, also an array of URIs can be provided:\r\n```bash\r\nconst options = {\r\n    uri: [\r\n        'mqtt://user11:pass11@host11:1883/?heartbeat=300',\r\n        'mqtt://user22:pass22@host22:1884/'\r\n    ]\r\n};\r\nconst client = new MQTT.Client(options);\r\n```\r\nThe client will start using the first URI and will try further URIs automatically in the given sequence until the connection can be established. If the client fails with all URIs then it stops and waits for another explicit call to connect. At this point an event `'disconnected'` is raised.\r\n\r\nAn application that requires a permanent opened connection shall always handle the `'disconnect'` event by calling `client.connect()` again, of course after a given delay time. Timers or other mechanisms may be used, depending on the application design. Keep in mind that NodeJS runtime does not guarantee precise timer execution, it depends on the event queue load.\r\n\r\nFinally, URIs can also be combined with all other settings. URI data (as far as provided) will just overwrite the corresponding fields. A typical example could be the following:\r\n```bash\r\nconst options = {\r\n    uri: [\r\n        'mqtt://user11:pass11@host11:1883/?keepalive=300',\r\n        'mqtt://user22:pass22@host22:1884/?clientid=myCID'\r\n    ]\r\n    mqtt: {\r\n        clientID: '',\r\n        keepAlive: 60\r\n    },\r\n    istreams: {\r\n        in1: {topic: 'a/b/c/d', qos: 1},\r\n        in2: {topic: 'x/y/z/#', qos: 1}\r\n    }\r\n    ostreams: {\r\n        out1: {topic: 'test/out1', qos: 0},\r\n        out2: {topic: 'test/out2', qos: 2}\r\n    }\r\n};\r\nconst client = new MQTT.Client(options);\r\n```\r\n\r\nWebSocket connections may require the use of [OAuth 2.0](https://oauth.net/2/) as well. Relevant grant flows are: [ClientCredentialsFlow](https://tools.ietf.org/html/rfc6749#section-4.4) and [ResourceOwnerPasswordCredentialsFlow](https://tools.ietf.org/html/rfc6749#section-4.3). One example is an external application, connecting to the cloud.\r\n\r\n```bash\r\nconst options = {\r\n    oa2: {\r\n        endpoint: 'https://myzone.authentication.sap.hana.ondemand.com/oauth/token',\r\n        client: 'myclientid',\r\n        secret: 'myclientsecret',\r\n    },\r\n    wss: {\r\n        host: 'myapp.cfapps.sap.hana.ondemand.com',\r\n        port: 443,\r\n        path: '/'\r\n    }\r\n};\r\n\r\nconst client = new MQTT.Client(options);\r\n```\r\n\r\nAfter an connection has been established the application may start to publish and/or subscribe. Details can be found in the sample applications, in project folder `./examples`.\r\n\r\n### Message Payload\r\n\r\nThe application may provide message payload as follows:\r\n\r\n* a simple Buffer object,\r\n* an Array of simple Buffer objects or\r\n* a Payload (see API) object, mainly for compatibility with other @sap/xb-msg* libraries.\r\n\r\nAfter the payload was handed over to the client the buffer content must not be modified by the application.\r\nAnd as soon as the buffer size exceeds `options.tune.ostreamPayloadCopyLimit` (default 1024 bytes, minimum 128 bytes) the client will not copy these data, but will directly push it to the network socket.\r\n\r\n## Limitations\r\n\r\nCurrently, you may only set the MQTT flag `cleanSession` to true.\r\n\r\n"}]