[{"name":"CHANGELOG.md","content":"# Change Log\r\n\r\nAll notable changes to this project will be documented in this file.\r\n\r\nThis project adheres to [Semantic Versioning](http://semver.org/).\r\n\r\nThe format is based on [Keep a Changelog](http://keepachangelog.com/).\r\n\r\n## [0.9.58] - 2021-12-14\r\n\r\n- fixed: oauth payload length issue on method fallback\r\n\r\n## [0.9.57] - 2021-12-08\r\n\r\n- added: oauth request timeout\r\n\r\n## [0.9.56] - 2021-11-15\r\n\r\n- fixed: late connection container close\r\n\r\n## [0.9.55] - 2021-11-15\r\n\r\n- fixed: oauth via params\r\n\r\n## [0.9.54] - 2021-11-04\r\n\r\n- fixed: handle null values as message payload\r\n\r\n## [0.9.53] - 2021-09-14\r\n\r\n- added: example for mTLS\r\n- added: 2-mode strategy for OAuth2.0 token request (auth via header, auth via params)\r\n\r\n## [0.9.52] - 2021-06-25\r\n\r\n- fixed: return response payload as part of error text on failed websocket upgrade\r\n\r\n## [0.9.51] - 2021-04-30\r\n\r\n- fixed: count split transfer frames correctly (when maxFrameSize is smaller than payload)\r\n\r\n## [0.9.50] - 2020-11-30\r\n\r\n- fixed: update more precisely remoteIncomingWindow and remoteOutgoingWindow\r\n\r\n## [0.9.48] - 2020-10-09\r\n\r\n- fixed: README after move to npmjs\r\n\r\n## [0.9.47] - 2020-09-22\r\n\r\n- fixed, no endpoint error emitted at client if endpoint closed event is handled\r\n\r\n## [0.9.45] - 2020-08-19\r\n\r\n- fixed: null values for unused Flow frame fields\r\n\r\n## [0.9.44] - 2020-07-31\r\n\r\n- fixed: relax max listener for connection state, each session will listen\r\n\r\n## [0.9.43] - 2020-06-25\r\n\r\n- added: license file for new delivery channel\r\n- fixed: newer Node.js version for unit tests and coverage\r\n\r\n## [0.9.42] - 2020-06-18\r\n\r\n## [0.9.41] - 2020-06-16\r\n\r\n- fixed: serial number handling (as sequence number, delivery number, transfer number)\r\n\r\n## [0.9.40] - 2020-05-29\r\n\r\n- fixed: always copy payload if websocket writer masks data (client to server)\r\n\r\n## [0.9.39] - 2020-03-23\r\n\r\n- added: improved default options for better performance\r\n\r\n## [0.9.38]- fixed: no disposition for early closed sessions (channels) - 2020-03-10\r\n\r\n## [0.9.36] - 2020-02-12\r\n\r\n- fixed: link state in combination with frequent state changes on same connection\r\n\r\n## [0.9.35] - 2020-02-11\r\n\r\n## [0.9.34] - 2019-12-23\r\n\r\n- fixed: correct minimum value for idleTimeoutMilliseconds\r\n- fixed: early destroy of dynamic endpoints (server-side)\r\n\r\n## [0.9.32] - 2019-12-10\r\n\r\n- added: echo example, receives and send via same connection\r\n- fixed: end handling of consumer example\r\n\r\n## [0.9.31] - 2019-11-18\r\n\r\n- added: more fine-grained handling of idle timeout, for client and for server side\r\n\r\n## [0.9.29] - 2019-11-15\r\n\r\n- fixed: payload encoding independent from payload (content) type\r\n\r\n## [0.9.28] - 2019-10-17\r\n\r\n## [0.9.27] - 2019-10-16\r\n\r\n- fixed: encoding of explicit bool value as application property\r\n\r\n## [0.9.26] - 2019-10-15\r\n\r\n- fixed: increment transfer.message.header.deliveryCount after serialization\r\n- fixed: decode value type CHAR correctly\r\n- fixed: application properties with long strings\r\n- fixed: updated dependencies\r\n\r\n## [0.9.20] - 2019-09-27\r\n\r\n- fixed: Value Factory, AMQP type Byte, Short, Int\r\n- added: Value Factory, AMQP type String and Symbol\r\n- fixed: payload type amqp-1.0 for AMQP values\r\n- added: sample to send AMQP values as payload\r\n\r\n## [0.9.19] - 2019-07-26\r\n\r\n- fixed: close plain TCP server\r\n\r\n## [0.9.18] - 2019-07-23\r\n\r\n- fixed: wrong transfer resumption in outgoing stream, when sending before ready event\r\n\r\n## [0.9.17] - 2019-06-06\r\n\r\n## [0.9.16] - 2019-06-06\r\n\r\n## [0.9.15] - 2019-06-06\r\n\r\n- fixed: flow.drain mode, missing flow response (to JMS client)\r\n\r\n## [0.9.14] - 2019-05-22\r\n\r\n- added: message examples in README.md\r\n- fixed: exeption handling, init connection\r\n- fixed: jsdoc annotations, js hint errors\r\n\r\n## [0.9.13] - 2019-03-18\r\n\r\n- fixed: incoming and outgoing endpoint errors\r\n- fixed: support info fields on AMQP errors\r\n- added: provide error object with endpoint closed events\r\n\r\n## [0.9.10] - 2019-02-11\r\n\r\n## [0.9.9] - 2019-02-11\r\n\r\n## [0.9.8] - 2019-02-01\r\n\r\n## [0.9.7] - 2019-02-01\r\n\r\n- fixed: link handles managed per session\r\n- fixed: endpoint state handling in case of early close\r\n- fixed: links destroyed automatically if owning session is destroyed\r\n- added: sender handles received flow.drain\r\n- added: peerInfo provides complete property map in addition\r\n\r\n## [0.9.2] - 2018-05-30\r\n\r\n- amqp v100 client-side implementation ready\r\n- amqp v100 server-side implementation ready"},{"name":"README.md","content":"# @sap/xb-msg-amqp-v100\r\nProvides a protocol implementation for [AMQP 1.0](http://www.amqp.org/specification/1.0/amqp-org-download).\r\n\r\n## Table of contents\r\n\r\n* [Prerequisites](#prerequisites)\r\n* [Install](#install)\r\n* [Overview](#overview)\r\n* [Getting started](#getting-started)\r\n* [API](#api)\r\n    * [Client Options](#client-options)\r\n    * [Server Options](#server-options)\r\n    * [Idle Timeout](#idle-timeout)\r\n    * [Endpoints](#endpoints)\r\n        * [Dynamic Endpoints](#dynamic-endpoints)\r\n        * [Common Behavior](#common-endpoint-behavior)\r\n        * [Session](#session)\r\n        * [Sender](#sender)\r\n        * [Outgoing Stream](#outgoing-stream)\r\n        * [Delivery Tags](#delivery-tags)\r\n        * [Receiver](#receiver)\r\n        * [Incoming Stream](#incoming-stream)\r\n    * [Message Delivery](#message-delivery)\r\n        * [Streams](#message-streams)\r\n        * [Piped Streams](#piped-message-streams)\r\n        * [Message Source and Target](#message-source-and-target)\r\n        * [Convert Source and Target](#convert-source-and-target)\r\n        * [Variable Message Routing](#variable-message-routing)\r\n        * [Quality of Service](#quality-of-service)\r\n        * [Mixed Quality of Service](#mixed-quality-of-service)\r\n        * [Flow Control](#flow-control)\r\n        * [Payload](#message-payload)\r\n        * [Payload and AMQP values](#message-payload-and-amqp-values)\r\n    * [Message Examples](#message-examples)\r\n* [Limitations](#limitations)\r\n* [Further Links](#further-links)\r\n\r\n## Prerequisites\r\n\r\nMake sure to have a message broker available for testing, e.g. [RabbitMQ](https://www.rabbitmq.com/download.html) with enabled AMQP 1.0 plugin.\r\n\r\n## Install\r\n\r\nSee also:\r\n[https://www.npmjs.com/package/@sap/xb-msg-amqp-v100](https://www.npmjs.com/package/@sap/xb-msg-amqp-v100)\r\n\r\nTo add it to your project run:\r\n```bash\r\nnpm i @sap/xb-msg-amqp-v100\r\n```\r\n\r\nTo generate complete API documentation run inside the library package folder\r\n```bash\r\nnpm run doc\r\n```\r\n\r\n## Overview\r\n\r\nThis library provides a messaging client as well as classes to realize a server for [AMQP 1.0](http://www.amqp.org/specification/1.0/amqp-org-download).\r\nIt has been tested successfully in combination with:\r\n* RabbitMQ, version `3.6.6`\r\n* Solace VMR, as of version `8.5.0.1008`\r\n* AMQPNetLite, version `2.1.1`\r\n* Apache Qpid Proton, version `0.23.0` (and electron go client)\r\n* Apache Qpid Proton-J, version `0.23.0`\r\n* Apache Qpid-JMS client, version `0.40.0`\r\n* Golang pack.ag/amqp, version `0.10.2`\r\n* Azure Service Bus, Queue\r\n\r\nEither TLS or NET socket is used, depending on the defined client options.\r\nBesides plain TCP/IP also WebSocket is supported, with and without [OAuth 2.0](https://oauth.net/2/), grant flows [ClientCredentialsFlow](https://tools.ietf.org/html/rfc6749#section-4.4) and [ResourceOwnerPasswordCredentialsFlow](https://tools.ietf.org/html/rfc6749#section-4.3).\r\n\r\nThe API works completely asynchronous based on callbacks, typically providing done (resolve) and failed (reject) callbacks.\r\nHence, it will be simple to use Promise objects in the application even if this library does not use it so far.\r\n\r\n## Getting started\r\n\r\nThere are test programs in the package folder `./examples` to demonstrate:\r\n* How to use a client as [producer](examples/producer.js), [consumer](examples/consumer.js) or [counter](examples/counter.js)\r\n* How to realize a server (or a mock server for tests), see example [gateway](examples/gateway.js)\r\n\r\nAll client examples shall run with provided defaults immediately if e.g. RabbitMQ is installed at localhost:5672 with user guest/guest, having the AMQP 1.0 plugin enabled.\r\nAlternatively, the producer may run in combination with the gateway example.\r\n\r\nAll examples accept individual settings, e.g. to use a remote host or to try different stream settings.\r\nIt can be provided with a js-file given as command line parameter. The file shall just export the options.\r\nRun it like this if the file is stored in folder ```config```, same level as ```examples```.\r\n\r\n```bash\r\nnode .\\examples\\producer.js ..\\config\\my-options.js\r\n```\r\n\r\nFeel free to start testing with the following file content:\r\n\r\n```bash\r\n'use strict';\r\n\r\nmodule.exports = {\r\n    net: {\r\n        host      : '127.0.0.1',\r\n        port      : 5672\r\n    },\r\n    sasl: {\r\n        mechanism : 'PLAIN',\r\n        user      : 'guest',\r\n        password  : 'guest'\r\n    },\r\n    data: {\r\n        source    : 'q001', // a queue name, source address for a receiver\r\n        target    : 'q002', // a queue name, target address for a sender\r\n        payload   : Buffer.allocUnsafe(50).fill('X'),\r\n        maxCount  : 10000,\r\n        logCount  : 1000\r\n    }\r\n};\r\n```\r\n\r\nThe `data` section is ignored by the client, it is just used by the example programs.\r\n\r\n## API\r\n\r\nFirst, the library provides a `Client` class. It represents one AMQP container and is able to manage one connection.\r\n`Session`, `Sender` and `Receiver` are provided as endpoints.\r\nReadable/Writable streams are used to consume/produce messages.\r\n\r\nFor the server implementation a basic `Server` class is provided.\r\nLike `Client` it supports connections running plain TCP (net/tls) as well as WebSocket (http/https).\r\n\r\nIncoming connections are represented as instances of the `Connection` class.\r\n`Connection` instances can also be created by an application-specific, more specialized server class.\r\nIt could for example support different connection types or WebSocket sub-protocols in parallel or could apply more strict validation rules.\r\n\r\n### Client Options\r\n\r\nClient instances are created directly, just providing options to the constructor:\r\n\r\n```bash\r\nconst AMQP = require('@sap/xb-msg-amqp-v100');\r\n\r\n...\r\nconst client = new AMQP.Client(options);\r\n...\r\n```\r\n\r\nOptions for a plain TCP connection, authenticating with user/password only:\r\n\r\n```bash\r\nconst options = {\r\n    net: {\r\n        host: 'localhost',\r\n        port: 5672,\r\n    },\r\n    sasl: {\r\n        mechanism: 'PLAIN',\r\n        user: 'guest',\r\n        password: 'guest'\r\n    }\r\n};\r\n```\r\n\r\nOptions for a plain TCP connection, using TLS and special trusts:\r\n\r\n```bash\r\nconst options = {\r\n    tls: {\r\n        host: 'localhost',\r\n        port: 5671,\r\n        ca: [\r\n            fs.readFileSync('../truststore/cacert.pem'),\r\n            fs.readFileSync('../truststore/cert.pem')\r\n        ]\r\n    },\r\n    sasl: {\r\n        mechanism: 'PLAIN',\r\n        user: 'guest',\r\n        password: 'guest'\r\n    }\r\n};\r\n```\r\n\r\nOptions to run AMQP over WebSocket (HTTP):\r\n\r\n```bash\r\nconst options = {\r\n    ws: {\r\n        host: 'localhost',\r\n        port: 80,\r\n        path: '/'\r\n        auth: 'webUser:webPass'\r\n    }\r\n    sasl: {\r\n        mechanism: 'PLAIN',\r\n        user: 'guest', \r\n        password: 'guest'\r\n    }\r\n};\r\n```\r\n\r\nOptions to run AMQP over WebSocket, using TLS (HTTPS) with well-known CA:\r\n\r\n```bash\r\nconst options = {\r\n    wss: {\r\n        host: 'myhost',\r\n        port: 443,\r\n        path: '/'\r\n    },\r\n    sasl: {\r\n        user: 'guest',\r\n        password: 'guest'\r\n    }\r\n};\r\n```\r\n\r\nEither 'tls' [attributes](https://nodejs.org/api/tls.html#tls_tls_connect_options_callback), 'net' [attributes](https://nodejs.org/api/net.html#net_socket_connect_options_connectlistener), wss [attributes](https://nodejs.org/api/https.html#https_https_request_options_callback) or ws [attributes](https://nodejs.org/api/http.html#http_http_request_options_callback) must be provided.\r\nIf more than one is defined the preference is as follows: preferred 'tls' then 'net' then 'wss' then finally 'ws'.\r\n\r\nIn case of WebSocket options the client will overwrite the HTTP method (with GET) and all web-socket relevant header fields.\r\nEverything else is given to `http.request()` or `https.request()`.\r\n\r\nHence, you could for example use a specialized https agent:\r\n\r\n```bash\r\nconst HttpsProxyAgent = require('https-proxy-agent');\r\n\r\n...\r\nconst options = {\r\n    wss: {\r\n        host : 'my.host.behind.proxy',\r\n        port : 443,\r\n        path: '/',\r\n        agent: new HttpsProxyAgent('http://proxy:8080')\r\n    },\r\n    sasl: {\r\n        user: 'guest',\r\n        password: 'guest'\r\n    }\r\n};\r\n```\r\n\r\nIt is also possible to provide connection data as URI.\r\n\r\n```bash\r\nconst options = {\r\n    uri: 'amqp://user:pass@localhost:5672/?container=myAMQPContainerID'\r\n};\r\n```\r\n\r\nTo use 'tls' again with own trust:\r\n\r\n```bash\r\nconst options = {\r\n    uri: 'amqps://user:pass@localhost:5671?cacertfile=cacert.pem&cacertfile=cert.pem'\r\n};\r\n```\r\n\r\nFinally, also an array of URIs can be provided:\r\n\r\n```bash\r\nconst options = {\r\n    uri: [\r\n        'amqp://user11:pass11@host11:7777/?container=ABC123',\r\n        'amqp://user22:pass22@host22:9999/?container=XYZ789'\r\n    ]\r\n};\r\n```\r\n\r\nThe client will start using the first URI and will try further URIs automatically in the given sequence until the connection can be established.\r\nIf the client fails with all URIs then it stops and waits for another explicit call to connect.\r\nAt this point an event `'disconnected'` is raised.\r\n\r\nAn application that requires a continuously opened connection shall always handle the `'disconnected'` event by calling `client.connect()` again, of course after a given delay time.\r\nTimers or other mechanisms may be used, depending on the application design.\r\nBut keep in mind that NodeJS runtime does not guarantee precise timer execution. The scheduling depends on the event queue load.\r\n\r\nFinally, URIs can also be combined with all other settings. URI data (as far as provided) will just overwrite the corresponding fields.\r\nA typical example:\r\n\r\n```bash\r\nconst options = {\r\n    uri: [\r\n        'amqp://user11:pass11@host11:7777',\r\n        'amqp://user22:pass22@host22:9999'\r\n    ]\r\n    amqp: {\r\n        containerID: '',               // auto-generated by client\r\n        maxMessageSize: 1000000        // bytes\r\n        autoDeliveryTagPrefix: 'tag-',\r\n        outgoingSessionWindow: 1000,\r\n        incomingSessionWindow: 1000,\r\n        maxReceiverLinkCredit: 255,\r\n        minReceiverLinkCredit: 200\r\n    }\r\n};\r\n```\r\n\r\nWebSocket connections may require the use of [OAuth 2.0](https://oauth.net/2/) as well, for example a local application connecting to SAP cloud.\r\nRelevant grant flows are: [ClientCredentialsFlow](https://tools.ietf.org/html/rfc6749#section-4.4) and [ResourceOwnerPasswordCredentialsFlow](https://tools.ietf.org/html/rfc6749#section-4.3).\r\n\r\n```bash\r\nconst options = {\r\n    wss: {\r\n        host: 'myapp.cfapps.sap.hana.ondemand.com',\r\n        port: 443,\r\n        path: '/'\r\n    },\r\n    oa2: {\r\n        endpoint: 'https://myzone.authentication.sap.hana.ondemand.com/oauth/token',\r\n        client: 'myclientid',\r\n        secret: 'myclientsecret',\r\n    },\r\n    sasl: {\r\n        mechanism: 'ANONYMOUS',\r\n        identity: 'test.user@sap.com'\r\n    }\r\n};\r\n```\r\n\r\nFurther settings for the OAuth token request, for example a special agent:\r\n\r\n```bash\r\nconst options = {\r\n    wss: {\r\n        host: 'myapp.cfapps.sap.hana.ondemand.com',\r\n        port: 443,\r\n        path: '/'\r\n        agent: new HttpsProxyAgent('http://proxy:8080')\r\n    },\r\n    oa2: {\r\n        endpoint: 'https://myzone.authentication.sap.hana.ondemand.com/oauth/token',\r\n        client: 'myclientid',\r\n        secret: 'myclientsecret',\r\n        request: {\r\n            agent: new HttpsProxyAgent('http://proxy:8080')\r\n        }\r\n    },\r\n    sasl: {\r\n        mechanism: 'ANONYMOUS',\r\n        identity: 'test.user@sap.com'\r\n    }\r\n};\r\n```\r\n\r\n### ClientOptions mTLS\r\n\r\nFurthermore, settings to use client certificates (mTLS), possible with or without websocket, this example with websocket:\r\n\r\n```bash\r\nconst options = {\r\n    uri: 'wss://xxx.eu10-canary.em.services.cloud.sap/protocols/amqp10ws'\r\n    wss: {\r\n        key: fs.readFileSync('../config/pem/my-key.pem'),      // or Buffer.from('')\r\n        cert: fs.readFileSync('../config/pem/my-cert.pem')     // or Buffer.from('')\r\n    },\r\n    oa2: {\r\n        endpoint: 'https://xxx.accountsxxx.ondemand.com/oauth2/token',\r\n        client: 'myclientid',\r\n        secret: '',\r\n        request: {\r\n            key: fs.readFileSync('../config/pem/my-key.pem'),  // or Buffer.from('')\r\n            cert: fs.readFileSync('../config/pem/my-cert.pem') // or Buffer.from('')\r\n        }\r\n    }\r\n};\r\n```\r\n\r\nActually, all options from [TLS core](https://nodejs.org/docs/latest-v12.x/api/tls.html#tls_tls_createsecurecontext_options) can be used.\r\n\r\n### Server Options\r\n\r\nSimilar to the client class new `Server` instances are created, using the constructor:\r\n\r\n```bash\r\nconst AMQP = require('@sap/xb-msg-amqp-v100');\r\n\r\n...\r\nconst server = new AMQP.Server(options);\r\n...\r\nserver.listen();\r\n```\r\n\r\nOptions for plain TCP connections, accepting two SASL mechanisms (validation triggered by event):\r\n\r\n```bash\r\nconst options = {\r\n    net: {\r\n        port: 9999,\r\n    },\r\n    sasl: {\r\n        mechanism: 'ANONYMOUS PLAIN',\r\n    }\r\n};\r\n```\r\n\r\nTo use WebSocket with or without SASL processing, both possible in parallel:\r\n\r\n```bash\r\nconst options = {\r\n    ws: {\r\n        port: 8888,\r\n    },\r\n    sasl: {\r\n        mechanism: 'ANONYMOUS PLAIN',\r\n        mandatory: false\r\n    }\r\n};\r\n```\r\n\r\nSecure plain TCP connections and more restrictive protocol settings:\r\n\r\n```bash\r\nconst options = {\r\n    tls: {\r\n        port: 5671,\r\n    },\r\n    sasl: {\r\n        mechanism: 'PLAIN EXTERNAL',\r\n    },\r\n    amqp: {\r\n        outgoingSessionWindow: 100,\r\n        incomingSessionWindow: 100,\r\n        maxReceiverLinkCredit: 10,\r\n        minReceiverLinkCredit: 5\r\n        maxMessageSize: 10000 // bytes\r\n    }\r\n}\r\n```\r\n\r\nThe server will create one `Connection` instance for each incoming client connection.\r\nWhen running an own (more specialized) server similar instances can be created.\r\n\r\nThe AMQP protocol is completely handled by the `Connection` class.\r\nIt requires the same options as the `Server` class, but uses only the sections `sasl`, `amqp` and `tune`.\r\n\r\n```bash\r\nconst AMQP = require('@sap/xb-msg-amqp-v100');\r\n\r\nconst options = {\r\n    sasl: {\r\n        mechanism: 'PLAIN'\r\n    },\r\n    amqp: {\r\n        outgoingSessionWindow: 100,\r\n        incomingSessionWindow: 100,\r\n        maxReceiverLinkCredit: 10,\r\n        minReceiverLinkCredit: 5,\r\n        maxMessageSize: 10000 // bytes\r\n    }\r\n    tune: {\r\n        ostreamPayloadCopyLimit: 1024 // bytes\r\n    }\r\n}\r\n\r\nfunction init(socket) {\r\n    try {\r\n        const connection = new Connection(socket, 'net', options);\r\n        ...\r\n        connection\r\n            .once('authenticate', (mechanism, data, callback) => {...}\r\n            .once('ready', (peerInfo) => {...}\r\n            .once('abort', (hadError) => {...}\r\n            .once('close', (hadError) => {...}\r\n            .on('error', (error) => {...}\r\n            .on('sender', (endpoint) => {...}\r\n            .on('receiver', (endpoint) => {...}\r\n        ;\r\n        ...\r\n    } catch(e) {\r\n        socket.destroy(e);  // if e.g. options were not accepted\r\n    }\r\n} \r\n```\r\n\r\nThe [gateway](examples/gateway.js) example uses all of the defined events, you may compare it as check list.\r\nMore details can also be found in JSDoc.\r\n\r\n`Connection` instances behave always the same, independent from the used server class.\r\nEach instance offers the expected endpoints: `Session`, `Sender`, `Receiver`.\r\n\r\n### Idle Timeout\r\n\r\nWhile opening a new connection both peers can declare an [idle timeout](https://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-transport-v1.0-os.html#doc-doc-idle-time-out).\r\nIt means to expect receiving any frame within this time or to close the connection otherwise.\r\nThe behavior is similar for client and server. And for both sides this library supports the following options:\r\n\r\n* `idleTimeoutMilliseconds`: specifies the timeout value in milliseconds, 0 means no timeout. The value will be provided to [`net.setTimeout()`](https://nodejs.org/dist/latest-v12.x/docs/api/net.html#net_socket_settimeout_timeout_callback)\r\n* `idleTimeoutTryKeepAlive`: defines the timeout behavior, indicates whether to send an empty frame to keep the connection alive or to end the connection, sending a close frame with an appropriate error message.\r\n* `adjustSelfIdleTimeout`: optional callback to recalculate the own timeout after peer information are available, the default implementation calculates the minimum of the own timeout and the half of peers timeout, but only if running in keep alive mode.\r\n\r\nClient defaults:\r\n```bash\r\nconst options = {\r\n    amqp: {\r\n        idleTimeoutMilliseconds: 90000,\r\n        idleTimeoutTryKeepAlive: true,\r\n        adjustSelfIdleTimeout: adjustSelfIdleTimeout // callback\r\n    }\r\n}\r\n\r\n```  \r\nServer defaults:\r\n```bash\r\nconst options = {\r\n    amqp: {\r\n        idleTimeoutMilliseconds: 180000,\r\n        idleTimeoutTryKeepAlive: false,\r\n        adjustSelfIdleTimeout: adjustSelfIdleTimeout // callback\r\n    }\r\n}\r\n\r\n```  \r\n\r\n### Endpoints\r\n\r\nOnce a connection has been established its usage is quite symmetric for both peers.\r\nAt least foreseen by the specification client and server both can begin and end sessions as well as attach and detach incoming or outgoing links.\r\n\r\nFor example, a server may wait for clients to connect and may afterwards immediately begin a session, attach an outgoing link and may finally start sending messages (that the client has never asked for).\r\n\r\nHowever, in typical scenarios the client takes the active role and the server will wait for client requests.\r\nIn particular, if the server is actually a message broker this is the expected behavior.\r\n\r\n#### Dynamic Endpoints\r\n\r\nThe boolean endpoint property _dynamic_ indicates whether or not an endpoint was created on peers request.\r\n`Session`, `Sender` and `Receiver` provide a common getter for it.\r\nThe property is not covered by the specification, it is just used by this API as part of the endpoint lifecycle control.\r\n\r\n`Client` and `Connection` both support _dynamic_ endpoints as follows:\r\n\r\n* raise an event each time a dynamic endpoint was created and opened the very first time,\r\n* destroy it immediately if the event is not handled to avoid uncontrolled resource consumption,\r\n* destroy it automatically latest on connection close,\r\n* allow the application to destroy it at any earlier point in time.\r\n\r\nIn addition the `Client` allows to create _non-dynamic_ endpoints, which stay registered by `name` or `id` until the application destroys it explicitly.\r\nThose endpoints can be used at any point in time, with or without an opened connection.\r\n\r\n#### Common Endpoint Behavior\r\n\r\nOverview on common methods for `Session`, `Sender` and `Receiver` (check JSDoc for details):\r\n\r\n* `dynamic()`: returns `true` if the endpoint was created on peers request,\r\n* `active()`: returns `true` if the endpoint gets opened automatically once `Client` is connected,\r\n* `opened()`: returns `true` if local and remote endpoint are interactive, \r\n* `closed()`: returns `true` if local and remote endpoint are neither opened nor on the way to open,\r\n* `destroyed()`: returns true if the endpoint was destroyed; it is not registered anymore,\r\n* `destroy()`: will immediately destroy the endpoint and cancel all of its messages in transit.\r\n\r\nOverview on common events for `Session`, `Sender` and `Receiver` (check JSDoc for details):\r\n\r\n* `opened`: raised if local and remote endpoint are both opened,\r\n* `closed(ox, ix)`: raised if local and remote endpoint are both closed, with outgoing and incoming error, both optional\r\n* `destroy`: raised before local endpoint is destroyed, application shall release any reference.\r\n\r\nThe `closed` event may report protocol errors. If the event is not handled by the application, but parameter `ix` is valuated then this (peer) error will be reported by the client.\r\n\r\nFurther methods and events depend on the specific endpoint type and applicable performatives.\r\n\r\n#### Session\r\n\r\nEach [session](http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-transport-v1.0-os.html#section-sessions) groups multiple [links](http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-transport-v1.0-os.html#section-links) and provides a higher-level flow control.\r\nFor a single connection multiple sessions can be used, but one session is usually sufficient.\r\n\r\nA stable session identifier (comparable to a link name) is not defined by the specification.\r\nThat's why, the library introduces an identifier (a simple string) just for local usage and applications convenience.\r\nIt is never visible to the peer.\r\n\r\nThere is one default session in use, identified with an empty string:\r\n\r\n```bash\r\nconst defSession = client.session('');\r\n...\r\nconst anySession = client.session('anyLocalID');\r\n```\r\n\r\nOverview on `Session` specific methods (check JSDoc for details):\r\n\r\n* all [common endpoint methods](#common-endpoint-behavior) and\r\n* `begin(outgoing, incoming, options)`: _begin_ session, all parameters optional and defaulted by client options,\r\n* `flow(outgoing, incoming)`: change current incoming and outgoing window size,\r\n* `end()`: _end_ the session, no messages will be sent or received, attached outgoing streams will wait based on flow control.\r\n\r\nOverview on `Session` specific events (check JSDoc for details):\r\n\r\n* all [common endpoint events](#common-endpoint-behavior) and\r\n* `flow`: flow settings were updated by the corresponding remote endpoint.  \r\n\r\nA session will automatically _begin_ if at least one active link endpoint is assigned to it.\r\nHowever, this can also be triggered explicitly.\r\n\r\n```bash\r\nclient.session('').begin(200, 200);\r\n```\r\n\r\nThe inherited method `destroy()` will first destroy all currently attached links before destroying itself.\r\n\r\n#### Sender\r\n\r\nEach `Sender` offers an `OutgoingStream` which extends the NodeJS stream class `Writable`.\r\nThe stream runs in object mode and expects plain message objects (see also [Message Streams](#message-streams)).\r\n\r\nOverview on `Sender` methods (check JSDoc for details):\r\n\r\n* all [common endpoint methods](#common-endpoint-behavior) and\r\n* `session()`: returns the currently assigned session endpoint,\r\n* `name()`: returns the link name,\r\n* `options()`: returns current settings as plain object,\r\n* `stream()`: returns the currently associated stream,\r\n* `attach()`: update settings, create the stream, _attach_ the link and return the stream,\r\n* `detach()`: destroy the stream and _detach_ the link,\r\n\r\nA `Sender` provides only the [common endpoint events](#common-endpoint-behavior) (check JSDoc for details):\r\n\r\nMethod `attach()` may also be called if the client is not connected.\r\nThis will switch the endpoint in active mode and it will automatically _attach_ whenever a connection is opened successfully.\r\n\r\nImmediately after calling `attach()` the application may also start using the stream.\r\nIn any case flow control must be handled correctly, based on the standard NodeJS stream API.\r\n\r\nAs long as the endpoint is `active()` it will try to send all queued messages.\r\nEven if the connection is interrupted the endpoint will resume its work as soon as the connection is opened again.\r\n\r\nThe inherited method `destroy()` will first _detach_ the endpoint before destroying its stream and finally itself.\r\nDestroying the stream means all queued messages including those that are already in transit will be cancelled.\r\nThe message `failed` callback is used to notify the application.\r\n\r\nThe application may also call `stream.end()` to indicate end of usage.\r\nNew messages are not accepted anymore, but all queued messages will be processed before the link is detached.\r\n\r\nA `Sender` manages one instance of an `OutgoingStream`.\r\n\r\n#### Outgoing Stream\r\n\r\nOverview on `OutgoingStream` methods (check JSDoc for details):\r\n\r\n* all methods of `Writable` and\r\n* `sender(): Sender`: returns the associated sender endpoint,\r\n* `newDeliveryTag():string`: returns a new delivery tag that can be registered by application before usage,\r\n* `flow(available)`: send the amount of locally available messages,\r\n* `delivered():UInt`: returns the amount of delivered messages,\r\n* `available():UInt`: returns the amount of available messages,\r\n* `credit():UInt`: returns the remaining message transfer credit,\r\n\r\nOverview on `OutgoingStream` events (check JSDoc for details):\r\n* all events of `Writable` and\r\n* `ready`: indicates the stream is attached and messages will now really be sent, not only queued.\r\n\r\n```javascript\r\nstream\r\n    .on('ready', () => {\r\n        send();\r\n    })\r\n    .on('drain', () => {\r\n        send();\r\n    })\r\n    .on('finish', () => {\r\n        client.disconnect();\r\n    })\r\n;\r\n```\r\n\r\nSee also the [producer](examples/producer.js) example.\r\n\r\n#### Delivery Tags\r\n\r\nIf the application writes a message without a `message.target.deliveryTag` to an outgoing stream then this tag will be generated automatically.\r\nThe result will be the same as if the application would have called `stream.newDeliveryTag()` first and would have assigned the new tag to a message, but the application was not able to register the tag for any kind of message correlation later on.\r\n\r\nGenerated delivery tags will start with `options.amqp.autoDeliveryTagPrefix`, by default `'tag-'`.\r\nHence, the application may also use own delivery tags in parallel with generated tags, easily avoiding duplicate tags being used.\r\n\r\n#### Receiver\r\n\r\nEach `Receiver` offers an `IncomingStream` which extends the NodeJS stream class `Readable`.\r\nThe stream runs in object mode and manages plain message objects (see also [Message Streams](#message-streams)).\r\n\r\nOverview on `Receiver` methods (check JSDoc for details):\r\n\r\n* all [common endpoint methods](#common-endpoint-behavior) and\r\n* `session()`: returns the currently assigned session endpoint,\r\n* `name()`: returns the link name,\r\n* `options()`: returns current settings as plain object,\r\n* `stream()`: returns the currently associated stream,\r\n* `attach()`: update settings, create the stream, _attach_ the link and return the stream,\r\n* `detach()`: destroy the stream and _detach_ the link,\r\n\r\nA `Receiver` provides only the [common endpoint events](#common-endpoint-behavior) (check JSDoc for details):\r\n\r\nMethod `attach()` may also be called if the client is not connected and it will return the stream already.\r\nThe endpoint is switched into active mode and will automatically _attach_ whenever a connection is opened successfully.\r\n\r\nThe inherited method `destroy()` will first _detach_ before destroying its stream and finally itself.\r\nDestroying the stream means:\r\n\r\n* all queued messages will be deleted immediately; it will not reach the application anymore, \r\n* for messages in transit (already provided to the application, but not yet done) a following `done()` callback is ignored,\r\n\r\nA `Receiver` manages one instance of an `IncomingStream`.\r\n\r\n#### Incoming Stream\r\n\r\nThe IncomingSteam handles also flow control for the application.\r\nIt can renew the transfer credit after it was consumed and it can reduce the credit if application has to consume slower as the sender can send.\r\n\r\nOverview on `IncomingStream` methods (check JSDoc for details):\r\n\r\n* all methods of `Readable` and\r\n* `receiver(): Receiver`: returns the associated receiver endpoint,\r\n* `flow(maxCredit, minCredit)`: updates message transfer credit settings,\r\n* `delivered():UInt`: returns the amount of messages received by this stream,\r\n* `available():UInt`: returns the amount of available messages from the remote endpoint,\r\n* `credit():UInt`: returns the remaining message transfer credit,\r\n\r\nOverview on `IncomingStream` events (check JSDoc for details):\r\n* all events of `Readable` and\r\n* `subscribed`: indicates the stream is attached and messages could be received now.\r\n\r\n```bash\r\nstream\r\n    .on('subscribed', () => {\r\n        console.log('attached');\r\n    })\r\n    .on('data', (message) => {\r\n        ...\r\n        message.done();\r\n        ...\r\n    })\r\n;\r\n```\r\n\r\nAs soon as the current credit reaches `minCredit`, the incoming stream will renew the credit with maxCredit automatically.\r\nHowever, if the application decides to set `minCredit = -1` then the application will have to renew the credit explicitly using method `stream.flow(maxCredit, minCredit)`.\r\n\r\nThe application must always call `message.done()`, independent from chosen settle mode.\r\n\r\nSee also the [consumer](examples/consumer.js) example.\r\n\r\n### Message Delivery\r\n\r\nMessages are transferred as soon as a link between a `Sender` and a `Receiver` is attached.\r\n\r\n#### Message Streams\r\n\r\nAs mentioned earlier `Writable` and `Readable` streams are provided to handle outgoing and incoming messages.\r\nThese streams always run in object mode using `options.amqp.linkHighWaterMsgCount`.\r\n\r\nHere, a single message is represented as a plain object with the following attributes:\r\n* `source`: defined by the incoming stream, providing transfer attributes as well as the message header, annotations and properties,\r\n* `target`: defined optionally by the application, similar to the source, accepted by the outgoing stream,\r\n* `payload`: message data to transfer, see also this [chapter](#message-payload),\r\n* `done`: a callback function to confirm final message processing,  \r\n* `failed`: a callback function to indicate processing failure.\r\n\r\nA receiving application is expected to call either `done` or `failed` for each single message, exactly one time (maybe asynchronously) and independent from the used link settings.\r\n\r\nIf a transfer was received unsettled then `done` will send a disposition with outcome [DeliveryAccepted](http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-messaging-v1.0-os.html#type-accepted).\r\n\r\nIn the case of a processing error, `failed` will either send outcome [DeliveryRejected](http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-messaging-v1.0-os.html#type-rejected) (if an error object is provided) or [DeliveryReleased](http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-messaging-v1.0-os.html#type-released) otherwise.\r\n\r\n```bash\r\nstream.on('data', (message) => {\r\n    try {\r\n        JSON.parse(message.payload.toString('utf8'));\r\n        ...\r\n        message.done();\r\n    } catch (e) {\r\n        message.failed(e);\r\n    }\r\n};\r\n```\r\n\r\nA sending application can define the callbacks to get notified about the transfer result.\r\n\r\n```bash\r\nconst message = {\r\n    payload : Buffer.from('test'),\r\n    done : () => this._onSendDone(message),\r\n    failed : (error) => this._onSendFailed(error, message)\r\n};\r\nconst noPause = stream.write(message);\r\n```\r\n\r\n#### Piped Message Streams\r\n\r\nAn application may also pass trough (or transform) a received message from an incoming stream to an outgoing stream.\r\nIn this case both streams would directly handle `done` and `failed` correctly.\r\n\r\n```bash\r\nclass Processor extends Transform {\r\n    constructor() {\r\n        super({\r\n            writableObjectMode: true,\r\n            writableHighWaterMark: 16,\r\n            readableObjectMode: true,\r\n            readableHighWaterMark: 16\r\n        });\r\n    }\r\n    \r\n    _transform(message, encoding, callback) {\r\n        try {\r\n            JSON.parse(message.payload.toString('utf8'));\r\n            ...\r\n            this.push(message);\r\n            callback();\r\n        } catch (e) {\r\n            callback(e);\r\n        }\r\n    }\r\n}\r\n...\r\nconst istream = client.receiver('inp').attach('queue:q001');\r\nconst ostream = client.sender('out').attach('topic:a/b/c');\r\n...\r\nistream.pipe(new Processor()).pipe(ostream);\r\n...\r\nclient.connect();\r\n```\r\n\r\n#### Message Source and Target\r\n\r\nBoth, `message.source`and `message.target` provide the same fields (check JSDoc for details):\r\n\r\n* `deliveryTag`: an application tag to identify (and correlate) the message,\r\n* `batchable`: true if a disposition can be delayed in order to optimize processing,\r\n* `settled`: true if the sender has already settled,\r\n* `rcvSettleMode`: senders requested receiver settle mode,\r\n* `header`: plain object with header data ([see specification](http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-messaging-v1.0-os.html#type-header)),\r\n* `annotations`: map with message annotations ([see specification](http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-messaging-v1.0-os.html#type-message-annotations)),\r\n* `properties`: plain object with message properties ([see specification](http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-messaging-v1.0-os.html#type-properties)).\r\n\r\nAll target data are optional, defaults originate from the link definition that the message is sent over.\r\n\r\n#### Convert Source and Target\r\n\r\nTwo fields of the `Client` and the `Connection` options allow the registration of conversion exits:\r\n* `options.amqp.mapIncomingMsgSource`\r\n* `options.amqp.mapOutgoingMsgTarget`\r\n\r\nThe application or any other library could replace the default functions (check JSDoc for parameters).\r\nFor example, @sap/xb-msg-env uses this mechanism to assure that a unified message source is provided and a unified target can be used by application.\r\n\r\n#### Variable Message Routing\r\n\r\nUsing `message.target` the application can select dynamically the address that the message is sent to:\r\n\r\n```bash\r\nlet id = '42'; \r\n...\r\nmessage.target = {\r\n    properties : {\r\n        to: 'topic/order/' + id\r\n    }\r\n};\r\n...\r\n```\r\n\r\nThis allows to:\r\n* add message-related data as topic segment, e.g. an object identifier,\r\n* forward messages with variable target address over one single link.\r\n\r\nPlease note, the specification defines only an [address string](http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-messaging-v1.0-os.html#type-address-string).\r\nThe address syntax depends on the connected service. For example, RabbitMQ, SolaceVMR or SAP Enterprise Messaging support different address expressions.\r\nAnd even more unexpected, RabbitMQ uses `properties.subject` instead of `properties.to`.\r\nHowever, package @sap/xb-msg-env would enable a unified processing here, if really needed.\r\n\r\n#### Quality of Service\r\n\r\nChapter [2.6.12.](http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-transport-v1.0-os.html#doc-idp438000) of the protocol specification describes how to handle message transfers.\r\nWith different combinations of sender and receiver settle mode the usual qualities can be realized.\r\n\r\n| quality | [sndSettleMode](http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-transport-v1.0-os.html#type-sender-settle-mode) | [rcvSettleMode](http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-transport-v1.0-os.html#type-receiver-settle-mode) |\r\n| :---: | :---: | :---: |\r\n| at-most-once  | 1 (settled) | 0 (first) |\r\n| at-least-once | 0 (unsettled) | 0 (first) |\r\n| exactly-once  | 0 (unsettled) | 1 (second) |\r\n\r\nSender and receiver will agree on its settle modes when the link is attached:\r\n```bash\r\nsender.attach({\r\n    sndSettleMode: 0,\r\n    rcvSettleMode: 0,\r\n    target: {\r\n        address: 'topic:a/b/c'\r\n    }\r\n});\r\n```\r\n\r\n```bash\r\nreceiver.attach({\r\n    sndSettleMode: 0,\r\n    rcvSettleMode: 0,\r\n    source: {\r\n        address: 'queue:q001'\r\n    }\r\n});\r\n```\r\n\r\nIn any case the application has just to select the settle mode, usually at the client side.\r\nThe library will assure correct handling of messages in transit, delivery states and message settlement.\r\n\r\n#### Mixed Quality of Service\r\n\r\nA sender may decide dynamically (per single message) on the settle mode.\r\nFirst, it would define sndSettleMode `mixed` while attaching the link.\r\n\r\n```bash\r\nsender.attach({\r\n    sndSettleMode: 2,\r\n    rcvSettleMode: 0,\r\n    target: {\r\n        address: 'topic:a/b/c'\r\n    }\r\n});\r\n```\r\n\r\nLater it would define the quality of service using the message target.\r\n\r\n```bash\r\n...\r\nmessage.target = {\r\n    settled: false,     // not yet settled by sender\r\n    rcvSettleMode: 0    // receiver settles first\r\n};\r\n...\r\n```\r\n\r\n#### Flow Control\r\n\r\nThere are actually 3 layers of flow control:\r\n* network socket and amount of bytes that is sent or received before the connection is throttled,\r\n* session layer with an incoming and outgoing message transfer window,\r\n* link layer with message transfer credits provided by the receiver to the sender.\r\n\r\nThe library handles flow control on all layers automatically to protect the process in which it resides.\r\nThe application just has to define the limits for each layer as part of the client or server options:\r\n\r\n* section `options.tune` for the network layer and\r\n* section `options.amqp` for the session and link layer.\r\n\r\n#### Message Payload\r\n\r\nThe application may provide the message payload for an outgoing message as follows:\r\n\r\n* a `Buffer` object,\r\n* an `Array` of `Buffer` objects,\r\n* a `Payload` object or a plain object with same properties as `Payload`.\r\n\r\nProperties of a `Payload` object:\r\n* `chunks`: an Array of Buffer objects,\r\n* `type`: an optional string providing the content type,\r\n* `encoding`: an optional string providing the content encoding,\r\n* `data`: any optional data to be sent either as [AMQP sequence](http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-messaging-v1.0-os.html#type-amqp-sequence) or as [AMQP value](http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-messaging-v1.0-os.html#type-amqp-value),\r\n* `properties`: [application properties](http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-messaging-v1.0-os.html#type-application-properties).\r\n\r\nAfter the payload was given to a sender it must not be modified by the application anymore.\r\nAnd as soon as a single buffers size exceeds `options.tune.ostreamPayloadCopyLimit` (default 1024 bytes, minimum 128 bytes) it will not be copied anymore, but will be pushed to the network socket directly.\r\n\r\nIncoming messages will always provide a `Payload` object, just for application convenience.\r\n\r\n#### Message Payload and AMQP values\r\n\r\nUsually, the message payload will consist of binary data, an opaque array of bytes from the protocol libraries perspective.\r\nHowever, AMQP 1.0 allows also a single [AMQP value](http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-messaging-v1.0-os.html#type-amqp-value) or an [AMQP sequence](http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-messaging-v1.0-os.html#type-amqp-sequence) alternatively.\r\n\r\nIf a received message payload consists of such values then the decoded values are provided as `payload.data` and in addition the corresponding parsed raw bytes as `payload.chunks`.\r\nThe field `payload.type` will then have the special value `'amqp-1.0'`, which is not a real mime type and in consequence not in danger to clash with such.\r\nPlease note, `'amqp-1.0'` is only a local API convention, not standardized.\r\nHowever, it has already been introduced by [RabbitMQ AMQP 1.0 plugin](https://github.com/rabbitmq/rabbitmq-amqp1.0).\r\n\r\nFor an outgoing message payload with special type `'amqp-1.0'` the encoder will either write `payload.chunks` (if provided) directly without any validation or it will encode the given `payload.data` as AMQP value or AMQP sequence.\r\n\r\n### Message Examples\r\nJust a few copy&paste templates:\r\n\r\n* Payload as Buffer\r\n  ```javascript\r\n  const message = {\r\n    payload : Buffer.from('hello world'),\r\n    done: () => { console.log('message was sent'); },\r\n    failed: (err) => { console.log('message not sent,', err); }\r\n  };\r\n  ```\r\n\r\n* Payload as Buffer Array\r\n  ```javascript\r\n  const message = {\r\n    payload : [\r\n        Buffer.from('hello '),\r\n        Buffer.from('world'),\r\n    ],\r\n    done: () => { console.log('message was sent'); },\r\n    failed: (err) => { console.log('message not sent,', err); }\r\n  };\r\n  ```\r\n\r\n* Payload from JSON, application, properties, message properties and message header to be sent\r\n  ```javascript\r\n  const message = {\r\n    payload: {\r\n        chunks: [Buffer.from(JSON.stringify({\r\n            quantity: 100,\r\n            uom: 'kg',\r\n        }))],\r\n        properties:{ // application properties, data to read without parsing full payload\r\n            SalesOrder: '42',\r\n            DeliveryID: '1764'\r\n        },\r\n        type: 'application/json'\r\n    },\r\n    target: {\r\n        header: {\r\n            durable: true,\r\n            priority: 2,\r\n            ttl: null, // or number in milliseconds\r\n        },\r\n        properties: {\r\n            messageID: '100037877',\r\n            userID: '',\r\n            to: 'topic:a/b/c',\r\n            subject: '',\r\n            replyTo: '',\r\n        }\r\n    },\r\n    done: () => { console.log('message was sent'); },\r\n    failed: (err) => { console.log('message not sent,', err); }\r\n  };\r\n  ```\r\n\r\n* Cloud Event, structured format\r\n  ```javascript\r\n  \r\n  const message = {\r\n    payload: {\r\n        chunks: [Buffer.from(JSON.stringify({\r\n            specversion: '0.3',\r\n            source: 'sap/faas/demo',\r\n            type: 'com.sap.coffee.produced',\r\n            id: 'demo',\r\n            cause: 'demo',\r\n            subject: '',\r\n            data: 'espresso',\r\n            datacontenttype: 'text/plain'\r\n        }))],\r\n        type: 'application/cloudevents+json'\r\n    },\r\n    done: () => { console.log('message was sent'); },\r\n    failed: (err) => { console.log('message not sent,', err); }\r\n  };\r\n\r\n  ```\r\n\r\n* Cloud Event, binary format \r\n  ```javascript\r\n  \r\n  const message = {\r\n    payload: {\r\n        chunks: [\r\n            Buffer.from('espresso')\r\n        ],\r\n        properties: {\r\n            'cloudEvents:specversion': '0.3',\r\n            'cloudEvents:source': 'sap/faas/demo',\r\n            'cloudEvents:type': 'com.sap.coffee.produced',\r\n            'cloudEvents:id': 'demo',\r\n            'cloudEvents:cause': 'demo',\r\n            'cloudEvents:subject': ''\r\n        },\r\n        type: 'text/plain'\r\n    },\r\n    done: () => { console.log('message was sent'); },\r\n    failed: (err) => { console.log('message not sent,', err); }\r\n  };\r\n\r\n  ```\r\n\r\n* No binary payload, but single AMQP Value, e.g. a string\r\n  ```javascript\r\n  \r\n  const AMQP = require('@sap/xb-msg-amqp-v100');\r\n  \r\n  const message = {\r\n    payload: {\r\n        type: 'amqp-1.0',\r\n        data: AMQP.Factory.String('Hello World')\r\n    },\r\n    done: () => { console.log('message was sent'); },\r\n    failed: (err) => { console.log('message not sent,', err); }\r\n  };\r\n\r\n  ```\r\n\r\n* Simulate text message from [Qpid JMS](https://qpid.apache.org/components/jms/index.html)\r\n  ```javascript\r\n  \r\n  const AMQP = require('@sap/xb-msg-amqp-v100');\r\n    \r\n  const message = {\r\n    target: {\r\n      annotations: {\r\n        'x-opt-jms-msg-type': AMQP.Factory.Byte(5)\r\n      }\r\n    },\r\n    payload: {\r\n      type: 'amqp-1.0',\r\n      data: AMQP.Factory.String('Hello World')\r\n    },\r\n    done: () => { console.log('message was sent'); },\r\n    failed: (err) => { console.log('message not sent,', err); }\r\n  };\r\n\r\n  ```\r\n\r\n## Limitations\r\n\r\nSimilar to other libraries not the full scope of AMQP 1.0 could be implemented so far:\r\n\r\n* Only the following SASL mechanisms are supported: ANONYMOUS, PLAIN, EXTERNAL,\r\n* Deliveries cannot be resumed; once reconnected those messages are sent again with a new delivery,\r\n* Delivery state [Received](http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-messaging-v1.0-os.html#type-received) is not used,\r\n* Delivery state [Modified](http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-messaging-v1.0-os.html#type-modified) is not supported,\r\n* Multiple Transfer Frames for one delivery are collected until the whole message can be provided to the application,\r\n* Message Footer is not supported, received but not exposed at the API,\r\n* Message Delivery Annotations are not supported, received, but not exposed at the API,\r\n* Decimal values are provided/accepted as binary data only, using a `Buffer` instance; use a specialized library for the conversion,\r\n* Transactions are not supported,\r\n* Incoming streams handle Quality of Service _Exactly Once_ with one single callback to the application only,\r\n* Source filters are not supported,\r\n* Several fine-grained settings for endpoint lifecycle control may be ignored.\r\n\r\n## Further Links\r\n\r\nProtocol Specification:\r\n\r\n* [AMQP 1.0, Part 1: Types](http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-types-v1.0-os.html#toc)\r\n* [AMQP 1.0, Part 2: Transport](http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-transport-v1.0-os.html#toc)\r\n* [AMQP 1.0, Part 3: Messaging](http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-messaging-v1.0-os.html#toc)\r\n* [AMQP 1.0, Part 4: Transactions](http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-transactions-v1.0-os.html#toc)\r\n* [AMQP 1.0, Part 5: Security](http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-security-v1.0-os.html#toc)\r\n\r\nSASL and supported mechanisms:\r\n\r\n* [SASL Protocol](https://tools.ietf.org/html/rfc4422)\r\n* [SASL Mechanisms](https://www.iana.org/assignments/sasl-mechanisms/sasl-mechanisms.xhtml#sasl-mechanisms-1)\r\n* [SASL Mechanism ANONYMOUS](https://tools.ietf.org/html/rfc4505)\r\n* [SASL Mechanism PLAIN](https://tools.ietf.org/html/rfc4616)\r\n* [SASL Mechanism EXTERNAL](https://tools.ietf.org/html/rfc4422#page-29)\r\n\r\nAMQP and WebSocket:\r\n\r\n* [AMQP WebSocketBinding](http://docs.oasis-open.org/amqp-bindmap/amqp-wsb/v1.0/amqp-wsb-v1.0.html)\r\n* [WebSocket Protocol](https://tools.ietf.org/html/rfc6455)\r\n* [Http User Agent Header](https://tools.ietf.org/html/rfc2616#section-14.43)\r\n* [OAuth 2.0](https://oauth.net/2/)\r\n* [OAuth 2.0, Client Credentials Grant](https://tools.ietf.org/html/rfc6749#section-4.4)\r\n* [OAuth 2.0, Resource Owner Password Credentials Grant](https://tools.ietf.org/html/rfc6749#section-4.3)\r\n\r\nProtocol Support by others:\r\n\r\n* [Rabbit MQ AMQP 1.0 plugin](https://github.com/rabbitmq/rabbitmq-amqp1.0)\r\n* [AMQP 1.0 in Azure Service Bus and Event Hubs protocol guide](https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-amqp-protocol-guide)\r\n* [Solace: Using AMQP 1.0](https://docs.solace.com/Open-APIs-Protocols/Using-AMQP.htm)\r\n* [Solace: AMQP 1.0 Protocol Conformance](https://docs.solace.com/Open-APIs-Protocols/AMQP-Protocol-Conformance.htm)\r\n* [Qpid Proton Overview](https://qpid.apache.org/proton/index.html)\r\n* [Qpid Proton C++ API](https://qpid.apache.org/releases/qpid-proton-0.22.0/proton/cpp/api/index.html)\r\n* [Qpid Proton-J API](https://qpid.apache.org/releases/qpid-proton-j-0.26.0/api/index.html)\r\n* [Qpid JMS](https://qpid.apache.org/components/jms/index.html)\r\n* [Qpid Proton github repository](https://github.com/apache/qpid-proton)\r\n* [.Net Library: AMQP.Net Lite](https://github.com/Azure/amqpnetlite)\r\n* [Node Library: Rhea](https://github.com/amqp/rhea)\r\n* [Node Library: AMQP 1.0](https://github.com/noodlefrenzy/node-amqp10)\r\n* [Go Library (uses Qpid C library): Qpid Electron](https://godoc.org/qpid.apache.org/electron)\r\n* [Go Library (pure GO, context.Context support): vcabbage/amqp](https://github.com/vcabbage/amqp)\r\n\r\nOthers:\r\n* [Introduction to AMQP 1.0](https://de.slideshare.net/ClemensVasters/amqp-10-introduction)\r\n* [Node: Backpressuring in Streams](https://nodejs.org/en/docs/guides/backpressuring-in-streams/)\r\n\r\n\r\n\r\n"}]