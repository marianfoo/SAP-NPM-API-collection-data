[{"name":"CHANGELOG.md","content":"# Changelog\r\n\r\nAll notable changes to this project will be documented in this file.\r\n\r\nThis project adheres to [Semantic Versioning](http://semver.org/).\r\n\r\nThe format is based on [Keep a Changelog](http://keepachangelog.com/).\r\n\r\n\r\n\r\n                                                                 \r\n## 6.0.0 - 2022-07-01\r\n\r\n### Added\r\n- support for new major cds-compiler 3.0.0\r\n- new user setting `cds.workspaceSymbols.caseInsensitive` (default off) to search case insensitive\r\n- new user setting `cds.outline.semantical` (default off) to show outline in a rather semantical structure as opposed to a flat list\r\n- analyze dependencies now supports coloring of layers for monorepos\r\n- env.cdsc is now also considered for code completion\r\n- custom requests to format given content with given options (e.g. for a _formatting options config UI_) and to get path of options file\r\n\r\n### Changed\r\n- minimum required NodeJS version is now 16.11.1\r\n- updated to Language Server Protocol v3.17.0\r\n  + definition request now returns both, name range and scope range\r\n\r\n## Fixed\r\n- fixed glitches in cds schema support for `package.json`, `.cdsrc.json` and `.cdsrc-private.json`\r\n- fixed highlighting for empty block comments `/**/`\r\n\r\n### Also see\r\n- `@sap/cds-compiler` 3.0.0\r\n\r\n\r\n## 5.5.9 - 2022-05-09\r\n\r\n### Added\r\n\r\n- support syntax highlighting for escape sequences in template strings\r\n- option to disable 'footprint' traces resulting in **no** overhead\r\n- code lens statistics\r\n\r\n### Fixed\r\n\r\n- completion proposals inside comments to turn on/off formatting\r\n- find references could have shown wrong entries from localized context\r\n\r\n### Changed\r\n\r\n- updated included capire docs\r\n\r\n## 5.5.7 - 2022-04-05\r\n\r\n### Fixed\r\n\r\n- syntax highlighting in BAS\r\n\r\n### Changed\r\n\r\n- consume cds-compiler 2.13.8\r\n\r\n\r\n## 5.5.6 - 2022-03-31\r\n\r\n### Added\r\n\r\n- unit test for textmate grammar\r\n\r\n### Changed\r\n\r\n- ignore filtering is now lazy\r\n- formatting options docs are now generated\r\n- consume cds-compiler 2.13.6\r\n\r\n### Fixed\r\n\r\n- no longer set NODE_ENV to production\r\n- highlighting of single quoted strings\r\n\r\n\r\n## 5.5.5 - 2022-03-03\r\n\r\n### Added\r\n\r\n- schema file for `cds` section in `package.json`, `.cdsrc.json` and `.cdsrc-private.json`\r\n\r\n### Fixed\r\n\r\n- code completion for annotations no longer propose `@` if inside an annotation\r\n\r\n## 5.5.4 - 2022-02-28\r\n\r\n### Added\r\n\r\n- new code-formatting options for `action`s and `function`s:\r\n  + `alignActionNames` (aligns names)\r\n  + `alignActionReturns` (aligns `returns` keywords)\r\n\r\n### Changed\r\n\r\n- removed obsolete code-formatting option `alignAsInElements` (calculated fields use `=` now)\r\n- textmate grammar additionally compatible with Ruby regex engine\r\n\r\n### Fixed\r\n\r\n- code formatting:\r\n  + separate post-annotation with blank\r\n  + remove erroneous newlines around cardinality and filter in `select`\r\n  + separate projection items with newlines\r\n- code completion for annotations now correctly handle e.g: @aaa.| entity\r\n- references for annotations: plugins now get all file indexes\r\n\r\n## 5.5.3 - 2022-02-04\r\n\r\n### Added\r\n\r\n- test support for contribution providers\r\n\r\n### Changed\r\n\r\n- CDS language server back to Node 12 (5.5.0 required Node 14 which led to problems in BAS)\r\n- typings for contribution implementors are now bundled and accessible directly via `@sap/cds-lsp`\r\n\r\n### Fixed\r\n\r\n- format-cds CLI was not working under certain circumstances\r\n- syntax highlighting glitches\r\n- code formatting of nested projections\r\n\r\n## 5.5.0 - 2022-01-28\r\n\r\n### Added\r\n\r\n- Command-line interface for code formatter\r\n- CDS language server is now bundled and minified to speed up initialization\r\n- workspace symbols query now supports filters for kinds\r\n\r\n### Changed\r\n\r\n- consume cds-compiler 2.12.0\r\n- code completion for `index.cds` files will now render just the folder\r\n- performance: revalidate file on focus got only if stale index\r\n- memory consumption: indexes are now cached per file, no longer per compilation\r\n\r\n### Fixed\r\n\r\n- `enum` was not indexed \r\n- `composition` of aspect was not indexed\r\n- symbols contained localized entries with recent compiler versions\r\n- workspaces with _many_ workspace folders could lead to stop lsp\r\n- syntax highlighting is now better aligned with CDS grammar:\r\n  + multi-lined strings disabled\r\n  + backslash escaping disabled\r\n  + doubled quotes inside strings to reproduce single quotes\r\n  + element types now include scopes and length/size arguments\r\n\r\n\r\n## 5.4.0 - 2021-12-03\r\n\r\n### Added\r\n\r\n- progress indication for initialization, configuration changed, references and workspace symbols\r\n- support for protocol:selectionRange (though, VSCode has a bug and does not considers it currently)\r\n\r\n### Fixed\r\n\r\n- goto definition of certain references was wrong\r\n- symlinks were not followed when scanning workspace\r\n- (speedup) indexes might got stale even model file hasn't changed\r\n\r\n### Changed\r\n\r\n- consume cds-compiler 2.11.0\r\n- import artifact quickfix now shortens the using path\r\n- @sap/cds/common.cds now included by default\r\n- speedup initialization: no scan/read workspace, reusing source files first read by compiler, unless reference or workspaceSymbols require a scan\r\n- speedup: cache missed paths when compiler resolves using paths\r\n- speedup: only consider models from app/srv/db folders (according cds env) for references and workspace symbols\r\n- speedup when config changes: revalidation of files only if relevant settings changed\r\n- speedup resolution of using paths\r\n- speedup: cds env is now loaded synchronously in-process\r\n- speedup: calculate annotation diagnostics only for active file\r\n- speedup: dynamic registration of configurable requests now done asynchronously at startup\r\n- speedup: files to index for references now ordered by rank\r\n\r\n## 5.3.0 - 2021-09-23\r\n\r\n### Added\r\n\r\n- doc comments are automatically aligned\r\n\r\n### Fixed\r\n\r\n- certain localized elements were still indexed\r\n- new i18n entry in properties file has corrupted existing last entry\r\n- inconsistency in dependency calculation could have led to incorrect revalidations after a change\r\n\r\n### Changed\r\n\r\n- translation support is now lazy\r\n- performance improvements when translation files changed\r\n- last workspace/symbols are cached now to speed up CAP explorer\r\n- user setting cds.workspace.scanCsn has now three modes: Off, ByFileExtension (new default) and InspectJson \r\n\r\n\r\n## 5.2.0 - 2021-07-30\r\n\r\n### Added\r\n\r\n- new validation mode _ActiveEditorOnly_ (new default) for clients indicating support\r\n  via capability _workspace.didChangeActiveEditor_. \r\n  Other clients remain using _OpenEditorsOnly_ as default.\r\n  The new mode reduces number of compilations during editing and thus improves responsiveness.\r\n- new command to analyze using dependencies of CDS model files.\r\n  It will create a graphviz dot file that can be viewed with an appropriate viewer. \r\n  Getting an overview of file dependencies can help to keep your project architecture clean.\r\n\r\n### Changed\r\n\r\n- consume cds-compiler 2.5.0\r\n\r\n\r\n## 5.1.1 - 2021-07-05\r\n\r\n### Changed\r\n\r\n- consume cds-compiler 2.4.4\r\n- new performance relevant user settings\r\n    + `cds.workspace.debounceFastChanges`:  skip intermediate compilations when typing - enabled by default\r\n    + `cds.workspace.scanDependentModules`: skip scanning of node_modules - enabled by default, speeds up start-up time\r\n      Note: \r\n      - when using code completion for global identifiers (see `cds.completion.workspaceSymbols.minPrefixLength`) this option needs to be enabled\r\n      - for code completion of import paths in `using` statements this option needs to be enabled\r\n\r\n\r\n## 5.1.0 - 2021-06-22\r\n\r\n### Note\r\n\r\nThis is a quality release focusing on performance for large models.\r\nThere are new user settings and some have changed their defaults.\r\nBest performance is achieved with default settings, \r\nexcept `cds.contributions.enablement.odata` which should be switched `off` to speed up compilation, unless feature is needed.\r\n\r\nAdditonal hints to increase performance:\r\n- Within _SAP Business Application Studio_: close `CAP Data Models and Services` view. Otherwise it will ask for all workspace symbols at every change.\r\n- Settings: `Cds � Contributions � Enablement: Odata`: switch off as already mentioned above\r\n- Settings: `Editor � Goto Location: Alternative Definition Command`: do not select `goToReferences`. Otherwise being already on a definition will trigger find references which requires all dirty models to be recompiled.\r\n- Settings: `Workbench � Editor � Limit: Enabled`: switch on\r\n- Settings: `Workbench � Editor � Limit: Value`: lower the number. If open editors have `using` dependencies, a change in one editor will lead to a recompile of releated editors.\r\n- Commands `Go to References` / `Find All References` will recompile all models that might have changed due to a change in a depending model. If there are index models it often means the complete workspace is being recompiled. \r\nUntil a further change, reference calculation is resonably fast.\r\n- Command `Go to Symbol in Workspace` will recompile the complete workspace once, then it is reasonable fast\r\n- Changing settings in `CDS` section will currently perform a complete workspace invalidation i.e. required indexes will lead to recompilations on-demand as described above\r\n- Changing certain `cds.env` settings e.g. folder configurations will invalidate the workspace as well\r\n\r\n### Changed\r\n\r\n- consume cds-compiler 2.3.2\r\n- user settings\r\n    + cds.workspaceValidationMode new default: OpenEditorsOnly\r\n    + cds.workspace.scanCsn new settings with default switch off (before implicitly on)\r\n    + cds.quickfix.importArtifact new setting with default off (before implicitly on)\r\n\r\n\r\n## 5.0.5 - 2021-05-11\r\n\r\n### Fixed\r\n\r\n- asynchronous scanning of workspace blocked and led to high cpu usage (mostly on Linux/macOS) \r\n\r\n\r\n## 5.0.3 - 2021-05-06\r\n\r\n### Changed\r\n\r\n- consume cds-compiler 2.2.4\r\n- bug fixes\r\n\r\n## 5.0.1 - 2021-04-22\r\n\r\n### Changed/Fixed\r\n\r\n- where-used for namespaces also for compiler v2\r\n- new query flag for workspace symbols: /n to include implicit namespaces\r\n\r\n## 5.0.0 - 2021-04-02\r\n\r\n### Note\r\n\r\nThis is a major release which comes with @sap/cds-compiler v2.\r\nIt still supports cds-compiler v1 if used in your project\r\nor via global @sap/cds-dk.\r\n\r\n### Added\r\n\r\n- semantic highlighting - to be enabled via user setting `cds.semanticHighlighting.enabled`\r\n- new API for annotation handler to support semantic highlighting\r\n\r\n### Changed\r\n\r\n- consume cds-compiler 2.1.4\r\n\r\n## 4.4.1 - 2021-03-17\r\n\r\n### Added\r\n\r\n- preliminary support for cds-compiler 2.x\r\n\r\n## 4.4.0 - 2021-03-01\r\n\r\n### Changed\r\n\r\n- optimizations for decreased memory consumption\r\n- consume cds-compiler 1.50.0\r\n\r\n## 4.3.0 - 2021-02-01\r\n\r\n### Added\r\n\r\n- asynchronous initialization for annotation plugins (#923)\r\n- find references for annotation plugins (#929)\r\n- revalidate workspace after an initial annotation plugin installation (#930)\r\n\r\n### Changed\r\n\r\n- new user options for where-used request (#877)<br/>\r\nuntil now this functionality was enabled by default and now needs to be enabled via user options\r\n  + generic annotations - where a certain annotation 'class' or 'namespace' is used\r\n  + strings literals - where same string literals are used\r\n\r\n- consume cds-compiler 1.49.0\r\n- compatibility with early versions of cds-compiler 2.x\r\n- simplified consumption of CDS textmate grammar for Jetbrain IDEs\r\n\r\n### Fixed\r\n\r\n- dependency analysis for compilation:\r\nif a changed file has dependencies to the roots, but the\r\nroot models do not cover it, no longer it will compile multiple\r\ntimes\r\n\r\n- translation code action was not shown in the context of annotations\r\n- code completion for annotations had a trailing @ (#883)\r\n- annotation assignment spanned beyond semantical end (#838)\r\n- code formatting of brackets enclosing multiple elements in annotations had wrong indentation\r\n- indexing of `on` condition for elements was broken\r\n- update regex to highlight `one` and `many` keyword properly\r\n\r\n## 4.2.0 - 2020-11-27\r\n\r\n### Added\r\n\r\n- quickfix for deprecated identifiers\r\n- support for quickfixes in annotation handler\r\n- internal support for incremental text updates \r\n- improved supportability with extended statistic logs\r\n\r\n### Changed\r\n\r\n- consume cds-compiler 1.46.4\r\n\r\n### Fixes\r\n\r\n- for annotation handler and others\r\n\r\n## 4.1.2 - 2020-11-12\r\n\r\n### Changed\r\n\r\n- cds-lsp itself no longer dynamically registers file system watching for VSCode, BAS and Eclipse, as those configure it client-side\r\n\r\n### Fixes\r\n\r\n- bug fixes\r\n\r\n## 4.1.1 - 2020-11-06\r\n\r\n### Fixed\r\n\r\n- support for mono repo file system layouts did not work in certain cases\r\n- completion proposals for annotations were not shown at top of the list if inside an annotation\r\n\r\n## 4.1.0 - 2020-10-30\r\n\r\n### Added\r\n\r\n- support mono repo file system layouts\r\n- user option to format snippets after completion \r\n- user option to disable odata plugin\r\n- detection of slow running odata plugin (when validating) incl. user options to disable and fine tune\r\n- user option for omitRedundantTypesInSnippets for annotations\r\n\r\n### Changed\r\n\r\n- install/update contributions completely async\r\n- completion no longer suggests types when values are meant\r\n- project cds-lsp settings overrule all\r\n- consume cds-compiler 1.45.0\r\n\r\n### Fixed\r\n\r\n- validation of annotation plugins led to 100% cpu load\r\n- globally installed cds was not reliably found\r\n- code completion for annotation plugins did not work inside annotations at @ characters\r\n- bug fixes\r\n\r\n### Note\r\n\r\nFrom version 4.1.0 on, @sap/cds-lsp requires NodeJS 12.14+\r\n\r\n## 4.0.0 - 2020-09-30\r\n\r\n### Added\r\n\r\n- Plugin support for domain specific annotation handlers, featuring\r\n  - diagnostics\r\n  - code completion\r\n  - hover information\r\n  - goto definition\r\n  - quickfix to maintain translation\r\n  - auto-installation/update with user setting for npm registry\r\n\r\n- code completion inside string literals and `![...]` identifiers is automatically triggered by `/` character (additionally to `.` and `@`)\r\n  \r\n- snippets applied via code completion are now formatted\r\n\r\n- `action`s and their parameters are now indexed and support code navigation, hover etc.\r\n\r\n### Changed\r\n\r\n- consume cds-compiler 1.42.0\r\n\r\n### Fixed\r\n\r\n- bug fixes\r\n\r\n### Note\r\nFrom version 4.0.0 on, @sap/cds-lsp requires NodeJS 12.8+ (was 10.16+)\r\n\r\n## 3.5.0 - 2020-09-01\r\n\r\n### Added\r\n\r\n- Code completion proposes identifiers not yet imported in current file and generates corresponding `using` statement\r\n  - user setting: minimum number of characters required to propose those identifiers (`cds.completion.workspaceSymbols.minPrefixLength`). Default is -1 (=off)\r\n  - user setting: limit number of global identifiers (`cds.completion.workspaceSymbols.maxProposals`). Default is -1 (=unlimited)\r\n- Code formatting: options `whitespaceBeforeColon` and `whitespaceAfterColon` are now supported inside anonymous structure types\r\n- Code formatting: support configuration of alignment of COMPOSITION structs (option `alignCompositionStructToRight`)\r\n\r\n### Changed\r\n\r\n- consume cds-compiler 1.39.0\r\n\r\n## 3.4.3 - 2020-08-05\r\n\r\n### Changed\r\n\r\n- consume cds-compiler 1.35.0\r\n\r\n## 3.4.2 - 2020-07-28\r\n\r\n### Added\r\n\r\n- new user setting `cds.completion.workspaceSymbols` (default `off`) to add workspace symbols to code completion proposals\r\n- query for workspace symbols allows new option `/f` to consider fully qualified name\r\n\r\n### Changed\r\n\r\n- consume cds-compiler 1.34.0\r\n\r\n### Fixed\r\n\r\n- bug fixes\r\n\r\n## 3.4.0 - 2020-07-10\r\n\r\n### Added\r\n\r\n- support for docComments (/** ... */)\r\n  + hover over artifact will consider docComment\r\n  + snippet to create\r\n  + formatting will beautify docComments, incl. new option maxDocCommentLine\r\n  + quickFix to convert @cds.doc annotation to docComment incl. beautify\r\n  + distinct syntax highlighting for docComments\r\n- quickFix to generate using statement for not yet imported artifacts\r\n  + sorted by module and artifact name, beautified\r\n- semantic code completion for elements, enums, actions and parameters in annotate and extend (via cds-compiler 1.32.0)\r\n- syntax highlighting identifiers, including variants delimited with \\![...]\r\n- identifier completion proposals are prioritized by message severity\r\n- messages may now contain related information\r\n- added INSTALLATION.md for 3rd party IDE integrations\r\n\r\n### Changed\r\n\r\n- consume cds-compiler 1.32.0\r\n- updated README.md with feature list\r\n\r\n### Fixed\r\n\r\n- enum keyword was wrongly syntax highlighted\r\n- when an ignored source file is closed, potential messages are wiped\r\n- annotations of extensions were not indexed\r\n- bug fixes\r\n\r\n## 3.3.2 - 2020-04-26\r\n\r\n### Changed\r\n\r\n- remove optional odata annotation handler due to build issues\r\n\r\n## 3.3.1 - 2020-04-24\r\n\r\n### Changed\r\n\r\n- consume cds-compiler 1.26.2\r\n\r\n## 3.3.0 - 2020-04-24\r\n\r\n### Added\r\n\r\n- use global @sap/cds/common if locally not available\r\n\r\n### Changed\r\n\r\n- consume cds-compiler 1.26.0\r\n- (alpha): diagnostics and hover support for external annotation providers\r\n\r\n### Fixed\r\n\r\n- Minor fixes and improvements\r\n\r\n## 3.2.1 - 2020-03-30\r\n\r\n### Changed\r\n\r\n- consume cds-compiler 1.24.4\r\n\r\n## 3.2.0 - 2020-03-16\r\n\r\n### Changed\r\n\r\n* remove option for compiler location - LSP will always search Project->Global(via DK&CDS)->BuiltIn now\r\n- remove irrelevent formatting option (trimTrailingWhitespace)\r\n- consume cds-compiler 1.24.3\r\n\r\n### Fixed\r\n\r\n- formatting failed (seen in Eclipse, VSCode works) due to off-by-one error\r\n- global npm root for Business App Studio was not found with compiler.location option ProjectThenGlobalThenBuiltIn\r\n\r\n## 3.1.4 - 2020-03-04\r\n\r\n### Added\r\n\r\n- _extend_ definitions are now shown in outline and workspace symbols\r\n- api (alpha) for external annotation providers\r\n\r\n### Changed\r\n\r\n- consume cds-compiler 1.24.0\r\n\r\n## 3.1.3 - 2020-02-24\r\n\r\n### Added\r\n\r\n- pick up compiler and env via global cds-dk if cds not (yet) in project\r\n\r\n### Changed\r\n\r\n- consume cds-compiler 1.23.2\r\n\r\n## 3.1.2 - 2020-02-11\r\n\r\n### Added\r\n* code formatting\r\n    * options can now be overridden in source comments e.g. // @formatter tabSize:3\r\n    * new option to add/remove final line break\r\n    * new option to trim trailing whitespace\r\n\r\n### Changed\r\n* consume cds-compiler 1.23.1\r\n\r\n### Fixed\r\n* in some cases csn files with .json extension where not detected and thus workspace symbols were incomplete\r\n\r\n## 3.1.1 - 2020-01-30\r\n\r\n### Added\r\n* code formatting\r\n    * option to keep original empty lines\r\n* language server protocol 3.15: implement serverInfo in onInitialize\r\n\r\n### Fixed\r\n* formatting options were taken from homedir instead of preferring from project\r\n\r\n## 3.1.0- 2020-01-24\r\n\r\n### Added\r\n* translation support\r\n    * now with all formats supported by runtime (.properties, .json, .csv) incl. quick fixes to create missing entries\r\n    * now with customizations supported by runtime (filename, folder name, fallback_bundle, default_language)\r\n        * if entries of fallback language are missing but are defined for default language the latter ones are used\r\n        * if property files or json nodes or csv header only has default language defined (and not raw), quick fix will use default language\r\n        * quick fix for json and csv formats now try to keep entries sorted\r\n        * navigation from translation reference in cds source files to value supported for all formats\r\n* allow .cdsprettier.json to be located in user home dir\r\n\r\n### Changed\r\n* code formatting\r\n    * improve alignment of types, values, and preceding `:` or `=` operators\r\n* consume cds-compiler 1.22.0\r\n\r\n### Fixed\r\n* code formatting\r\n    * fix, improve, and allow to better adjust alignments and whitespace\r\n    * fix alignment of annotations in `annotate` statement\r\n    * fix casing of and indentation after `Association` and `Composition`\r\n    * fix formatting of parts of `select` statement in case of nesting and after `in`\r\n    * fix positioning of brace `{` after annotation if requested to be kept in previous line\r\n    * fix bug where token starting with `$` was merged\r\n* in the past file changes via watcher were automatically sent for all files in VSCode.\r\n  In recent versions of VSCode this has changed to only sent files supported by language server type (cds).\r\n  A fix was made to dynamically register for relevant side-files like\r\n  package.json, .cdsrc.json, all supported translation file formats, ignore files\r\n  to keep track of changed environment\r\n\r\n## 3.0.0 - 2019-12-16\r\nOfficial support for code formatting\r\n\r\n### Changed\r\n* code completion\r\n    * more snippet variants for extend\r\n    * no longer differ entity suggestions between within service or outside\r\n    * base types with parameters now suggested as simply keyword w/o params and additional suggestion as snippet (param names now enclosed in < >)\r\n    * changed label indicator for snippets from <> to ellipsis\r\n* consume cds-compiler 1.21.1\r\n* code formatting\r\n    * rework formatting options: add/remove options according to relevance, rename/group options for clarity, change default behavior in some cases\r\n    * various improvements, including in case statements and bracketed conditions\r\n\r\n### Fixed\r\n* code formatting\r\n    * fix alignment of annotations in views\r\n    * safely identify unreserved keywords\r\n\r\n## [2.1.21]\r\n### Fixes\r\n* Fix indentation after element definitions using Association or Composition\r\n\r\n## [2.1.20]\r\n### Added\r\n* support LSP configuration via settings file in workspace incl. logs in workspace\r\n\r\n### Changed\r\n* consume cds-compiler 1.20.3\r\n\r\n### Fixed\r\n* fix: extraction of root models did no longer work since @sap/cds#3.19\r\n* code formatting\r\n    * Fix indentation of keywords `union`, `except`, and `minus`\r\n    * Make alignments more consistent generally\r\n    * Improve readability by padding operators with blanks\r\n    * Improve alignment of bracketed conditions\r\n\r\n## [2.1.19]\r\n* consume cds-compiler 1.20.0\r\n* fixes and enhancements in code formatting\r\n\r\n## [2.1.18]\r\n* syntax highlighting: now supports 'default' keyword, plus minor fixes\r\n* removed dependencies to ts-md5 and vscode-uri\r\n* **for all IDE providers**: _out_ folder was renamed to _lib_\r\n* new internal URI handling: especially on Windows no longer encode drive letter colon\r\n\r\n## [2.1.17]\r\n* minor text polishing for config UI\r\n\r\n## [2.1.16]\r\n* fixes and enhancements for code formatting\r\n    * renamed settings file to .cdsprettier.json\r\n    * schema with parentOption and basic markdown support for label (new) and description\r\n* renamed tmLanguage for syntax highlighting\r\n* consume cds-compiler 1.19.2\r\n\r\n## [2.1.15]\r\n* fixes and enhancements for code formatting\r\n* clean-ups in LSP project setup\r\n* consume cds-compiler 1.19.1\r\n\r\n## [2.1.13]\r\n* fix regression: schema file was not included\r\n\r\n## [2.1.12]\r\n* fix minor issues\r\n\r\n## [2.1.11]\r\n* schema for formatting options with category, description, code sample, suboptions, enum values\r\n* now sits on node 10+\r\n* consume cds-compiler 1.18.1\r\n\r\n## [2.1.10]\r\n* Fixes and enhancement for syntax highlighting and code formatting\r\n\r\n## [2.1.9]\r\n* Syntax highlighting now uses different classifications (=colors) for annotations and comments\r\n* Support user settings in $LSP/.cds-lsp/.settings.json for IDEs which do not support user settings (Eclipse, Intellij, ...)\r\n* No longer report compiler messages for csn files\r\n* Preparation for config editor for formatting options\r\n* Deadlock detection and prevention for code formatting incl. option to cancel or try best in case\r\n* Use json parsing from compiler for csn files (which allows comments etc.)\r\n* Fixes and enhancements in source formatting\r\n* consume cds-compiler 1.17.3\r\n\r\n## [2.1.8]\r\n* code formatting - many fixes and enhancements\r\n    * now on by default but still experimental\r\n* syntax highlighting reworked for CDL and CQL keywords\r\n* where-used index now with using path segments\r\n* updated cds documentation (in code completion)\r\n* outline now shows contexts and services with fully qualified name\r\n* other fixes and improvements\r\n* consume cds-compiler 1.17.0\r\n\r\n## [2.1.7]\r\n* consume cds-compiler 1.16.2\r\n* fixes and improvements\r\n\r\n## [2.1.6]\r\n* beautify: improve alignment of comments and robustness\r\n* bug fix: outline showed entries not contained in file\r\n\r\n## [2.1.5]\r\n* consume cds-compiler 1.16.1\r\n* beautification for annotations and CQL\r\n\r\n## [2.1.4]\r\n* consume cds-compiler 1.15.0\r\n* user option to enable beautify: cds.experimental.beautify.enable (default false)\r\n\r\n## [2.1.3]\r\n* consume cds-compiler 1.14.0\r\n\r\n## [2.1.2]\r\n* consume cds-compiler 1.13.4\r\n* using compiler from project workspace now default\r\n\r\n## [2.1.1]\r\n* consume cds-compiler 1.13.1\r\n* performance improvements (less compilations and reduced memory footprint)\r\n* Links to folders in using statement are now resolved\r\n\r\n## [2.1.0]\r\n* consume cds-compiler 1.12.1\r\n* new where-used index with less memory consumption and support for references of custom annotations, built-in types, string constants and better tracking of identifiers in CQL\r\n* targets of using statement now rendered as links (via documentLink request)\r\n\r\n## [2.0.8]\r\n* performance optimizations for translation support\r\n* consume cds-compiler 1.10.0\r\n\r\n## [2.0.7]\r\n* new switch: cds.compiler.markMissingI18nDefault (default: off) to show problem markers for unresolved i18n references\r\n* bug fixes\r\n\r\n## [2.0.6]\r\n* consume cds-compiler 1.9.0\r\n* bug fixes\r\n\r\n## [2.0.5]\r\n* fix dependency installation in public cloud\r\n* consume cds-compiler 1.8.1\r\n\r\n## [2.0.4]\r\n* suggest @sap/cds/common as default path in using snippet if dependency to @sap/cds is present\r\n\r\n## [2.0.3]\r\n* fixes\r\n\r\n## [2.0.2]\r\n* consume cds-compiler 1.8.0\r\n\r\n## [2.0.1]\r\n* doc support (snippet for localization, hover on translation id)\r\n* consume cds-compiler 1.7.1\r\n* new unofficial switch cds.compiler.showInternalErrors\r\n* cds-compiler 1.7.1\r\n\r\n## [2.0.0]\r\n* Snippets for title and description\r\n* Code completion for translation references\r\n* Create translation properties file in quickfix if none existing\r\n* fixes\r\n\r\n## [1.4.25]\r\n* support for cds.doc\r\n* cds-compiler 1.6.0\r\n\r\n## [1.4.24]\r\n* Goto-definition for paths in using statement\r\n* New user preference to configure minimum severity of compilation problems\r\n* Compiler 1.5.0\r\n* Fix support of git and git+https dependencies\r\n\r\n## [1.4.23]\r\n* code completions for using statement paths\r\n* reworked snippets\r\n* minor fixes\r\n\r\n## [1.4.22]\r\n* CSN files are now detected and including in where-used index e.g. for workspace symbols\r\n* Introduce per-file compilation mode which speeds up where-used features expecially for large workspaces. User setting cds.compilation.mode (default PerFile)\r\n* Installation of dependencies in package.json files\r\n    * now configurable via user setting cds.autoInstallDependencies (default off)\r\n    * if turned on it only reinstalls if dependency definitions exist and have changed since last install. Other changes in package.json files are ignored\r\n    * package.json files are no longer reformatted when installing dependencies\r\n    * .cdsignore can be used to exclude paths from installation e.g. test folders with package.json files\r\n* In internal landscape within WebIDE it is now possible to use git-git-URLs to internal github in addition to https-git-URLs\r\n* Compiler 1.3.0\r\n* Trace now measures durations with high precision, includes compilation footprint (number of files and size of compiled sources) and shows memory changes\r\n"},{"name":"doc","nodes":[{"name":"00-Intro-and-Benefits-.md","content":"\r\n## Why use _@sap/cds/common_?\r\n\r\nIt is strongly recommended that all applications use the common types and aspects provided through _@sap/cds/common_ in order to benefit from these features:\r\n\r\n* **concise** and **comprehensible** models &rarr; see also [Capture Intent](../guides/domain-models#capture-intent)\r\n* **foster interoperability** between all applications doing so\r\n* **proven best practices** captured from real applications\r\n* **streamlined** data models with **minimal entry barriers**\r\n* **optimized** implementations and runtime performance\r\n* **automatic** support for [localized] code lists and value helps\r\n* **extensibility** to adapt to your needs using [Aspects](../guides/domain-models#aspects)\r\n* **verticalization** through third party extension packages\r\n* **out-of-the-box** support for [Business Configuration]\r\n\r\n\r\nFor example, usage is as simple as indicated in the following sample:\r\n\r\n```swift\r\nusing { Country } from '@sap/cds/common';\r\nentity Addresses {\r\n  street  : String;\r\n  town    : String;\r\n  country : Country; //> using reuse type\r\n}\r\n```\r\n\r\n### Outcome = optimized best practice\r\n\r\nThe final outcomes in terms of modeling patterns, persistence structures, and implementations is essentially the same as what you would have done in a straightforward approach with native means --- if you would have collected design experiences from prior solutions, such as we did.\r\n\r\n**Note:** All the common reuse features discussed herein and provided through _@sap/cds/common_ are provided only through this ~100 lines .cds model. There's no additional runtime support required; it merely makes use of basic CDS modeling features as well as generic features like [localized data] and [temporal data] (which, in turn, also only need minimal runtime support with minimal overhead).\r\n\r\nIn effect, the results are **straightforward**, capturing **best practices** we learned from real business applications, with **minimal footprint**, **optimized performance** and **maximized adaptability** and **extensibility**.\r\n"},{"name":"01-Common-Aspects-.md","content":"\r\n## Common reuse aspects\r\n\r\n\r\n_@sap/cds/common_ defines the following [aspects] for use in your entity definitions. They give you not only shortcuts for concise and comprehensible models but also interoperability and out-of-the-box runtime features connected to them.\r\n\r\n### aspect `cuid`\r\n\r\nUse this as a convenient shortcut to add canonic, universally unique primary keys to your entity definitions. For example:\r\n\r\n```swift\r\nentity Foo : cuid {...}\r\n```\r\n\r\n... is equivalent to:\r\n\r\n```swift\r\nentity Foo {\r\n  key ID : UUID;\r\n  ...\r\n}\r\n```\r\n\r\n**Note:** The service provider runtimes automatically fill in UUID-typed keys like these with auto-generated UUIDs.\r\n\r\n[learn more about **canonic keys** and **UUIDs**](../guides/domain-models#use-canonic-primary-keys){: .learn-more}\r\n\r\n\r\n### aspect `managed`\r\n\r\nUse this to add four elements to capture created by/at and latest changed by/at management information for records.\r\n\r\n```swift\r\nentity Foo : managed {...}\r\n```\r\n\r\n... is essentially equivalent to:\r\n\r\n```swift\r\nentity Foo {\r\n  modifiedAt : DateTime;\r\n  createdAt  : DateTime;\r\n  createdBy  : String;\r\n  modifiedBy : String;\r\n  ...\r\n}\r\n```\r\n\r\n**In addition** to what's shown above, the pre-defined elements are annotated in a way that has the respective fields managed and filled in automatically by the generic service providers. Moreover, the fields are annotated with `@Core.Immutable` that tells Fiori clients to handle them as non-editable fields.\r\n\r\n[learn more about **generic service features**](../guides/providing-services#generic-providers){: .learn-more}\r\n\r\n\r\n### aspect `temporal`\r\n\r\nThis aspect basically adds two canonic elements, `validFrom` and `validTo` to an entity. It also adds a tag annotation that connects the cds compiler's and runtime's built-in support for _[Temporal Data]_, which covers handling date-effective records and time slices, including time travel. All you have to do is add the temporal aspect to respective entities as follows:\r\n\r\n```swift\r\nentity Contract : temporal {...}\r\n```\r\n\r\n[learn more about **temporal data**][temporal data]{: .learn-more}\r\n"},{"name":"02-Common-Types-.md","content":"\r\n## Common reuse types\r\n{:#code-types}\r\n\r\n_@sap/cds/common_ provides predefined easy-to-use types for _Countries_, _Currencies_ and _Languages_.\r\nUsing these in all applications fosters interoperability.\r\n\r\n### type `Country`\r\n[`Country`]: #country\r\n\r\nThe reuse type `Country` is defined in _@sap/cds/common_ as a simple managed [Association] to the [code list](#code-lists) for countries as follows:\r\n\r\n```swift\r\ntype Country : Association to sap.common.Countries;\r\n```\r\n\r\nHere's an example of how you would use that reuse type:\r\n\r\n{% include _code sample='using-country-type.cds' %}\r\n\r\nThe [code lists](#code-lists) define a key element `code`, which results in a foreign key column `country_code` in your SQL table for Addresses. For example:\r\n\r\n{% include _code sample='using-country-type.sql' %}\r\n\r\n[learn more about **managed associations**][Associations]{: .learn-more}\r\n\r\n\r\n\r\n### type `Currency`\r\n\r\n```swift\r\ntype Currency : Association to sap.common.Currencies;\r\n```\r\n\r\n[essentially same as for `Country`](#type-country){: .learn-more}\r\n\r\n### type `Language`\r\n\r\n```swift\r\ntype Language : Association to sap.common.Languages;\r\n```\r\n\r\n[essentially same as for `Country`](#type-country){: .learn-more}\r\n"},{"name":"03-Entities-.md","content":"\r\n## Entities, Views<!-- omit in toc -->\r\n\r\n- [entities](#entities)\r\n- [views](#views)\r\n- [views with declared signatures](#views-with-declared-signatures)\r\n- [views with parameters](#views-with-parameters)\r\n- [abstract entities](#abstract-entities)\r\n- [entity ... as projection on](#entity--as-projection-on)\r\n\r\n\r\n### entities\r\n\r\nEntities are essentially structured types representing sets of (persisted) data\r\nthat can be read and manipulated using CRUD operations. They usually contain\r\nprimary key elements. The leading `define` is optional.\r\n\r\n```swift\r\nentity Employees {\r\n  key ID : Integer;\r\n  name : String;\r\n  jobTitle : String;\r\n}\r\n```\r\nA most simple entity definition is:\r\n```\r\nentity Foo {};\r\n```\r\n\r\n### views\r\n\r\nViews are entities defined by projection on underlying entities/views, like views\r\nin SQL. The element signatures are usually inferred from the projection.\r\nThe projection can be any valid query.\r\n\r\n```swift\r\nentity SomeView as SELECT from Employees { * };\r\nentity Foo as SELECT from Bar; //> implicit {*}\r\n```\r\n\r\nViews inherit all properties and annotations from their primary underlying base entity. Their [`elements`]({{csn}}#structs) signature is **inferred** from the projection on base elements and each element inherits all properties from the respective base element.\r\n\r\nFor example, a view like that:\r\n\r\n```swift\r\nentity SomeView as SELECT from Employees {\r\n  ID, name, job.title as jobTitle\r\n};\r\n```\r\n\r\nwould probably have an inferred signature equivalent to that:\r\n```swift\r\nentity SomeView {\r\n  ID: Integer; name: String; jobTitle: String;\r\n};\r\n```\r\n\r\n\r\n### views with declared signatures\r\n{: .impl.concept}\r\n\r\nYou can optionally declare a view's expected signature explicitly. This will completely override the inferred signature. And implementation can check the inferred signature against the declared (i.e. expected) one.\r\n\r\n```swift\r\nentity SomeView {\r\n  ID: Integer; name: String; jobTitle: String;\r\n} as SELECT from Employees {\r\n  ID, name, job.title as jobTitle\r\n};\r\n```\r\n\r\n\r\n### views with parameters\r\n\r\nViews can be equipped with parameters that need to be passed in whenever that\r\nview is queried. Default values can be specified. The parameters can be referred\r\nto in the view's query using the prefix `:`.\r\n\r\n```swift\r\nentity SomeView ( foo: Integer, bar: Boolean )\r\nas SELECT * from Employees where ID=:foo;\r\n```\r\n\r\n\r\n### abstract entities\r\n\r\nYou can prefix an entity definition with the keyword `abstract` to indicate that\r\nthis entity should not have instances; i.e. just an _entity type_ declaration without\r\nan _entity set_. When activated to a database, no persistence artifacts, i.e. tables and views in SQL, are created.\r\n\r\n```swift\r\nabstract entity Foo {...}\r\nabstract entity Foo as SELECT from Bar {...};\r\n```\r\n\r\n\r\n\r\n### entity ... as projection on\r\n\r\nYou can use `as projection on` instead of `as SELECT from` to indicate restrictions on the allowed expressions of the following query.\r\n\r\n\r\n```swift\r\nentity Foo as projection on Bar {...}\r\n```\r\n\r\n> This is to support custom implementations in parsing the query, which would add respective checks.\r\nThe core `cds` parser and compiler modules themselves don't make any assumptions nor about restrictions on allowed expressions neither about when and where `as projection on` is allowed instead of `as SELECT from`.\r\n"},{"name":"04-CDS","nodes":[{"name":"11-CDL.md","content":"---\r\nlayout: cds-ref\r\nshorty: Definition Language\r\nsynopsis: >\r\n  A reference and overview of all CDS concepts and features with compact examples written in CDS' definition language.\r\npermalink: cds/cdl\r\nstatus: released\r\nuacp: Used as link target from Help Portal at https://help.sap.com/viewer/65de2977205c403bbc107264b8eccf4b/Cloud/en-US/855e00bd559742a3b8276fbed4af1008.html\r\n---\r\n\r\n# Definition Language (CDL)\r\n<style>\r\n  h2 {\r\n    font-weight: 300; font-size: 2.8em; color: #222;\r\n    border-bottom: .5px solid silver;\r\n    padding-bottom: 5px;\r\n  }\r\n  h3 {\r\n    font-weight: 400;\r\n    font-size: 1.5em;\r\n  }\r\n</style>\r\n\r\nFind here a reference of all CDS concepts and features in the form of compact examples.\r\nThe examples are given in **_CDL_**, a human-readable syntax for defining models, and **_CQL_**, an extension of SQL to write queries.\r\n\r\n\r\n{% include _toc levels=\"2,3\" %}\r\n{% include links.md %}\r\n\r\n<br>\r\nPlease refer also to [_The Nature of Models_](models) and the [_CSN specification_][CSN] to complete your understanding of CDS.\r\n\r\n<br>\r\n\r\n\r\n## Entity and Type Definitions\r\n\r\n- [Entity Definitions](#entities) --- `define entity`\r\n- [Type Definitions](#types) --- `define type`\r\n- [Predefined Types](#predefined-types)\r\n- [Structured Types](#structured-types)\r\n- [Arrayed Types](#arrayed-types)\r\n- [Virtual Elements](#virtual-elements)\r\n- [Calculated Fields](#calculated-fields)\r\n- [Default Values](#default-values)\r\n- [Constraints](#constraints)\r\n- [Enums](#enums)\r\n\r\n\r\n\r\n\r\n### Entity Definitions --- `define entity`\r\n{:#entities}\r\n\r\nEntities are structured types with named and typed elements,\r\nrepresenting sets of (persisted) data that can be read and manipulated using usual CRUD operations.\r\nThey usually contain one or more designated primary key elements:\r\n\r\n```swift\r\ndefine entity Employees {\r\n  key ID : Integer;\r\n  name : String;\r\n  jobTitle : String;\r\n}\r\n```\r\n\r\n> The `define` keyword is optional, that means `define entity Foo` is equal to `entity Foo`.\r\n\r\n\r\n### Type Definitions --- `define type`\r\n{:#types}\r\n\r\nYou can declare custom types to reuse later on, for example, for elements in entity definitions.\r\nCustom-defined types can be simple, that is derived from one of the predefined types, structure types or [Associations].\r\n\r\n```swift\r\ndefine type User : String(111);\r\ndefine type Amount {\r\n  value : Decimal(10,3);\r\n  currency : Currency;\r\n}\r\ndefine type Currency : Association to Currencies;\r\n```\r\n> The `define` keyword is optional, that means `define type Foo` is equal to `type Foo`.\r\n\r\n[Learn more about **Definitions of Named Aspects**.](#aspects){:.learn-more}\r\n\r\n\r\n\r\n\r\n### Predefined Types\r\n\r\n\r\n[See list of **Built-in Types**](types){:.learn-more}\r\n\r\n\r\n\r\n\r\n### Structured Types\r\n\r\nYou can declare and use custom struct types as follows:\r\n\r\n```swift\r\ntype Amount {\r\n  value : Decimal(10,3);\r\n  currency : Currency;\r\n}\r\nentity Books {\r\n  price : Amount;\r\n}\r\n```\r\n\r\nElements can also be specified with anonymous inline struct types.\r\nFor example, the following is equivalent to the definition of `Books` above:\r\n\r\n```swift\r\nentity Books {\r\n  price : {\r\n    value : Decimal(10,3);\r\n    currency : Currency;\r\n  };\r\n}\r\n```\r\n\r\n\r\n### Arrayed Types\r\n\r\nPrefix a type specification with `array of` or `many` to signify array types.\r\n\r\n```swift\r\nentity Foo { emails: many String; }\r\nentity Bar { emails: many { kind:String; address:String; }; }\r\nentity Car { emails: many EmailAddress; }\r\nentity Car { emails: EmailAddresses; }\r\ntype EmailAddresses : many { kind:String; address:String; }\r\ntype EmailAddress : { kind:String; address:String; }\r\n```\r\n\r\n> Keywords `many` and `array of` are mere syntax variants with identical semantics and implementations.\r\n\r\nWhen deployed to SQL databases, such fields are mapped to [LargeString](types) columns.\r\nWith OData V4, arrayed types are rendered as `Collection` in the EDM(X).\r\n\r\nGeneric support in runtimes is added over time. It's available in Node.js but not yet in Java. If not available, you need to add custom logic, for example, to serialize payloads into JSON strings and vice versa.\r\n\r\n\r\n\r\n### Virtual Elements\r\n\r\nAn element definition can be prefixed with modifier keyword `virtual`. This keyword indicates that this element isn't added to persistent artifacts, that is, tables or views in SQL databases. Virtual elements are part of OData metadata.\r\n\r\n```swift\r\nentity Employees {\r\n  ...\r\n  virtual something : String(11);\r\n}\r\n```\r\n### Literals\r\n\r\nUsing literals in CDS models is commonly used, for example, to set default values. The literals in the following table show you how to define these values in your CDS source.\r\n\r\n| Kind | Example |\r\n| --- | --- |\r\n| Null | `null` |\r\n| Boolean | `true`, `false` |\r\n| Numbers | `11` or  `2.4` |\r\n| Strings | `'foo'` |\r\n| Dates |  `'2016-11-24'` |\r\n| Times  |  `'16:11'` |\r\n| DateTimes |  `'2016-11-24T16:11'` |\r\n| Records |  `{\"foo\":<literal>, ...}` |\r\n| Arrays |  `[<literal>, ...]` |\r\n\r\n[Learn more about literals and their representation in CSN.]({{cap}}/cds/csn#literals){:.learn-more}\r\n\r\n### Calculated Fields\r\n{: .impl.concept}\r\n\r\nElements can be specified with a calculation expression in which you can refer to other elements of the same entity.\r\n\r\n```swift\r\nentity Employees {\r\n  addresses : Association to many Addresses;\r\n  homeAddress = addresses [kind='home'];\r\n}\r\n```\r\n\r\n\r\n### Default Values\r\n\r\nAs in SQL you can specify default values to fill in upon INSERTs if no value is specified for a given element.\r\n\r\n```swift\r\nentity Foo {\r\n  bar : String default 'bar';\r\n  boo : Integer default 1;\r\n}\r\n```\r\n\r\n\r\n### Type References\r\n{:#typereferences}\r\n\r\nIf you want to base an element's type on another element of the same structure, you can use the `type of` operator.\r\n\r\n```swift\r\nentity Author {\r\n  firstname : String(100);\r\n   lastname : type of firstname; // has type \"String(100)\"\r\n}\r\n```\r\n\r\nFor referencing elements of other artifacts, you can use the element access through `:`.\r\nElement references with `:` don’t require `type of` in front of them.\r\n\r\n```swift\r\nentity Employees {\r\n  firstname: type of Author:firstname;\r\n   lastname: Author:firstname; // optional type of\r\n}\r\n```\r\n\r\n\r\n### Constraints\r\n\r\nElement definitions can be augmented with constraint `not null` as known from SQL.\r\n\r\n```swift\r\nentity Employees {\r\n  name : String(111) not null;\r\n}\r\n```\r\n\r\n\r\n### Enums\r\n\r\nYou can specify enumeration values for a type as a semicolon-delimited list of symbols. String and integer enums are supported. For string types, declaration of actual values is optional; if omitted, the actual values then are the string counterparts of the symbols.\r\n\r\n```swift\r\ntype Gender : String enum { male; female; }\r\nentity Order {\r\n  status : Integer enum {\r\n    submitted =  1;\r\n    fulfilled =  2;\r\n    shipped   =  3;\r\n    canceled  = -1;\r\n  };\r\n}\r\n```\r\n\r\n\r\n<br>\r\n\r\n\r\n## Views and Projections\r\n{:#views}\r\n\r\nUse `as select from` or `as projection on` to derive new entities from existing ones by projections, very much like views in SQL. When mapped to relational databases, such entities are in fact translated to SQL views but they're frequently also used to declare projections without any SQL views involved.\r\n\r\nThe entity signature is inferred from the projection.\r\n\r\n- [The `as select from` Variant](#as-select-from)\r\n- [The `as projection on` Variant](#as-projection-on)\r\n- [Views with Inferred Signatures](#views-with-inferred-signatures)\r\n- [Views with Declared Signatures](#views-with-declared-signatures)\r\n- [Views with Nested Projections](#views-with-nested-projections)\r\n- [Views with Parameters](#views-with-parameters)\r\n\r\n\r\n### The `as select from` Variant\r\n{:#as-select-from}\r\n\r\nUse the `as select from` variant to use all possible features an underlying relational database would support using any valid [CQL] query including all query clauses.\r\n\r\n```swift\r\nentity Foo1 as SELECT from Bar; //> implicit {*}\r\nentity Foo2 as SELECT from Employees { * };\r\nentity Foo3 as SELECT from Employees LEFT JOIN Bar on Employees.ID=Bar.ID {\r\n  foo, bar as car, sum(boo) as moo\r\n} where exists (\r\n  SELECT 1 as anyXY from SomeOtherEntity as soe where soe.x = y\r\n)\r\ngroup by foo, bar\r\norder by moo asc;\r\n```\r\n\r\n\r\n### The `as projection on` Variant\r\n{:#as-projection-on}\r\n\r\nUse the `as projection on` variant instead of `as select from` to indicate that you don’t use the full power of SQL in your query. For example, having a restricted query in an entity allows us to serve such an entity from external OData services.\r\n\r\n\r\n```swift\r\nentity Foo as projection on Bar {...}\r\n```\r\n\r\nCurrently the restrictions of `as projection on` compared to `as select from` are:\r\n\r\n- no explicit, manual `JOINs`\r\n- no explicit, manual `UNIONs`\r\n- no sub selects in from clauses\r\n\r\nOver time, we can add additional checks depending on specific outbound protocols.\r\n\r\n\r\n### Views with Inferred Signatures\r\n\r\nBy default views inherit all properties and annotations from their primary underlying base entity.\r\nTheir [`elements`]({{csn}}#structured-types) signature is **inferred** from the projection on base elements.\r\nEach element inherits all properties from the respective base element.\r\n\r\nFor example, the following definition:\r\n\r\n```swift\r\nentity SomeView as SELECT from Employees {\r\n  ID,\r\n  name,\r\n  job.title as jobTitle\r\n};\r\n```\r\n\r\nMight result in this inferred signature:\r\n\r\n```swift\r\nentity SomeView {\r\n  ID: Integer;\r\n  name: String;\r\n  jobTitle: String;\r\n};\r\n```\r\n\r\n\r\n### Views with Declared Signatures\r\n{: .impl.concept}\r\n\r\nYou can optionally declare the expected signature explicitly. This declaration overrides the inferred signature. The implementation can check the inferred signature against the declared one.\r\n\r\n```swift\r\nentity SomeView {\r\n  ID: Integer; name: String; jobTitle: String;\r\n} as SELECT from Employees {\r\n  ID, name, job.title as jobTitle\r\n};\r\n```\r\n\r\n\r\n### Views with Nested Projections\r\n{: .impl.concept}\r\n\r\nUse [CQL's nested expands]({{cql}}#nested-expands) to declare projections on document structures and/or entity graphs, in turn resulting in structured document signatures.\r\n\r\n```swift\r\nentity MyOrders as select from Orders {\r\n  ID, buyer {\r\n    ID, name\r\n  },\r\n  Items {\r\n    pos, quantity, product {\r\n      ID, title\r\n    }\r\n  }\r\n};\r\n```\r\n\r\nThis projection would result in an inferred signature like that:\r\n\r\n\r\n```swift\r\nentity MyOrders {\r\n  ID : UUID;\r\n  buyer : {\r\n    ID : UUID;\r\n    name : String;\r\n  };\r\n  Items : array of {\r\n    pos : Integer;\r\n    quantity : Integer;\r\n    product : {\r\n      ID : UUID;\r\n      title : String;\r\n    }\r\n  }\r\n};\r\n```\r\n\r\n\r\n### Views with Parameters\r\n\r\nYou can equip views with parameters that are passed in whenever that view is queried. Default values can be specified. Refer to these parameters in the view's query using the prefix `:`.\r\n\r\n```swift\r\nentity SomeView ( foo: Integer, bar: Boolean )\r\nas SELECT * from Employees where ID=:foo;\r\n```\r\n[Learn more about how to expose views with parameters in **Services - Exposed Entities**.](#exposed-entities){: .learn-more}\r\n[Learn more about views with parameters for existing HANA artifactsSee in **Native SAP HANA Artifacts**.]({{cap}}/advanced/hana){: .learn-more}\r\n\r\n\r\n\r\n## Associations & Compositions\r\n{:#associations}\r\n\r\nAssociations capture relationships between entities. They are like forward-declared joins added to a table definition in SQL.\r\n\r\n- [Unmanaged Associations](#unmanaged-associations)\r\n- [Managed Associations](#managed-associations)\r\n- [To-many Associations](#to-many-associations)\r\n- [Many-to-many Associations](#many-to-many-associations)\r\n- [Managed many-to-many Associations](#managed-many-to-many-associations)\r\n- [Associations with Default Filters](#associations-with-default-filters)\r\n- [Associations to Parameterized Views](#associations-to-parameterized-views)\r\n- [Compositions](#compositions)\r\n- [Managed Compositions](#managed-compositions)\r\n\r\n\r\n### Unmanaged Associations\r\n\r\nUnmanaged associations specify arbitrary join conditions in their `on` clause, which refer to available foreign key elements. The association's name (`address` in the following example) is used as the alias for the to-be-joined target entity.\r\n\r\n```swift\r\nentity Employees {\r\n  address : Association to Addresses on address.ID = address_ID;\r\n  address_ID : Integer;  //> foreign key\r\n}\r\n```\r\n```swift\r\nentity Addresses {\r\n  key ID : Integer;\r\n}\r\n```\r\n\r\n\r\n### Managed (To-One) Associations\r\n{:#managed-associations}\r\n\r\nFor to-one associations, CDS can automatically resolve and add requisite foreign key elements from the target's primary keys and implicitly add respective join conditions.\r\n\r\n```swift\r\nentity Employees {\r\n  address : Association to Addresses;\r\n}\r\n```\r\n\r\nThis example is equivalent to the [unmanaged example above](#unmanaged-associations), with the foreign\r\nkey element `address_ID` being added automatically upon activation to a SQL database.\r\n\r\n> No foreign key constraints are added on database level.\r\n\r\n\r\n### To-many Associations\r\n\r\nFor to-many associations specify an `on` condition following the canonical expression pattern `<assoc>.<backlink> = $self` as in this example:\r\n\r\n```swift\r\nentity Employees {\r\n  key ID : Integer;\r\n  addresses : Association to many Addresses\r\n    on addresses.owner = $self;\r\n}\r\n```\r\n```swift\r\nentity Addresses {\r\n  owner : Association to Employees;  //> the backlink\r\n}\r\n```\r\n\r\n> The backlink can be any managed to-one association on the _many_ side pointing back to the _one_ side.\r\n\r\n\r\n### Many-to-many Associations\r\n\r\nFor many-to-many association, follow the common practice of resolving logical many-to-many relationships into two one-to-many associations using a link entity to connect both.\r\nFor example:\r\n\r\n```swift\r\nentity Employees { ...\r\n  addresses : Association to many Emp2Addr on addresses.emp = $self;\r\n}\r\nentity Emp2Addr {\r\n  key emp : Association to Employees;\r\n  key adr : Association to Addresses;\r\n}\r\n```\r\n\r\n[Learn more about **Managed Compositions for Many-to-many Relationships**.](#for-many-to-many-relationships){:.learn-more}\r\n\r\n\r\n\r\n### Managed many-to-many Associations\r\n{: .impl.concept}\r\n\r\nWith Managed Many-to-many Associations, CDS can generate requisite link tables automatically. You can use the `via` parameter clause to add elements to link table reflecting attributed relationships or to use a predefined link table instead.\r\n\r\n```swift\r\nentity Employees {\r\n  addresses1 : Association to many Addresses;\r\n  addresses2 : Association to many Addresses via {\r\n    kind: String(11);\r\n  };\r\n  addresses3 : Association to many Addresses via Emp2Addr;\r\n}\r\n```\r\n\r\nFor the first case, [`cds.compile`]({{cap}}/node.js/cds-compile) automatically adds a link table.\r\nFor the second case, it automatically adds a link table with an additional element `kind` (&rarr; an _attributed relationship_).\r\nFor the third case, [`cds.compile`]({{cap}}/node.js/cds-compile) uses the predefined entity `Emp2Addr` that is defined like that (names for `source/target` can be freely chosen):\r\n\r\n```swift\r\nentity Emp2Addr {\r\n  key emp : Association to Employees;\r\n  key adr : Association to Addresses;\r\n}\r\n```\r\n\r\n\r\n\r\n### Associations with Default Filters\r\n{: .impl.concept}\r\n\r\nFor to-many associations, you can optionally specify a default filter. That filter automatically\r\napplies to any usage of that association in queries, unless another filter is specified explicitly.\r\n\r\n```swift\r\nentity Products {\r\n  localized : Association to many Product$Texts\r\n    with default filter lang=$env.user.lang;\r\n}\r\n```\r\n```swift\r\nentity Product$Texts {\r\n  key product : Association to Products;\r\n  key lang : String(3);\r\n  title : String(44);\r\n  descr : String(444);\r\n}\r\n```\r\n\r\n### Associations to Parameterized Views\r\n{: .impl.concept}\r\n\r\nIf the target is a [parameterized view](#views-with-parameters), you can specify\r\ncorresponding arguments in an `Association` definition as follows:\r\n\r\n```swift\r\nentity Products {\r\n  assoc : Association to SomeParameterizedView (\r\n    param1: 4711,\r\n    param2: foo\r\n  );\r\n  foo : String;\r\n}\r\n```\r\n\r\n> The argument values for parameters are literals or expressions in which references are resolved within the current entity's elements.\r\n\r\n\r\n\r\n<br>\r\n\r\n\r\n### Compositions\r\n\r\nCompositions constitute document structures through 'contained-in' relationships.\r\nThey frequently show up in to-many header-child scenarios.\r\n\r\n```swift\r\nentity Orders {\r\n  key ID: Integer; //...\r\n  Items : Composition of many Orders.Items on Items.parent = $self;\r\n}\r\nentity Orders.Items {\r\n  key pos : Integer;\r\n  key parent : Association to Orders;\r\n  product : Association to Products;\r\n  quantity : Integer;\r\n}\r\n```\r\n\r\n> Essentially, Compositions are the same as _[associations]_, just with the additional information that this association represents a contained-in relationship so the same syntax and rules apply in their base form.\r\n\r\n\r\n### Managed Compositions of Aspects\r\n{:#managed-compositions}\r\n\r\nUse managed compositions variant to nicely reflect document structures in your domain models, without the need for separate entities, reverse associations, and unmanaged `on` conditions.\r\n\r\n\r\n#### With Inline Targets\r\n\r\n```swift\r\nentity Orders { \r\n  key ID: Integer; //...\r\n  Items : Composition of many { \r\n    key pos : Integer;\r\n    product : Association to Products;\r\n    quantity : Integer;\r\n  }\r\n}\r\n```\r\n\r\nManaged Compositions are mostly syntactical sugar: Behind the scenes, they are unfolded to the [unmanaged equivalent as shown above](#compositions) \r\nby automatically adding a new entity, the name of which being constructed as a [scoped name](#scoped-names) from the name of parent entity, followed by the name of the composition element, \r\nthat is `Orders.Items` in the previous example.\r\n\r\n\r\n#### With Named Targets\r\n\r\nInstead of anonymous target aspects you can also specify named aspects, which are unfolded the same way than anonymous inner types, as shown in the previous example:\r\n\r\n```swift\r\nentity Orders {\r\n  key ID: Integer; //...\r\n  Items : Composition of many OrderItems;\r\n}\r\naspect OrderItems { \r\n  key pos : Integer;\r\n  product : Association to Products;\r\n  quantity : Integer;\r\n}\r\n```\r\n\r\n#### For Many-to-many Relationships\r\n\r\nManaged Compositions are handy for [many-to-many relationships](#many-to-many-associations), where a link table usually is private to one side.\r\n\r\n```swift\r\nentity Teams { ...\r\n  members : Composition of many { key user: Association to Users; }\r\n}\r\nentity Users { ...\r\n  teams: Association to many Teams.members on teams.user = $self;\r\n}\r\n```\r\n\r\nAnd here's an example of an attributed many-to-many relationship:\r\n\r\n```swift\r\nentity Teams { ...\r\n  members : Composition of many {\r\n    key user : Association to Users;\r\n    role : String enum { Lead; Member; Collaborator; }\r\n  }\r\n}\r\nentity Users { ... }\r\n```\r\n\r\n\r\n\r\n\r\n## Annotations\r\n\r\nThis section describes how to add Annotations to model definitions written in CDL, focused on the common syntax options, and fundamental concepts. Find additional information in the [OData Annotations] guide. \r\n\r\n- [Annotation Syntax](#annotation-syntax)\r\n- [Annotation Targets](#annotation-targets)\r\n- [Annotation Values](#annotation-values)\r\n- [Records as Syntax Shortcuts](#records-as-syntax-shortcuts)\r\n- [The `annotate` Directive](#annotate)\r\n\r\n\r\n### Annotation Syntax\r\n\r\nAnnotations in CDL are prefixed with an `@` character and can be placed before a definition, after the defined name or at the end of simple definitions.\r\n\r\n```swift\r\n@before entity Foo @inner {\r\n  @before simpleElement @inner : String @after;\r\n  @before structElement @inner { /* elements */ }\r\n}\r\n```\r\n\r\nMultiple annotations can be placed in each spot separated by whitespaces or enclosed in `@(...)` and separated by comma - like the following are equivalent:\r\n\r\n```swift\r\nentity Foo @(\r\n  my.annotation: foo,\r\n  another.one: 4711\r\n) { /* elements */ }\r\n```\r\n```swift\r\n@my.annotation:foo\r\n@another.one: 4711\r\nentity Foo { /* elements */ }\r\n```\r\n\r\nFor an `@inner` annotation, only the syntax `@(...)` is available.\r\n\r\n### Annotation Targets\r\n\r\nYou can basically annotate any named thing in a CDS model, such as:\r\n\r\nContexts and services:\r\n\r\n```java\r\n@before [define] (context|service) Foo @inner { ... }\r\n```\r\n\r\nDefinitions and elements with simple types:\r\n\r\n```java\r\n@before [define] type Foo @inner : String @after;\r\n@before [key] anElement @inner : String @after;\r\n```\r\n\r\nEntities, aspects, and other struct types and elements thereof:\r\n\r\n```java\r\n@before [define] (entity|type|aspect|annotation) Foo @inner {\r\n  @before simple @inner : String @after;\r\n  @before struct @inner { ...elements... };\r\n}\r\n```\r\n\r\nEnums:\r\n\r\n```java\r\n... status : String @inner enum {\r\n  fulfilled @after;\r\n}\r\n```\r\n\r\nColumns in a view definition's query:\r\n\r\n```java\r\n... as SELECT from Foo {\r\n  @before expr as alias @inner : String,\r\n  ...\r\n}\r\n```\r\n\r\nParameters in view definitions:\r\n\r\n```java\r\n... with parameters (\r\n  @before param @inner : String @after\r\n) ...\r\n```\r\n\r\nActions/functions including their parameters and result elements:\r\n\r\n```java\r\n@before action doSomething @inner (\r\n  @before param @inner : String @after\r\n) returns {\r\n  @before result @inner : String @after;\r\n};\r\n```\r\n\r\n\r\n### Annotation Values\r\n\r\nValues can be literals or references. If no value is given, the default value is `true` as for `@aFlag` in the following example:\r\n\r\n```java\r\n@aFlag //= true, if no value is given\r\n@aBoolean: false\r\n@aString: 'foo'\r\n@anInteger: 11\r\n@aDecimal: 11.1\r\n@aSymbol: #foo\r\n@aReference: foo.bar\r\n@anArray: [ /* can contain any kind of value */ ]\r\n```\r\n\r\nAs described in the [CSN spec]({{csn}}#literals), the previously mentioned annotations would compile to CSN as follows:\r\n\r\n```\r\n{\r\n  \"@aFlag\": true,\r\n  \"@aBoolean\": false,\r\n  \"@aString\": \"foo\",\r\n  \"@anInteger\": 11,\r\n  \"@aDecimal\": 11.1,\r\n  \"@aSymbol\": {\"#\":\"foo\"},\r\n  \"@aReference\": {\"=\":\"foo.bar\"},\r\n  \"@anArray\": [ ... ]\r\n}\r\n```\r\n\r\nReferences (and expressions in general) aren't checked or resolved by CDS parsers or linkers. They’re interpreted and evaluated only on consumption-specific modules. For example, for SAP Fiori models, it's the _4odata_ and _2edm(x)_ processors.\r\n{:.tip}\r\n\r\n\r\n### Records as Syntax Shortcuts\r\n\r\nAnnotations in CDS are flat lists of key-value pairs assigned to a target.\r\nThe record syntax - that is, `{key:<value>, ...}` - is a shortcut notation that applies a common prefix to nested annotations.\r\nFor example, the following are equivalent:\r\n\r\n```java\r\n@Common.foo.bar\r\n@Common.foo.car: 'wheels'\r\n```\r\n```java\r\n@Common: { foo.bar, foo.car: 'wheels' }\r\n```\r\n```java\r\n@Common.foo: { bar }\r\n@Common.foo.car: 'wheels'\r\n```\r\n```java\r\n@Common.foo: { bar, car: 'wheels'  }\r\n```\r\n\r\nand they would show up as follows in a parsed model (&rarr; see [CSN][]):\r\n\r\n```\r\n{\r\n  \"@Common.foo.bar\": true,\r\n  \"@Common.foo.car\": \"wheels\",\r\n}\r\n```\r\n\r\n### Annotation Propagation\r\n\r\nAnnotations are inherited from types and base types to derived types, entities, and elements as well as from elements of underlying entities in case of views.\r\n\r\nFor examples, given this view definition:\r\n\r\n```swift\r\nusing Books from './bookshop-model';\r\nentity BooksList as SELECT from Books {\r\n  ID, genre : Genre, title,\r\n  author.name as author\r\n};\r\n```\r\n\r\n* `BooksList` would inherit annotations from `Books`\r\n* `BooksList.ID` would inherit from `Books.ID`\r\n* `BooksList.author` would inherit from `Books.author.name`\r\n* `BooksList.genre` would inherit from type `Genre`\r\n\r\nThe rules are:\r\n\r\n1. Entity-level properties and annotations are inherited from the **primary** underlying source entity --- here `Books`.\r\n\r\n2. Each element that can **unambiguously** be traced back to a single source element, inherits that element's properties.\r\n\r\n3. An explicit **cast** in the select clause cuts off the inheritance, for example, as for `genre` in our previous example.\r\n\r\n\r\n\r\n### The `annotate` Directive\r\n{:#annotate}\r\n\r\nThe `annotate` directive allows to annotate already existing definitions, that may have been [imported](#imports) from other files or projects.\r\n\r\n```swift\r\nannotate Foo with @title:'Foo' {\r\n  nestedStructField {\r\n    existingField @title:'Nested Field';\r\n  }\r\n}\r\nannotate Bar with @title:'Bar';\r\n```\r\n\r\nThe `annotate` directive a variant of the [`extend` directive](#extend).\r\nActually, `annotate` is just a shortcut with the default mode being switched to `extend`ing existing fields instead of adding new ones.\r\n\r\n<br>\r\n\r\n## Aspects\r\n\r\nCDS's aspects allow to flexibly extend definitions by new elements as well as overriding properties and annotations.\r\nThey're based on a mixin approach as known from Aspect-oriented Programming methods.\r\n\r\n- [The `extend` Directive](#extend)\r\n- [Named Aspects](#aspect) --- `define aspect`\r\n- [Shortcut Syntax `:`](#includes)\r\n- [Looks Like Inheritance](#looks-like-inheritance)\r\n- [Extending Views / Projections](#extend-view)\r\n\r\n\r\n### The `extend` Directive\r\n{: #extend}\r\n\r\nUse `extend` to add extension fields or to add/override metadata to existing definitions, for example, annotations, as follows:\r\n\r\n```swift\r\nextend Foo with @title:'Foo' {\r\n  newField : String;\r\n  extend nestedStructField {\r\n    newField : String;\r\n    extend existingField @title:'Nested Field';\r\n  }\r\n}\r\nextend Bar with @title:'Bar'; // nothing for elements\r\n```\r\n\r\nMake sure that you prepend the `extend` keyword to nested elements, otherwise this would mean that you want to add a new field with that name:\r\n{:.tip}\r\n\r\n[Learn more about the **annotate** Directive.](#annotate){:.learn-more}\r\n\r\n\r\n\r\n### Named Aspects --- `define aspect`\r\n{:#aspect}\r\n\r\nYou can use `extend` or `annotate` with predefined aspects, to apply the same extensions to multiple targets:\r\n\r\n```swift\r\nextend Foo with ManagedObject;\r\nextend Bar with ManagedObject;\r\n```\r\n```swift\r\naspect ManagedObject {\r\n  created { at: Timestamp; _by: User; }\r\n}\r\n```\r\n\r\n> The `define` keyword is optional, that means `define aspect Foo` is equal to `aspect Foo`.\r\n\r\nIf you use `extend`, all nested fields in the named aspect are interpreted as being extension fields. If you use `annotate`, the nested fields are interpreted as existing fields and the annotations are copied to the corresponding target elements.\r\n\r\nThe named extension can be anything, for example, including other `types` or `entities`.\r\nUse keyword `aspect` as shown in the example to declare definitions that are only meant to be used in such extensions, not as types for elements.\r\n\r\n\r\n\r\n### Includes -- `:` as Shortcut Syntax\r\n{:#includes}\r\n\r\nYou can use an inheritance-like syntax option to extend a definition with one or more [named aspects](#aspect)\r\nas follows:\r\n\r\n```swift\r\ndefine entity Foo : ManagedObject, AnotherAspect {\r\n  key ID : Integer;\r\n  name : String;\r\n  ...\r\n}\r\n```\r\n\r\nThis is syntactical sugar and equivalent to using a sequence of [extends](#extend) as follows:\r\n\r\n```swift\r\ndefine entity Foo {}\r\nextend Foo with ManagedObject;\r\nextend Foo with AnotherAspect;\r\nextend Foo with {\r\n  key ID : Integer;\r\n  name : String;\r\n  ...\r\n}\r\n```\r\n\r\nYou can apply this to any definition of an entity or a structured type.\r\n\r\n\r\n\r\n### Looks Like Inheritance\r\n\r\nThe `:`-based syntax option described before looks very much like (multiple) inheritance and in fact has very much the same effects. Yet, as mentioned in the beginning of this\r\nsection, it isn’t based on inheritance but on mixins, which are more powerful and also avoid common problems like the infamous diamond shapes in type derivations.\r\n\r\nWhen combined with persistence mapping there are a few things to note, that goes down to which strategy to choose to map inheritance to, for example, relational models. See [_Aspects vs Inheritance_](../cds/aspects-inheritance) for more details.\r\n\r\n\r\n### Extending Views and Projections\r\n{: #extend-view}\r\n\r\nUse the `extend projection` variant to extend the projection of a view entity to include more elements existing in the underlying entity:\r\n\r\n```swift\r\nextend projection Foo with @title:'Foo' {\r\n  foo as bar @car\r\n}\r\n```\r\n\r\nEnhancing nested structs isn’t supported. Note also that you can use the common [`annotate`](#annotate) syntax, to just add/override annotations of a view's elements.\r\n{:.tip}\r\n\r\n<br>\r\n\r\n\r\n## Services\r\n\r\n- [Service Definitions](#service-definitions)\r\n- [Exposed Entities](#exposed-entities)\r\n- [(Auto-) Redirected Associations](#auto-redirect)\r\n- [Auto-exposed Targets](#auto-expose)\r\n- [Custom Actions/Functions](#actions)\r\n- [Custom-defined Events](#events)\r\n- [Extending Services](#extend-service)\r\n- [Derived Services](#derived-services)\r\n\r\n\r\n### Service Definitions\r\n\r\nCDS allows to define service interfaces as collections of exposed entities enclosed in a `service` block, which essentially is and acts the same a [`context`](#context):\r\n\r\n```swift\r\nservice SomeService {\r\n  entity SomeExposedEntity { ... };\r\n  entity AnotherExposedEntity { ... };\r\n}\r\n```\r\n\r\nThe endpoint of the exposed service is constructed by its name, following some conventions (the string `service` is dropped and kebab-case is enforced). If you want to overwrite the path, you can add the `@path` annotation as follows:\r\n\r\n```swift\r\n@path: 'myCustomServicePath'\r\nservice SomeService { ... }\r\n```\r\n\r\n\r\n### Exposed Entities\r\n\r\nThe entities exposed by a service are most frequently projections on entities from underlying data models.\r\nStandard view definitions, using [`as SELECT from`](#views) or [`as projection on`](#as-projection-on), can be used for\r\nexposing entities.\r\n\r\n```swift\r\nservice CatalogService {\r\n  entity Product as projection on data.Products {\r\n    *, created.at as since\r\n  } excluding { created };\r\n}\r\nservice MyOrders {\r\n  view Order as select from data.Orders { * } where buyer=$user.id;  //> $user not yet implemented!\r\n  entity Product as projection on CatalogService.Product;\r\n}\r\n```\r\n\r\nYou can optionally add annotations such as `@readonly` or `@insertonly` to exposed entities, which, will be enforced by the CAP runtimes in Java and Node.js.\r\n{:.tip}\r\n\r\nEntities can be also exposed as views with parameters:\r\n\r\n```swift\r\nservice MyOrders {\r\n  view OrderWithParameter( foo: Integer ) as select from data.Orders where id=:foo;\r\n}\r\n```\r\nA [`view with parameter`](#views-with-parameters) modeled in the previous example, can be exposed as follows:\r\n\r\n```swift\r\nservice SomeService {\r\n  view ViewInService( p1: Integer, p2: Boolean ) as select from data.SomeView(foo: :p1, bar: :p2) {*};\r\n}\r\n```\r\nThen the OData request for views with parameters should look like this:\r\n\r\n```swift\r\nGET: /OrderWithParameter(foo=5)/Set or GET: /OrderWithParameter(5)/Set\r\nGET: /ViewInService(p1=5, p2=true)/Set\r\n```\r\n\r\n\r\n### (Auto-) Redirected Associations\r\n{:#auto-redirect}\r\n\r\nWhen exposing related entities, associations are automatically redirected. This ensures that clients can navigate between projected entities as expected. For example:\r\n\r\n```swift\r\nservice AdminService {\r\n  entity Books as projection on my.Books;\r\n  entity Authors as projection on my.Authors;\r\n  //> AdminService.Authors.books refers to AdminService.Books\r\n}\r\n```\r\n\r\n#### Resolving Ambiguities \r\n\r\nAuto-redirection fails if a target can't be resolved unambiguously, that is, when there is more than one projection with the same minimal 'distance' to the source. For example, compiling the following model with two projection on `my.Books` would produce this error:\r\n\r\n{:.danger-title}  \r\nTarget \"Books\" is exposed in service \"AdminService\" by multiple projections \"AdminService.ListOfBooks\", \"AdminService.Books\" - no implicit redirection.\r\n{:.danger} \r\n\r\n```swift\r\nservice AdminService {\r\n  entity ListOfBooks as projection on my.Books;\r\n  entity Books as projection on my.Books;\r\n  entity Authors as projection on my.Authors;\r\n  //> which one should AdminService.Authors.books refers to?\r\n}\r\n```\r\n\r\n#### Using `redirected to` with projected Associations\r\n\r\nYou can use `redirected to` to resolve the ambiguity as follows:\r\n\r\n```swift\r\nservice AdminService {\r\n  ...\r\n  entity Authors as projection on my.Authors { *,\r\n    books : redirected to Books //> resolved ambiguity\r\n  };\r\n}\r\n```\r\n\r\n#### Using `@cds.redirection.target` Annotations\r\n\r\nAlternatively, you can use the boolean annotation `@cds.redirection.target` with value `true` to make an entity a preferred redirection target, or with value `false` to exclude an entity as target for auto-redirection.\r\n\r\n```swift\r\nservice AdminService {\r\n  @cds.redirection.target: true\r\n  entity ListOfBooks as projection on my.Books;\r\n  ...\r\n}\r\n```\r\n\r\n### Auto-Exposed Entities\r\n\r\n{:#auto-expose}\r\n\r\nAnnotate entities with `@cds.autoexpose` to automatically expose them in services containing entities with Association referring to them. \r\n\r\nFor example, given the following entity definitions:\r\n\r\n```swift\r\n// schema.cds\r\nnamespace schema;\r\nentity Bar @cds.autoexpose { key id: Integer; }\r\n\r\nusing { sap.common.CodeList } from '@sap/cds/common';\r\nentity Car : CodeList { key code: Integer; }\r\n//> inherits  @cds.autoexpose from  sap.common.CodeList\r\n```\r\n\r\n... a service definition like this:\r\n\r\n```swift\r\nusing { schema as my } from './schema.cds';\r\nservice Zoo {\r\n  entity Foo { //...\r\n    bar : Association to my.Bar;\r\n    car : Association to my.Car;\r\n  }\r\n}\r\n```\r\n\r\n... would result in the service being automatically extended like this:\r\n\r\n```swift\r\nextend service Zoo with { // auto-exposed entities:\r\n   @readonly entity Foo_bar as projection on Bar;\r\n   @readonly entity Foo_car as projection on Car;\r\n}\r\n```\r\n\r\nYou can still expose such entities explicitly, for example, to make them read-write:\r\n\r\n```swift\r\nservice Sue {\r\n  entity Foo { /*...*/ }\r\n  entity Bar as projection on my.Bar;\r\n}\r\n```\r\n\r\n[Learn more about **CodeLists in `@sap/cds/common`**.][{{cap}}/cds/common#code-lists]{:.learn-more}\r\n\r\n### Custom Actions and Functions\r\n{:#actions}\r\n\r\nWithin service definitions, you can additionally specify `actions` and `functions`. Use a comma-separated list of named and typed inbound parameters and an\r\noptional response type, which can be either a:\r\n\r\n- [Predefined Type](types)\r\n- [Reference to a custom-defined type](#types)\r\n- [Inline definition of an anonymous structured type](#structured-types)\r\n\r\n```swift\r\nservice MyOrders {\r\n  entity Order { /*...*/ };\r\n  // unbound actions / functions\r\n  type cancelOrderRet {\r\n    acknowledge: String enum { succeeded; failed; };\r\n    message: String;\r\n  }\r\n  action cancelOrder ( orderID:Integer, reason:String ) returns cancelOrderRet;\r\n  function countOrders() returns Integer;\r\n  function getOpenOrders() returns array of Order;\r\n}\r\n```\r\n\r\nThe notion of actions and functions in CDS adopts that of [OData](http://docs.oasis-open.org/odata/odata/v4.0/os/part1-protocol/odata-v4.0-os-part1-protocol.html#_Toc372793737); actions and functions on service-level are _unbound_ ones.\r\n{:.tip}\r\n\r\n\r\n#### Bound Actions and Functions\r\n{: #bound-actions}\r\n\r\nActions and functions can also be bound to individual entities of a service, enclosed in an additional `actions` block as the last clause in an entity/view definition.\r\n\r\n```swift\r\nservice CatalogService {\r\n  entity Products as projection on data.Products { ... }\r\n    actions {\r\n      // bound actions/functions\r\n      action addRating (stars: Integer);\r\n      function getViewsCount() returns Integer;\r\n    }\r\n}\r\n```\r\n\r\n\r\n### Custom-Defined Events\r\n{:#events .impl.beta}\r\n\r\nSimilar to [Actions and Functions][actions] you can declare `events`, which a service emits via messaging channels. Essentially, an event declaration looks very much like a type definition, specifying the event's name and the type structure of the event messages' payload.\r\n\r\n```swift\r\nservice MyOrders { ...\r\n  event OrderCanceled {\r\n    orderID: Integer;\r\n    reason: String;\r\n  }\r\n}\r\n```\r\n\r\n### Extending Services\r\n{:#extend-service}\r\n\r\nYou can [extend](#extend) services with additional entities and actions much as you would add new entities to a context:\r\n\r\n```swift\r\nextend service CatalogService with {\r\n  entity Foo {};\r\n  function getRatings() returns Integer;\r\n}\r\n```\r\n\r\nSimilarly, you can [extend](#extend) entities with additional actions\r\nas you would add new elements:\r\n\r\n\r\n```swift\r\nextend entity CatalogService.Products with actions {\r\n  function getRatings() returns Integer;\r\n}\r\n```\r\n\r\n\r\n### Derived Services\r\n{: .impl.concept}\r\n\r\nDefine abstract services and inherit from it in other service definitions as in this example:\r\n\r\n```swift\r\nabstract service ShoppingService {\r\n  abstract entity Articles {...}\r\n  entity Suppliers {...}\r\n  entity ShoppingCart {} actions {\r\n    action submitOrder();\r\n  }\r\n}\r\n```\r\n\r\n```swift\r\nservice Bookshop : ShoppingService {\r\n  entity Books : ShoppingService.Articles {\r\n    author : Association to Authors;\r\n  }\r\n  entity Authors {...}\r\n}\r\n```\r\n\r\n\r\n\r\n<br>\r\n\r\n## Namespaces\r\n\r\n- [The `namespace` Directive](#namespace)\r\n- [The `context` Directive](#context)\r\n- [Fully Qualified Names](#fully-qualified-names)\r\n\r\n\r\n### The `namespace` Directive\r\n{:#namespace}\r\n\r\nTo prefix the names of all subsequent definitions, place a `namespace` directive at the top of a model. This is comparable to other languages, like Java.\r\n\r\n{% include _code sample='namespaces.cds' %}\r\n\r\n\r\n### The `context` Directive\r\n{:#context}\r\n\r\nUse `contexts` for nested namespace sections.\r\n\r\n{% include _code sample='contexts.cds' %}\r\n\r\n\r\n\r\n### Scoped Definitions\r\n{:#scoped-names}\r\n\r\nYou can define types and entities with other definitions' names as prefixes:\r\n\r\n```swift\r\nnamespace foo.bar;\r\nentity Foo {}           //> foo.bar.Foo\r\nentity Foo.Bar {}       //> foo.bar.Foo.Bar\r\ntype Foo.Bar.Car {}     //> foo.bar.Foo.Bar.Car\r\n```\r\n\r\n\r\n### Fully Qualified Names\r\n\r\nA model ultimately is a collection of definitions with unique, fully qualified names. For example, the second model above would compile to this [CSN][]:\r\n\r\n{% include _code sample='contexts.json' %}\r\n\r\n\r\n<br>\r\n\r\n## Import Directives\r\n{:#imports}\r\n\r\n  - [The `using` Directive](#using)\r\n  - [The `import` Directive](#import)\r\n  - [Model Resolution](#model-resolution)\r\n\r\n\r\n### The `using` Directive\r\n{:#using}\r\n\r\nUsing directives allows to import definitions from other CDS models. As shown in line three below you can specify aliases to be used subsequently. You can import single definitions as well as several ones with a common namespace prefix. Optional: Choose a local alias.\r\n\r\n{% include _code sample='using-from.cds' %}\r\n\r\nMultiple named imports through es6-like deconstructors:\r\n\r\n```swift\r\nusing { Foo as Moo, sub.Bar } from './base-model';\r\nentity Boo : Moo { /*...*/ }\r\nentity Car : Bar { /*...*/ }\r\n```\r\n\r\n> Also in the deconstructor variant of `using` shown in the previous example, specify fully qualified names.\r\n\r\n\r\n### The `import` Directive\r\n{: #import .impl.concept}\r\n\r\nThe `import` directive extends the `using` directive to fully support syntax and semantics of [`import` statements in ES6][ES6].\r\n\r\nImported names can omit the target's namespace prefix:\r\n\r\n```swift\r\nimport {Foo} from './base-model';\r\n```\r\n\r\nMultiple named imports through es6-like deconstructors:\r\n\r\n```swift\r\nimport { Foo as Moo, scoped.Bar } from './base-model';\r\nentity Boo : Moo;\r\nentity Car : Bar;\r\n```\r\n\r\n\r\nImports with locally chosen prefixes (independent from target namespaces):\r\n\r\n```swift\r\nimport base from './base-model';\r\nentity Foo : base.Foo;\r\nentity Bar : base.scoped.Bar;\r\n```\r\n\r\n\r\n### Model Resolution\r\n\r\nImports in `cds` work very much like `require` in [node][] and `imports` in [ES6][].\r\nIn fact, we reuse **[Node's module loading mechanisms](https://nodejs.org/api/modules.html#modules_all_together)**.\r\nHence, the same rules apply:\r\n\r\n* Relative path resolution\r\n  Names starting with `./` or `../` are resolved relative to the current model.\r\n* Resolving absolute references\r\n  They're fetched for in `node_modules` folders:\r\n  * Files having `.cds`, `.csn`, or `.json` as suffixes, appended in order\r\n  * Folders, from either the file set in `cds.main` in the folder's `package.json` or `index.<cds|csn|json>` file.\r\n\r\nTo allow for loading from precompiled `.json` files it’s recommended to **omit `.cds` suffixes** in import statements, as shown in the provided examples.\r\n{:.tip}\r\n"},{"name":"12-CSN.md","content":"---\r\nlayout: cds-ref\r\nshorty: Schema Notation\r\nsynopsis: >\r\n  Specification of CSN, CDS' canonical format for representing CDS models as plain JavaScript objects, similar to [JSON Schema].\r\npermalink: cds/csn\r\nstatus: released\r\nuacp: Used as link target from Help Portal at https://help.sap.com/viewer/65de2977205c403bbc107264b8eccf4b/Cloud/en-US/855e00bd559742a3b8276fbed4af1008.html\r\n---\r\n\r\n# Schema Notation (CSN)\r\n\r\nCSN (pronounced as \"_Season_\") is a notation for compact representations of CDS models — tailored to serve as an optimized format to share and interpret models with minimal footprint and dependencies.\r\n\r\nIt’s similar to [JSON Schema][] but goes beyond JSON's abilities, in order to capture full-blown _Entity-Relationship Models_ and [Extensions](#aspects). This makes CSN models a perfect source to generate target models, such as [OData/EDM][odata] or [OpenAPI] interfaces, as well as persistence models for SQL or NoSQL databases.\r\n\r\n[JSON Schema]: https://json-schema.org\r\n\r\n\r\n\r\n#### Content\r\n{% include _toc levels=\"2,3\" %}\r\n{% include links.md %}\r\n\r\n\r\n\r\n## Anatomy\r\n\r\nA CSN model in **JSON**:\r\n\r\n```json\r\n{\r\n  \"requires\": [ \"@sap/cds/common\", \"./db/schema\" ],\r\n  \"definitions\": {\r\n    \"some.type\": { \"type\": \"cds.String\", \"length\": 11 },\r\n    \"another.type\": { \"type\": \"some.type\" },\r\n    \"structured.type\": { \"elements\": {\r\n      \"foo\": { \"type\": \"cds.Integer\" },\r\n      \"bar\": { \"type\": \"cds.String\" }\r\n    }}\r\n  },\r\n  \"extensions\": [\r\n    { \"extend\":\"Foo\", \"elements\":{\r\n      \"bar\": { \"type\": \"cds.String\" }\r\n    }}\r\n  ]\r\n}\r\n```\r\n\r\nThe same model in **YAML**:\r\n\r\n```yaml\r\nrequires:\r\n  - @sap/cds/common\r\n  - ./db/schema,\r\ndefinitions:\r\n  some.type: {type: cds.String, length: 11}\r\n  another.type: {type: some.type }\r\n  structured.type:\r\n    elements:\r\n      foo: {type: cds.Integer}\r\n      bar: {type: cds.String}\r\nextensions: [\r\n  - extend: Foo\r\n    elements: \r\n      bar: {type: cds.String}\r\n]\r\n```\r\n\r\nThe same model as a **plain JavaScript** object:\r\n\r\n```js\r\n({\r\n  requires:[ '@sap/cds/common', './db/schema' ],\r\n  definitions: {\r\n    'some.type': { type:\"cds.String\", length:11 },\r\n    'another.type': { type:\"some.type\" },\r\n    'structured.type': { elements: {\r\n      'foo': { type:\"cds.Integer\" },\r\n      'bar': { type:\"cds.String\" }\r\n    }}\r\n  },\r\n  extensions: [\r\n    { extend:'Foo', elements:{\r\n      'bar': { type:\"cds.String\" }\r\n    }\r\n  ],\r\n})\r\n```\r\n\r\nFor the remainder of this spec, you see examples in plain JavaScript representation with the following **conventions**:\r\n\r\n```js\r\n({property:...})   // a CSN-specified property name\r\n({'name':...})     // a definition's declared name\r\n\"value\"            // a string value, including referred names\r\n11, true           // number and boolean literal values\r\n```\r\n\r\n#### Properties\r\n* [`requires`](#imports) --- an array listing [imported models](#imports)\r\n* [`definitions`](#definitions) ---  a dictionary of named [definitions](#definitions)\r\n* [`extensions`](#aspects) --- an array of unnamed [aspects](#aspects)\r\n* [`i18n`](#i18n) --- a dictionary of dictionaries of [text translations](#i18n)\r\n\r\nAll properties are optional. For example, one model could contain a few definitions, while another one only contains some extensions.\r\n{:.tip}\r\n\r\n> References are case-sensitive. All references in properties like `type` or `target` use exactly the same notation regarding casing as their targets' names. To avoid problems when translating models to case-insensitive environments like SQL databases, avoid case-significant names and references. For example, avoid two different definitions in the same scope whose names only differ in casing, such as `foo` and `Foo`.\r\n\r\n\r\n\r\n\r\n## Literals\r\n\r\nThere are several places where literals can show up in models, such as in SQL expressions, calculated fields, or annotations.\r\n\r\nStandard literals are represented as in JSON:\r\n\r\n| Kind | Example |\r\n| --- | --- |\r\n| Globals | `true`, `false`, `null` |\r\n| Numbers<sup>1</sup> | `11` or  `2.4` |\r\n| Strings | `\"foo\"` |\r\n| Dates<sup>2</sup> |  `\"2016-11-24\"` |\r\n| Times<sup>2</sup>  |  `\"16:11\"` |\r\n| DateTimes<sup>2</sup> |  `\"2016-11-24T16:11\"` |\r\n| Records |  `{\"foo\":<literal>, ...}` |\r\n| Arrays |  `[<literal>, ...]` |\r\n\r\nIn addition, CSN specifies these special forms for references, expressions, and `enum` symbols:\r\n\r\n| Kind | Example |\r\n| --- | --- |\r\n| Unparsed Expressions | `{\"=\":\"foo.bar < 9\"}` |\r\n| Enum symbols<sup>3</sup> |  `{\"#\":\"asc\"}` |\r\n\r\n#### Remarks\r\n\r\n><sup>1</sup> This is as in JSON and shares the same issues when decimals are mapped to doubles with potential rounding errors. The same applies to Integer64. Use strings to avoid that, if applicable.\r\n>\r\n><sup>2</sup> Also, as in JSON, dates, and times are represented just as strings as specified in [ISO 8601][]; consumers are assumed to know the types and handle the values correctly.\r\n>\r\n><sup>3</sup> As enum symbols are equal to their values, it frequently suffices to just provide them as strings. Similar to time and dates in CSN and JSON, the consumers are assumed to know the types and handle the values correctly. The  `{\"#\":...}` syntax option is to serve cases where you have to distinguish the kind only based on the provided value, for example, in untyped annotations.\r\n\r\n\r\n\r\n\r\n\r\n## Definitions\r\n\r\nEach entry in the `definitions` dictionary is essentially a type definition. The name is the absolute, fully qualified name of the definition, and the value is a record with the definition details.\r\n\r\n\r\n#### Example\r\n\r\n```js\r\n({definitions:{\r\n  'Name':     {type:\"cds.String\"},\r\n  'Currency': {type:\"cds.String\", length:3},\r\n  'USD':      {type:\"Currency\"},\r\n  'Amount':   {elements:{\r\n    'value':    {type:\"cds.Decimal\", precision:11, scale:3},\r\n    'currency': {type:\"Currency\"},\r\n  }},\r\n  'SortOrder':{enum:{ 'asc':{}, 'desc':{} }}\r\n}})\r\n```\r\n\r\nThe __name__ of a definition is its key in the enclosing dictionary, like in `definitions` for top-level entries or in `elements` for structured types and entities.\r\n\r\nNames **must**:\r\n* Be nonempty strings.\r\n* Neither start, nor end with `.` or `::`.\r\n* Not contain substrings `..` or `:::`.\r\n* Not contain the substring `::` more than once.\r\n\r\n\r\n#### Properties\r\n\r\n* `kind` --- one of `context`, `service`, `entity`, `type`, `action`, `function`, or `annotation`\r\n* `type` --- an optional base type that this definition is derived from\r\n* [`elements`][elements] --- optional dictionary of [_elements_][elements] in case of structured types\r\n\r\nProperty `kind` is always omitted for [elements][] and can be omitted for top-level [type definitions](#type-definitions). These examples are semantically equivalent:\r\n\r\n```js\r\nFoo1 = { type:\"cds.String\" }\r\nFoo2 = { type:\"cds.String\", kind:\"type\" }\r\n```\r\n\r\n\r\n\r\n\r\n\r\n## Type Definitions\r\n\r\nCustom-defined types are entries in [`definitions`](#definitions) with an optional property `kind`=`\"type\"` and the following properties.\r\n\r\n| Property | Used for |\r\n| --- | --- |\r\n| `type` | [Scalar Types](#scalar-types), [Structured Types][struct], and [Associations](#associations) |\r\n| `elements` | [Structured Types][struct] |\r\n| `items` | [Arrayed Types][arrays] |\r\n| `enum` | [Enumeration Types][enum] |\r\n\r\n\r\n\r\n#### Example\r\n\r\n```js\r\n({definitions: {\r\n  'scalar.type': {type:\"cds.String\", length:3 },\r\n  'struct.type': {elements:{ 'foo': {type:\"cds.Integer\"}}},\r\n  'arrayed.type': {items:{type:\"cds.Integer\"}},\r\n  'enum.type':   {enum:{ 'asc':{}, 'desc':{} }}\r\n}})\r\n```\r\n\r\n#### Properties\r\n[kind]: #kind\r\n[type]: #type\r\n\r\n* `kind` --- omitted or _`\"type\"`_\r\n* `type` --- the base type, this definition is derived from\r\n* [`elements`][elements] --- optional element definitions for [_structured types_][struct].\r\n* [`items`][arrays] --- optional definition of item types for [_arrayed types_][arrays].\r\n* [`enum`][enum] --- an optional dictionary of enum members for [_enumeration types_][enum].\r\n* `value` --- a constant [literal value](#literals) or calculation expression\r\n* `default` --- a default [value or expression](#literals)\r\n* `localized` _= true_ if this type was declared like _foo : localized String_\r\n* `...` --- other type-specific properties, for example, a String's `length`\r\n\r\n\r\n\r\n### Scalar Types\r\n[scalar]: #scalar-types\r\n\r\nScalar types always have property `type` specified, plus optional type-specific parameter properties.\r\n\r\n```js\r\n({definitions:{\r\n  'scalar.type': {type:\"cds.String\", length:3 },\r\n}})\r\n```\r\n\r\nSee the [CDL reference docs]({{cap}}/cds/types) for an overview of CDS' built-in types.\r\n\r\nWhile in [CDS sources][CDL] you can refer to these types without prefix, they always have to be specified with their **fully qualified names in CSN**, for example:\r\n\r\n```js\r\n({definitions: {\r\n  'Foo': { type:\"cds.Integer\" },\r\n  'Bar': { type:\"cds.Decimal\", precision:11, scale:3 },\r\n}})\r\n```\r\n\r\n\r\n### Structured Types\r\n\r\n[struct]: #structured-types\r\n[elements]: #structured-types\r\n[Structured Types]: #structured-types\r\n\r\nStructured types are signified by the presence of an `elements` property. The value of `elements` is a dictionary of `elements`. The name is the local name of the element and the values in turn are [Type Definitions](#type-definitions).\r\n\r\nThe optional property `includes` contains a list of fully qualified entity-, aspect-, or type-names. Elements, actions, and annotations from those definitions are then copied into the structured type.\r\n\r\n```js\r\n({definitions:{\r\n  'structured.type': {elements:{\r\n    'foo': {type:\"cds.Integer\"},\r\n    'bar': {type:\"cds.String\"}\r\n  }}\r\n}})\r\n```\r\n\r\n\r\n### Arrayed Types\r\n[arrays]: #arrayed-types\r\n\r\nArrayed types are signified by the presence of a property `items`. The value of which is in turn a [type definition](#type-definitions) that specifies the arrayed items' type.\r\n\r\n```js\r\n({definitions:{\r\n  'arrayed.type': {items:{type:\"cds.Integer\"}}\r\n}})\r\n```\r\n\r\n\r\n### Enumeration Types\r\n[enum]: #enumeration-types\r\n\r\nThe `enum` property is a dictionary of enum member elements with the name being the enum symbol and the value being a [CQN literal value expression]({{cxn}}#literal-values). The literal expression optionally specifies a constant `val` as a [literal](#literals) plus optional annotations. An enumeration type can specify an explicit `type` (for example, _Decimal_) but can also omit it and refer from given enumeration values, or _String_ as default.\r\n\r\n```js\r\n({definitions:{\r\n  'Gender': {enum:{\r\n    'male':{},\r\n    'female':{}\r\n  }},\r\n  'Status': {enum:{\r\n    'submitted': {val:1},\r\n    'fulfilled': {val:2}\r\n  }},\r\n  'Rating': {type:\"cds.Decimal\", enum:{\r\n    'low':    {val:0},\r\n    'medium': {val:50},\r\n    'high':   {val:100}\r\n  }}\r\n}})\r\n```\r\n\r\n\r\n\r\n\r\n\r\n## Entity Definitions\r\n[entities]: #entity-definitions\r\n[entity]: #entity-definitions\r\n\r\nEntities are [structured types][struct] with **_kind_** =`'entity'`. In addition, one or more elements usually have property `key` set to true, to flag the entity's primary key.\r\n\r\n#### Example\r\n\r\n```js\r\n({definitions:{\r\n  'Products': {kind:\"entity\", elements:{\r\n    'ID':     {type:\"cds.Integer\", key:true},\r\n    'title':  {type:\"cds.String\", notNull:true},\r\n    'price':  {type:\"Amount\", virtual:true},\r\n  }}\r\n}})\r\n```\r\n\r\n#### Properties\r\n\r\n* `kind` --- is always _`\"entity\"`_\r\n* `elements` --- as in [Structured Types], optionally equipped with one or more of these boolean properties:\r\n  * `key` --- signifies that the element is (part of) the primary key\r\n  * `virtual` --- has this element ignored in generic persistence mapping\r\n  * `notNull` --- the _not null_ constraint as in SQL\r\n* `includes` --- as in [Structured Types]\r\n\r\n\r\n\r\n### View Definitions\r\n[views]: #view-definitions\r\n[view]: #view-definitions\r\n\r\nViews are entities defined as projections on underlying entities. In CSN, views are signified by the presence of property `query`, which captures the projection as a [CQN] expression.\r\n\r\n\r\n#### Example\r\n\r\n```js\r\n({definitions:{\r\n  'Foo': { kind:\"entity\", query: {\r\n    SELECT:{\r\n      from: {ref:['Bar']},\r\n      columns: [ {ref:['title']}, {ref:['price']} ]\r\n    }\r\n  }}\r\n}})\r\n```\r\n\r\n#### Properties\r\n\r\n* `kind` --- mandatory; always _`\"entity\"`_\r\n* `query` --- the parsed query in [CQN] format\r\n* `elements` --- optional [elements signature](#views-with-declared-signatures), omitted and inferred\r\n* `params` --- optional [parameters](#views-with-parameters)\r\n\r\n\r\n\r\n### Views with Declared Signatures\r\n\r\nViews with declared signatures have the additional property `elements` filled in as in [entities]:\r\n\r\n```js\r\n({definitions:{\r\n  'with.declared.signature': {kind:\"entity\",\r\n    elements: {\r\n      'title': {type:\"cds.String\"},\r\n      'price': {type:\"Amount\"}\r\n    },\r\n    query: { SELECT:{...} },\r\n  }\r\n}})\r\n```\r\n\r\n\r\n### Views with Parameters\r\n\r\nViews with parameters have an additional property `params` --- an optional dictionary of parameter [type definitions](#type-definitions):\r\n\r\n```js\r\n({definitions:{\r\n  'with.params': {kind:\"entity\",\r\n    params: { 'ID': { type: 'cds.Integer' } },\r\n    query: { SELECT:{...} },\r\n  }\r\n}})\r\n```\r\n\r\n\r\n\r\n\r\n\r\n## Associations\r\n\r\nAssociations are like [scalar type definitions][scalar] with `type` being `cds.Association` or `cds.Composition` plus additional properties specifying the association's `target` and optional information like `on` conditions or foreign `keys`.\r\n\r\n### Basic to-one Associations\r\n\r\nThe basic form of associations is *to-one* associations to a designated target:\r\n\r\n```js\r\n({definitions:{\r\n  'Books': { kind:\"entity\", elements:{\r\n    'author': { type:\"cds.Association\", target:\"Authors\" },\r\n  }},\r\n  //> an association type-def\r\n  'Currency': { type:\"cds.Association\", target:\"Currencies\" },\r\n}})\r\n```\r\n\r\n\r\n\r\n### Associations with specified `cardinality`\r\n\r\nAdd property `cardinality` to explicitly specify a *to-one* or *to-many* relationship:\r\n\r\n```js\r\n({definitions:{\r\n  'Authors': { kind:\"entity\", elements:{\r\n    'books': { type:\"cds.Association\", target:\"Books\", cardinality:{max:\"*\"} },\r\n  }},\r\n}})\r\n```\r\n\r\nProperty `cardinality` is an object `{src?,min?,max}`with...\r\n\r\n* `src` set to `1` give a hint to database optimizers, that a source entity always exists\r\n* `min` specifying the target's minimum cardinality --- default: 0\r\n* `max` specifying the target's maximum cardinality --- default: 1\r\n\r\nIn summary, the default cardinality is _[0..1,0..1]_, which means *to-one*.\r\n\r\n### Associations with Specified `on` Condition\r\n\r\nSo-called *unmanaged* associations have an explicitly specified `on` condition:\r\n\r\n```js\r\n({definitions:{\r\n  'Authors': { kind:\"entity\", elements:{\r\n    'books': { type:\"cds.Association\", target:\"Books\", cardinality{max:\"*\"},\r\n      on: [{ref:['books', 'author']}, '=', {ref:['$self']}]\r\n    },\r\n  }}\r\n }})\r\n```\r\n\r\n\r\n\r\n### Associations with specified `keys`\r\n\r\nManaged to-one associations automatically use the target's designated primary `key` elements. You can overrule this by explicitly specifying alternative target properties to be used in the `keys` property:\r\n\r\n```js\r\n({definitions:{\r\n  'Books': {kind:\"entity\", elements:{\r\n    'genre': {type:\"cds.Association\", target:\"Genres\", keys:[\r\n      {ref:[\"category\"], as:\"cat\"},\r\n      {ref:[\"name\"]},\r\n    ]},\r\n  }},\r\n}})\r\n```\r\n\r\nProperty `keys` has the format and mechanisms of [CQN projections]({{cqn}}#select).\r\n\r\n\r\n\r\n## Annotations\r\n\r\nAnnotations are represented as properties, prefixed with `@`.\r\nThis format applies to type/entity-level annotations as well as to element-level ones.\r\n\r\n#### Example\r\n\r\n```js\r\n({definitions:{\r\n  'Employees': {kind:\"entity\",\r\n    '@title':\"Mitarbeiter\",\r\n    '@readonly':true,\r\n    elements:{\r\n      'firstname': {type:\"cds.String\", '@title':\"Vorname\"},\r\n      'surname':   {type:\"cds.String\", '@title':\"Nachname\"},\r\n    }\r\n  },\r\n}})\r\n```\r\n\r\nAnnotations are used to add custom information to definitions, the prefixed `@` acts as a protection against conflicts with built-in/standard properties. They’re flat lists of key-value pairs, with keys being fully qualified property names and values being represented as introduced in the section [Literals and Expressions](#literals).\r\n\r\n\r\n\r\n\r\n\r\n## Aspects\r\n\r\nIn parsed-only models, the top-level property `extensions` holds an array of unapplied extensions or annotations (&rarr; see also [Aspects in CDL]({{cdl}}#aspects)). The entries are of this form:\r\n\r\n```js\r\next = { extend|annotate: <name>, <property>: <value>, … }\r\n```\r\n\r\nwith:\r\n\r\n- `extend` or `annotate` referring to the definition to be extended or annotated\r\n- `<property>` being the property that should be extended, for example, `elements` if an entity\r\n  should be extended with further elements\r\n\r\n\r\n\r\n### Extend with \\<named aspect\\>\r\n\r\nThe most basic form allows to express an extension of a named definition with another named definition (&rarr; see [Named Aspects]({{cdl}}#aspect)):\r\n\r\n```js\r\ncsn = { extensions:[\r\n  { extend:\"TargetDefinition\", includes:[\"NamedAspect\"]}\r\n]}\r\n```\r\n\r\n\r\n\r\n\r\n### Extend with \\<anonymous aspect\\>\r\n\r\nThe form `{ extend:<target>, <property>: <value>, … }` allows to add elements to an existing [struct] definition as well as to add or override annotations of the target definition:\r\n\r\n```js\r\ncsn = { extensions:[\r\n\r\n  // extend Foo with @foo { ..., bar: String; }\r\n  {\r\n    extend: \"Foo\",\r\n    '@foo': true,\r\n    elements: {\r\n      // adds a new element 'bar'\r\n      bar: { type: \"cds.String\", '@bar': true },\r\n    }\r\n  },\r\n\r\n]}\r\n```\r\n\r\n\r\n### annotate with \\<anonymous aspect\\>\r\n\r\nThe form `{ annotate:<target>, with:{...} }` allows to add or override annotations of the target definition as well as those of nested elements:\r\n\r\n```js\r\ncsn = {extensions:[\r\n\r\n  // annotate Foo with @foo;\r\n  { annotate:\"Foo\", '@foo':true },\r\n\r\n  // annotate Foo with @foo { boo @boo }\r\n  { annotate:\"Foo\", '@foo':true, elements: {\r\n    // annotates existing element 'boo'\r\n    boo: {'@boo':true },\r\n  }},\r\n\r\n]}\r\n```\r\n\r\n\r\n\r\n## Services\r\n\r\nServices are definitions with _kind =`'service'`_:\r\n\r\n```js\r\n({definitions:{\r\n  'MyOrders': {kind:\"service\"}\r\n}})\r\n```\r\n\r\n\r\n\r\n### Actions / Functions\r\n{: .h2}\r\n\r\nService definitions (for _unbound_ actions/functions) as well as entity definitions\r\n(for _bound_ actions/functions) can have an additional property `actions`.\r\nThe keys of these `actions` are the (local) names of actions/functions.\r\n\r\n\r\n#### Example\r\n\r\n```js\r\n({definitions:{\r\n  'MyOrders': {kind:\"service\", actions:{\r\n    'cancelOrder': {kind:\"action\",\r\n      params:{\r\n        'orderID': {type:\"cds.Integer\"},\r\n        'reason':  {type:\"cds.String\"},\r\n      },\r\n      returns: {elements:{\r\n        'ack': {enum:{ 'succeeded':{}, 'failed':{} }},\r\n        'msg': {type:\"cds.String\"},\r\n      }}\r\n    }\r\n  }}\r\n}})\r\n```\r\n\r\n#### Properties\r\n\r\n* `kind` --- either `'action'` or `'function'` as in _OData_\r\n* `params` --- a dictionary with the values being\r\n  [Type Definitions](#type-definitions)\r\n* `returns` --- a [Type Definition](#type-definitions)\r\n  describing the response\r\n\r\n> The definition of the response can be a reference to a declared type or the inline definition of a new (struct) type.\r\n\r\n\r\n\r\n\r\n\r\n## Imports\r\n\r\nThe `requires` property lists other models to import definitions from. \r\n\r\n#### Example\r\n\r\n```js\r\n({\r\n  requires:[ '@sap/cds/common', './db/schema' ],\r\n  ...\r\n})\r\n```\r\n\r\nAs in Node.js the filenames are either absolute module names or relative \r\nfilenames, starting with `./` or `../`.\r\n\r\n## i18n\r\nA CSN may optionally contain a top-level `i18n` property, which can contain translated texts. The expected structure is as follows:\r\n\r\n```js\r\n({\r\n  \"i18n\": {\r\n    \"language-key\": {\r\n      \"text-key\": \"some string\"\r\n    }\r\n  }\r\n})\r\n```\r\n\r\nThis data must be written and handled by the application, there’s no out-of-the-box support for this by CAP.\r\n"},{"name":"21-CQL.md","content":"---\r\nlayout: cds-ref\r\nshorty: Query Language\r\nsynopsis: >\r\n  Documents the CDS Query Language (aka CQL) which is an extension of the standard SQL SELECT statement.\r\npermalink: cds/cql\r\nstatus: released\r\nuacp: Used as link target from Help Portal at https://help.sap.com/viewer/65de2977205c403bbc107264b8eccf4b/Cloud/en-US/855e00bd559742a3b8276fbed4af1008.html\r\n---\r\n\r\n\r\n# Query Language (CQL)\r\n\r\nCDS QL is based on standard SQL, which it enhances by...\r\n\r\n{% include _toc levels=\"2,3\" %}\r\n{% include links.md %}\r\n\r\n## Postfix Projections\r\n\r\nCQL allows to put projections, that means, the `SELECT` clause, behind the `FROM` clause enclosed in curly braces. For example, the following are equivalent:\r\n\r\n```sql\r\nSELECT name, address.street from Authors;\r\n```\r\n```sql\r\nSELECT from Authors { name, address.street };\r\n```\r\n\r\n\r\n### Nested Expands\r\n{: .impl.concept}\r\n\r\nPostfix projections can be appended to any column referring to a struct element or an association and hence be nested.\r\nThis allows **expand** results along associations and hence read deeply structured documents:\r\n\r\n```sql\r\nSELECT from Authors {\r\n   name, address { street, town { name, country }}\r\n};\r\n```\r\n\r\nThis actually executes three correlated queries to authors, addresses, and towns and returns a structured result set like that:\r\n\r\n```js\r\nresults = [\r\n  {\r\n    name: 'Victor Hugo',\r\n    address: {\r\n      street: '6 Place des Vosges', town: {\r\n        name: 'Paris',\r\n        country: 'France'\r\n      }\r\n    }\r\n  }, {\r\n    name: 'Emily Brontë', ...\r\n  }, ...\r\n]\r\n```\r\n\r\n> This is rather a feature tailored to NoSQL databases and has no equivalent in standard SQL as it requires structured result sets. Some SQL vendors allow things like that with non-scalar subqueries in SELECT clauses.\r\n\r\n\r\n### Nested Inlines\r\n{: .impl.concept}\r\n\r\nPut a **`\".\"`** before the opening brace to **inline** the target elements and avoid writing lengthy lists of paths to read several elements from the same target. For example:\r\n\r\n```sql\r\nSELECT from Authors {\r\n   name, address.{ street, town.{ name, country }}\r\n};\r\n```\r\n\r\n... is equivalent to:\r\n\r\n```sql\r\nSELECT from Authors {\r\n  name,\r\n  address.street,\r\n  address.town.name,\r\n  address.town.country\r\n};\r\n```\r\n\r\n\r\n### Smart `*` Selector\r\n\r\nWithin postfix projections, the `*` operator queries are handled slightly different than in plain SQL select clauses.\r\n\r\n#### Example:\r\n\r\n```swift\r\nSELECT from Books { *, author.name as author }\r\n```\r\n\r\n Queries like in our example, would result in duplicate element effects for `author` in SQL, while in CQL explicitly defined columns following a `*` replaces equally named columns inferred before.\r\n\r\n\r\n\r\n## Path Expressions\r\n\r\nUse path expressions to navigate along associations and/or struct elements in any of the SQL clauses as follows:\r\n\r\n* In `from` clauses:\r\n\r\n```sql\r\nSELECT from Authors[name='Emily Brontë'].books;\r\nSELECT from Books:authors.towns;\r\n```\r\n\r\n* In `select` clauses:\r\n\r\n```sql\r\nSELECT title, author.name from Books;\r\nSELECT *, author.address.town.name from Books;\r\n\r\n```\r\n* In `where` clauses:\r\n\r\n```sql\r\nSELECT from Books where author.name='Emily Brontë';\r\n\r\n```\r\n* The same is valid for `group by`, `having`, and `order by`.\r\n\r\n\r\n### Path Expressions in `from` Clauses\r\n\r\nPath expressions in from clauses allow to fetch only those entries from a target entity, which are associated to a parent entity. They unfold to _SEMI JOINS_ in plain SQL queries. For example, the previous mentioned queries would unfold to the following plain SQL counterparts:\r\n\r\n```sql\r\nSELECT * from Books WHERE EXISTS (\r\n  SELECT 1 from Authors WHERE Authors.ID = Books.author_ID\r\n    AND Authors.name='Emily Brontë'\r\n);\r\n```\r\n```sql\r\nSELECT * from Towns WHERE EXISTS (\r\n  SELECT 1 from Authors WHERE Authors.town_ID = Towns.ID AND EXISTS (\r\n    SELECT 1 from Books WHERE Books.author_ID = Authors.ID\r\n  )\r\n);\r\n```\r\n\r\n### Path Expressions in All Other Clauses\r\n\r\nPath expressions in all other clauses are very much like standard SQL's column expressions with table aliases as single prefixes. CQL essentially extends the standard behavior to paths with multiple prefixes, each resolving to a table alias from a corresponding `LEFT OUTER JOIN`. For example, the path expressions in the previous mentioned queries would unfold to the following plain SQL queries:\r\n\r\n```sql\r\nSELECT Books.title, author.name from Books\r\nLEFT JOIN Authors author ON author.ID = Books.author_ID;\r\n```\r\n```sql\r\nSELECT Books.*, author_address_town.name from Books\r\nLEFT JOIN Authors author ON author.ID = Books.author_ID\r\nLEFT JOIN Addresses author_address ON author_address.ID = author.address_ID\r\nLEFT JOIN Towns author_address_town ON author_address_town.ID = author_address.town_ID;\r\n```\r\n```sql\r\nSELECT Books.* from Books\r\nLEFT JOIN Authors author ON author.ID = Books.author_ID\r\nWHERE author.name='Emily Brontë'\r\n```\r\n\r\nAll column references get qualified &rarr; in contrast to plain SQL joins there’s no risk of ambiguous or conflicting column names.\r\n{:.tip}\r\n\r\n### With Infix Filters\r\n\r\nAppend infix filters to associations in path expressions to narrow the resulting joins. For example:\r\n\r\n```sql\r\nSELECT books[genre='Mystery'].title from Authors\r\n WHERE name='Agatha Christie'\r\n```\r\n\r\n... unfolds to:\r\n```sql\r\nSELECT books.title from Authors\r\nLEFT JOIN Books books ON ( books.author_ID = Authors.ID )\r\n  AND ( books.genre = 'Mystery' )  --> from Infix Filter\r\nWHERE Authors.name='Agatha Christie';\r\n```\r\n\r\n### Exists Predicate\r\n{:.impl.concept}\r\n\r\nUse a filtered path expression to test if any element of the associated collection matches the given filter:\r\n\r\n```sql\r\nSELECT FROM Authors {name} WHERE EXISTS books[year = 2000]\r\n```\r\n\r\n...unfolds to:\r\n```sql\r\nSELECT name\r\nFROM Authors a\r\nWHERE EXISTS (\r\n        SELECT 1\r\n        FROM Books b\r\n        WHERE b.author_id = a.id\r\n            AND b.year = 2000\r\n    )\r\n```\r\n\r\n## CDL-Style Casts\r\n\r\nInstead of SQL-style type casts you can alternatively use [CDL]-style casts, that means, as in the element of an entity definition.\r\nFor example, the following statements are equivalent:\r\n\r\n```sql\r\nSELECT cast (foo+1 as Decimal) as bar from Foo;  -- standard SQL\r\nSELECT from Foo { foo+1 as bar : Decimal };      -- CDL-style\r\n```\r\n[learn more about CDL type definitions]({{cdl}}#types){:.learn-more}\r\n\r\nSQL-style type casts aren’t yet supported.\r\n{:.tip}\r\n\r\n## Excluding Clause\r\n\r\nUse the `excluding` clause in combination with `SELECT *` to select all elements except for the ones listed in the exclude list.\r\n\r\n```swift\r\nSELECT from Books { * } excluding { author }\r\n```\r\n\r\nThe effect is about **late materialization** of signatures and staying open to late extensions.\r\nFor example assume the following definitions:\r\n\r\n```swift\r\nentity Foo { foo : String; bar : String; car : String; }\r\nentity Bar as SELECT from Foo excluding { bar };\r\nentity Boo as SELECT from Foo { foo, car };\r\n```\r\n\r\nA `SELECT * from Bar` would result into the same as a query of `Boo`:\r\n\r\n```sql\r\nSELECT * from Bar --> { foo, car }\r\nSELECT * from Boo --> { foo, car }\r\n```\r\n\r\nNow, assume a consumer of that package extends the definitions as follows:\r\n\r\n```swift\r\nextend Foo with { boo : String; }\r\n```\r\n\r\nWith that, queries on `Bar` and `Boo` would return different results:\r\n\r\n```sql\r\nSELECT * from Bar --> { foo, car, boo }\r\nSELECT * from Boo --> { foo, car }\r\n```\r\n\r\n\r\n## Query-Local Mixins\r\n\r\nUse the `mixin...into` clause to logically add unmanaged associations to the source of the query, which you can use and propagate in the query's projection. This is only supported in postfix notation.\r\n\r\n```sql\r\nSELECT from Books mixin {\r\n  localized : Association to LocalizedBooks on localized.ID = ID;\r\n} into {\r\n  ID, localized.title\r\n};\r\n```\r\n"},{"name":"31-Types.md","content":"---\r\nlayout: cds-ref\r\nshorty: Built-in Types\r\nsynopsis: >\r\n  Find here a brief overview of the predefined types shipped with CDS.\r\npermalink: cds/types\r\nstatus: released\r\n---\r\n\r\n\r\n# Built-in Types\r\n\r\n{% include links.md %}\r\n\r\nThe following built-in types are provided:\r\n\r\n\r\n| CDS Type | Arguments / Remarks | Example Value | SQL <sup>(5)</sup> |\r\n| --- | --- | ---  | --- |\r\n| `UUID` | an opaque 36-characters string <sup>(1)</sup> | `'be071623-8699-4106-b6fa-8e3cb04c261e'`| _NVARCHAR(36)_  |\r\n| `Boolean` | | `true` | _BOOLEAN_  |\r\n| `Integer` | | `1337` | _INTEGER_  |\r\n| `Integer64` | | `1337` | _BIGINT_  |\r\n| `Decimal` | ( `precision`, `scale` ) <sup>(2)</sup> | `15.2` | _DECIMAL_  |\r\n| `Double` | | `15.2` | _DOUBLE_  |\r\n| `Date` | | `'2021-06-27'` | _DATE_  |\r\n| `Time` | | `'07:59:59'` | _TIME_  |\r\n| `DateTime` | _sec_ precision | `'2021-06-27T14:52:23Z'` | _TIMESTAMP_  |\r\n| `Timestamp` | 0.1 _µs_ precision <sup>(3)</sup> | `'2021-06-27T14:52:23.123Z'` |  _TIMESTAMP_  |\r\n| `String` | ( `length` ) <sup>(4)</sup> | `'hello world'` | _NVARCHAR_  |\r\n| `Binary` | ( `length` ) <sup>(4)</sup> | |  _VARBINARY_  |\r\n| `LargeBinary` |  | | _BLOB_  |\r\n| `LargeString` |  | `'hello world'` | _NCLOB_  |\r\n\r\n\r\n### Remarks\r\n\r\n\r\n> <sup>(1)</sup> At runtime, UUIDs are treated as opaque values and are, for example, not converted to lower case on input. UUIDs generated in the application are [RFC 4122](https://tools.ietf.org/html/rfc4122)-compliant. See [Don't Interpret UUIDs!]({{cap}}/guides/domain-models#dont-interpret-uuids) for details.\r\n\r\n> <sup>(2)</sup> Arguments `precision` and `scale` are optional → if omitted a *decfloat* type is used\r\n\r\n> <sup>(3)</sup> Up to 7 digits of fractional seconds; if a data is given with higher precision truncation may occur\r\n\r\n> <sup>(4)</sup> Argument `length` is optional → use options `cds.cdsc.defaultStringLength` and `cds.cdsc.defaultBinaryLength` to control the project-specific default length used for OData and SQL backends. If not set, the global default length 5000 is used for SQL backends.\r\n\r\n> <sup>(5)</sup> Mapping to ANSI SQL types are given for comparison. Note though, that you need to have the specification of your target database in mind when considering, for example, length restrictions.\r\n\r\n\r\n### See also...\r\n\r\n[**Mapping to OData EDM types**]({{cap}}/advanced/odata#type-mapping){:.learn-more}\r\n\r\n[**HANA-native Data Types**]({{cap}}/advanced/hana#hana-types){:.learn-more}"},{"name":"33-common.cds.md","content":"---\r\nlayout: cds-ref\r\nshorty: \\@sap/cds/common\r\nsynopsis: >\r\n  Introduces _@sap/cds/common_ a prebuilt CDS model shipped with `@sap/cds` that provides common types and aspects.\r\npermalink: cds/common\r\nstatus: released\r\nuacp: Used as link target from Help Portal at https://help.sap.com/viewer/65de2977205c403bbc107264b8eccf4b/Cloud/en-US/855e00bd559742a3b8276fbed4af1008.html\r\n---\r\n\r\n# Common Types & Aspects\r\n_@sap/cds/common_\r\n{:.subtitle}\r\n\r\nCDS ships with a prebuilt model _@sap/cds/common_ that provides common types and aspects.\r\n\r\n#### Content\r\n{% include _toc levels=\"2,3\" %}\r\n{% include links.md %}\r\n\r\n[ISO 3166]: https://en.wikipedia.org/wiki/ISO_3166\r\n[ISO 3166-1]: https://en.wikipedia.org/wiki/ISO_3166-1\r\n[ISO 3166-2]: https://en.wikipedia.org/wiki/ISO_3166-2\r\n[ISO 3166-3]: https://en.wikipedia.org/wiki/ISO_3166-3\r\n[ISO 4217]: https://en.wikipedia.org/wiki/ISO_4217\r\n[ISO/IEC 15897]: https://en.wikipedia.org/wiki/ISO/IEC_15897\r\n\r\n\r\n## Why Use _@sap/cds/common_?\r\n\r\nIt’s recommended that all applications use the common types and aspects provided through _@sap/cds/common_ to benefit from these features:\r\n\r\n* **Concise** and **comprehensible** models &rarr; see also [Conceptual Modeling](../guides/domain-models#conceptual-modeling)\r\n* **Foster interoperability** between all applications\r\n* **Proven best practices** captured from real applications\r\n* **Streamlined** data models with **minimal entry barriers**\r\n* **Optimized** implementations and runtime performance\r\n* **Automatic** support for [localized] code lists and value helps\r\n* **Extensibility** using [Aspects](../guides/domain-models#aspects)\r\n* **Verticalization** through third-party extension packages\r\n\r\nFor example, usage is as simple as indicated in the following sample:\r\n\r\n```swift\r\nusing { Country } from '@sap/cds/common';\r\nentity Addresses {\r\n  street  : String;\r\n  town    : String;\r\n  country : Country; //> using reuse type\r\n}\r\n```\r\n\r\n### Outcome = Optimized Best Practice\r\n\r\nThe final outcomes in terms of modeling patterns, persistence structures, and implementations is essentially the same as with native means, if you would have collected design experiences from prior solutions, such as we did.\r\n\r\nAll the common reuse features of _@sap/cds/common_ are provided only through this ~100 line .cds model. Additional runtime support isn't required. _@sap/cds/common_ merely uses basic CDS modeling features as well as generic features like [localized data] and [temporal data] (which only need minimal runtime support with minimal overhead).\r\n{:.tip}\r\n\r\nIn effect, the results are **straightforward**, capturing **best practices** we learned from real business applications, with **minimal footprint**, **optimized performance**, and **maximized adaptability** and **extensibility**.\r\n\r\n\r\n## Common Reuse Aspects\r\n\r\n_@sap/cds/common_ defines the following [aspects] for use in your entity definitions. They give you shortcuts, for concise and comprehensible models, interoperability and out-of-the-box runtime features connected to them.\r\n\r\n\r\n### Aspect `cuid`\r\n\r\nUse `cuid` as a convenient shortcut, to add canonical, universally unique primary keys to your entity definitions. These examples are equivalent:\r\n\r\n```swift\r\nentity Foo : cuid {...}\r\n```\r\n\r\n\r\n```swift\r\nentity Foo {\r\n  key ID : UUID;\r\n  ...\r\n}\r\n```\r\n\r\n> The service provider runtimes automatically fill in UUID-typed keys like these with auto-generated UUIDs.\r\n\r\n[Learn more about **canonical keys** and **UUIDs**.](../guides/domain-models#use-canonic-primary-keys){: .learn-more}\r\n\r\n\r\n### Aspect `managed`\r\n\r\nUse `managed`, to add four elements to capture _created by/at_ and latest _modified by/at_ management information for records. The following examples are equivalent-\r\n\r\n```swift\r\nentity Foo : managed {...}\r\n```\r\n\r\n\r\n```swift\r\nentity Foo {\r\n  createdAt  : Timestamp @cds.on.insert : $now;\r\n  createdBy  : User      @cds.on.insert : $user;\r\n  modifiedAt : Timestamp @cds.on.insert : $now  @cds.on.update : $now;\r\n  modifiedBy : User      @cds.on.insert : $user @cds.on.update : $user;\r\n  ...\r\n}\r\n```\r\n\r\n`modifiedAt` and `modifiedBy` are set whenever the respective row was modified, that means, also during `CREATE` operations.\r\n{:.tip}\r\n\r\nThe annotations `@cds.on.insert/update` are handled in generic service providers so to fill-in those fields automatically.\r\n\r\n[Learn more about **generic service features**.](../guides/providing-services#managed-data){: .learn-more}\r\n\r\n\r\n### Aspect `temporal`\r\n\r\nThis aspect basically adds two canonical elements, `validFrom` and `validTo` to an entity. It also adds a tag annotation that connects the CDS compiler's and runtime's built-in support for _[Temporal Data]_. This built-in support covers handling date-effective records and time slices, including time travel. All you have to do is, add the temporal aspect to respective entities as follows:\r\n\r\n```swift\r\nentity Contract : temporal {...}\r\n```\r\n\r\n[Learn more about **temporal data**.][temporal data]{: .learn-more}\r\n\r\n\r\n## Common Reuse Types\r\n{:#code-types}\r\n\r\n_@sap/cds/common_ provides predefined easy-to-use types for _Countries_, _Currencies_, and _Languages_. Use these in all applications to foster interoperability.\r\n\r\n### Type `Country`\r\n[`Country`]: #country\r\n\r\nThe reuse type `Country` is defined in _@sap/cds/common_ as a simple managed [Association] to the [code list](#code-lists) for countries as follows:\r\n\r\n```swift\r\ntype Country : Association to sap.common.Countries;\r\n```\r\n\r\nHere's an example of how you would use that reuse type:\r\n\r\n{% include _code sample='using-country-type.cds' %}\r\n\r\nThe [code lists](#code-lists) define a key element `code`, which results in a foreign key column `country_code` in your SQL table for Addresses. For example:\r\n\r\n{% include _code sample='using-country-type.sql' %}\r\n\r\n[Learn more about **managed associations**.][Associations]{: .learn-more}\r\n\r\n\r\n### Type `Currency`\r\n\r\n```swift\r\ntype Currency : Association to sap.common.Currencies;\r\n```\r\n\r\n[It’s the same as for `Country`.](#type-country){: .learn-more}\r\n\r\n### Type `Language`\r\n\r\n```swift\r\ntype Language : Association to sap.common.Languages;\r\n```\r\n\r\n[It’s the same as for `Country`.](#type-country){: .learn-more}\r\n\r\n\r\n## Common Code Lists\r\n{: #code-lists}\r\n\r\nAs seen in the previous section, the reuse types `Country`, `Currency`, and `Language` are defined as associations to respective code list entities. They act as code list tables for respective elements in your domain model.\r\n\r\n> You rarely have to refer to the code lists in consuming models, but always only do so transitively by using the corresponding reuse types [as shown above](#code-types).\r\n\r\n\r\n### Aspect `sap.common.CodeList`\r\n\r\nThis is the base definition for the three code list entities in _@sap/cds/common_. It can also be used for your own code lists.\r\n\r\n```swift\r\naspect sap.common.CodeList {\r\n  name  : localized String(111);\r\n  descr : localized String(1111);\r\n}\r\n```\r\n[Learn more about **localized** keyword.][localized]{: .learn-more}\r\n\r\n\r\n### Entity `sap.common.Countries`\r\n\r\nThe code list entity for countries is meant to be used with **[ISO 3166-1] two-letter alpha codes** as primary keys. For example, `'GB'` for the United Kingdom. Nevertheless, it's defined as `String(3)` to allow you to fill in three-letter codes, if needed.\r\n\r\n```swift\r\nentity sap.common.Countries : CodeList {\r\n  key code : String(3); //> ISO 3166-1 alpha-2 codes (or alpha-3)\r\n}\r\n```\r\n\r\n\r\n### Entity `sap.common.Currencies`\r\n\r\nThe code list entity for currencies is meant to be used with **[ISO 4217] three-letter alpha codes** as primary keys, for example, `'USD'` for US Dollar. In addition, it provides an element to hold common currency symbols.\r\n\r\n```swift\r\nentity sap.common.Currencies : CodeList {\r\n  key code : String(3); //> ISO 4217 alpha-3 codes\r\n  symbol : String(2); //> for example, $, €, £, ₪, ...\r\n}\r\n```\r\n\r\n\r\n### Entity `sap.common.Languages`\r\n\r\nThe code list entity for countries is meant to be used with POSIX locales as defined in **[ISO/IEC 15897]** as primary keys. For example, `'en_GB'` for British English.\r\n\r\n```swift\r\nentity sap.common.Languages : CodeList {\r\n  key code : String(5); //> for example, en_GB\r\n}\r\n```\r\n[Learn more on **normalized locales**.](../guides/i18n#normalized-locales){: .learn-more}\r\n\r\n\r\n### SQL Persistence\r\n\r\nThe following table definition represents the resulting SQL persistence of the countries code list:\r\n\r\n{% include _code sample='sap-common-countries.sql' label='none' %}\r\n\r\n\r\n### SQL Persistence and Localized Texts\r\n\r\nIn addition, the generic [localized data] support triggered through the `localized` keyword adds these additional tables and views to efficiently deal with translations:\r\n\r\n{% include _code sample='sap-common-countries_texts.sql' label='none' %}\r\n{% include _code sample='sap-common-countries_localized.sql' label='none' %}\r\n\r\n[Learn more about **localized data**.][localized data]{: .learn-more}\r\n\r\n\r\n### Minimalistic Design by Intent\r\n{:label=none}\r\n{: #minimalistic-design-by-intend}\r\n\r\nThe models for code lists are intentionally minimalistic to keep the entry barriers as low as possible, focusing on the bare minimum of what all applications generally need: a unique code and localizable fields for name and full name or descriptions.\r\n\r\n**ISO alpha codes** for languages, countries, and currencies were chosen because they:\r\n\r\n1. Are most common (most projects would choose that)\r\n2. Are most efficient (as these codes are also frequently displayed on UIs)\r\n3. Guarantee minimal entry barriers (bringing about 1 above)\r\n4. Guarantee best support (for example, by readable foreign keys)\r\n\r\nAssumption is that ~80% of all apps don't need more than what is already covered in this minimalistic model. Yet, in case you need more, you can easily leverage CDS standard features to adapt and extend these base models to your needs as demonstrated in the section [Adapting to your needs](#adapting-to-your-needs).\r\n\r\n\r\n## Providing Initial Data\r\n\r\nTo fill code lists with data, a business application would frequently connect to and use _[Business Configuration]_ services. This allows customers to adjust the data for code lists individually. Alternatively or in addition, you can also provide initial data for the code lists by placing CSV files in a folder called `csv` next to your data models.\r\n\r\nThe following is an example of a `csv` file to provide data for countries:\r\n\r\n{% include _code sample='db/csv/sap.common-Countries.csv' %}\r\n\r\n[Learn more about **Providing Initial Data**.](../guides/databases#providing-initial-data){: .learn-more}\r\n\r\n\r\n### Add Translated Texts\r\n\r\nIn addition, you can provide translations for the `sap.common.Countries_texts` table as follows:\r\n\r\n{% include _code sample='db/csv/sap.common-Countries_texts.csv' %}\r\n\r\n[Learn more about **Localization/i18n**.][localization]{: .learn-more}\r\n\r\n\r\n### Using Tools like Excel\r\n\r\nYou can use Excel or similar tools to maintain these files. For example, the following screenshot shows how we maintained the above two files in Numbers on a Mac:\r\n\r\n![csv in numbers](assets/csv-numbers.png)\r\n\r\n\r\n## Adapting to Your Needs\r\n\r\nAs stated, the predefined definitions are minimalistic by intent. Yet, as _@sap/cds/common_ is also just a CDS model, you can apply all the standard features provided by [CDS][CDL], especially CDS' [Aspects] to adapt, and extend these definitions to your needs.\r\n\r\nLet's look at a few examples of what could be done. You can combine these extensions in an effective model.\r\n\r\nYou can do such extensions in the models of your project. You can also collect your extensions into reuse packages and share them as common definitions with several consuming projects, similar to _@sap/cds/common_ itself.\r\n{:.tip}\r\n\r\n[Learn more about providing reuse packages.]({{cap}}/guides/reuse-and-compose){: .learn-more}\r\n\r\n\r\n### Adding Detailed Fields as of [ISO 3166-1]\r\n\r\n{% include _code sample='your-common.1.cds' %}\r\n\r\n> Value lists in SAP Fiori automatically search in the new text fields as well.\r\n\r\n\r\n### Protecting Certain Entries\r\n\r\nSome application logic might have to be hard-coded against certain entries in code lists. Therefore, these entries have to be protected against changes and removal. For example, let's assume a code list for payment methods defined as follows:\r\n\r\n```swift\r\nentity PaymentMethods : sap.common.CodeList {\r\n  code : String(11);\r\n}\r\n```\r\n\r\nLet's further assume the entires with code `Main` and `Travel` are required by implementations and hence must not be changed or removed. Have a look at a couple of solutions.\r\n\r\n\r\n#### Generic Solution\r\n{:.impl.concept}\r\n\r\nOne option is to add an [automatic validation](../guides/providing-services#input-validation) based on certain annotations. For example:\r\n\r\n```swift\r\nannotate PaymentMethods {\r\n  code @assert.nottouched: ['Main','Travel'];\r\n}\r\n```\r\n\r\nHowever, the generic logic behind this validation isn’t trivial and an implementation is pending.\r\n\r\n\r\n#### Programmatic Solution\r\n\r\nA fallback, and at the same time, the most open, and most flexible approach, is to use a custom handler to assert that. For example, in Node.js:\r\n\r\n```js\r\nsrv.on ('DELETE', 'PaymentMethods', req=>{\r\n  const entry = req.query.DELETE.where[2].val\r\n  if (['Main','Travel'].includes(entry))\r\n    return req.reject(403, 'these entries must not be deleted')\r\n})\r\n```\r\n\r\n\r\n### Using Different Foreign Keys\r\n\r\nLet's assume you prefer to have references to the latest code list entries without adjusting foreign keys. This can be achieved by adding and using numeric ISO codes for foreign keys instead of the alpha codes.\r\n\r\n{% include _code sample='your-common.2.cds' %}\r\n\r\nYou can use your own definition of `Country` instead of the one from _@sap/cds/common_ in your models as follows:\r\n\r\n{% include _code sample='using-numcodes.cds' %}\r\n\r\n\r\n### Mapping to SAP S/4HANA or ABAP Table Signatures\r\n\r\n{% include _code sample='your-common.3.cds' %}\r\n\r\nThese views are updatable on SAP HANA and many other databases. You can also use CDS to expose them through corresponding OData services in order to facilitate integration with SAP S/4HANA or older ABAP backends.\r\n\r\n\r\n## Adding Own Code Lists\r\n\r\nAs another example of adaptations, let's add support for subdivisions, that means regions, as of [ISO 3166-2] to countries.\r\n\r\n\r\n### Defining a New Code List Entity\r\n\r\n{% include _code sample='your-common.4.1.cds' %}\r\n\r\n`Regions` is a new, custom-defined code list entity defined in the same way as the predefined ones in _@sap/cds/common_. In particular, it inherits all elements and annotations from the base definition [`sap.common.CodeList`](#code-lists). For example, the `@cds.autoexpose` annotation, which provides that `Regions` is auto-exposed in any OData service that has exposed entities with associations to it. The localization of the predefined elements `name` and `descr` is also inherited.\r\n\r\n\r\n### Defining a New Reuse Type\r\n\r\nFollowing the pattern for codes in _@sap/cds/common_ a bit more, you can also define a reuse type for regions as a managed association:\r\n\r\n{% include _code sample='your-common.4.2.cds' %}\r\n\r\n\r\n### Using the New Reuse Type and Code List\r\n\r\nThis finally allows you to add respective elements, the same way you do it with predefined reuse types. These elements receive the same support from built-in generic features. For example:\r\n\r\n{% include _code sample='using-region-type.cds' %}\r\n\r\n\r\n## Code Lists with Validity\r\n\r\nEven ISO codes may change over time and you may have to react to that in your applications. For example, when Burma was renamed to Myanmar in 1989. Let's investigate strategies on how that can be updated in our code lists.\r\n\r\n\r\n### Accommodating Changes\r\n\r\nThe renaming from Burma to Myanmar in 1989, was reflected in [ISO 3166] as follows (_the alpha-4 codes as specified in [ISO 3166-3] signify entries officially deleted from [ISO 3166-1] code lists_):\r\n\r\n| Name | Alpha-2 | Alpha-3 | Alpha-4 | Numeric |\r\n| --- | --- | --- | --- | --- |\r\n| Burma | BU | BUR | BUMM | 104\t|\r\n| Myanmar | MM | MMR | | 104\t|\r\n\r\nBy default, and with the given default definitions in _@sap/cds/common_, this would have been reflected as a new entry for Myanmar and you'd have the following choices on what to do with the existing records in your data:\r\n\r\n* **(a)** adjust foreign keys for records so that it always reflects the current state\r\n* **(b)** keep foreign keys as is for cases where the old records reflect the state effective at the time they were created or valid\r\n\r\n\r\n### Exclude Outdated Entries from Pick Lists (Optional)\r\n\r\nAlthough outdated entries like the one for Burma have to remain in the code lists as targets for references from historic records in other entities, you would certainly want to exclude it from all pick lists used in UIs when entering new data. This is how you could achieve that:\r\n\r\n\r\n#### 1. Extend the Common Code List Entity\r\n\r\n```swift\r\nusing { sap.common.Countries } from '@sap/cds/common';\r\nextend Countries with { validFrom: Date; validTo: Date; }\r\n```\r\n\r\n\r\n#### 2. Fill Validity Boundaries in Code Lists:\r\n\r\n| code | name | validFrom | validTo |\r\n| --- | --- | --- | --- | --- |\r\n| BU | Burma | | 1989-06-18 |\r\n| MM | Myanmar | 1989-06-18 |\r\n\r\n\r\n#### 3. Add Custom Handlers to Narrow Queries\r\n\r\n```js\r\nsrv.before ('READ','sap_common_Countries', req => {\r\n  req.query.where ('current_date between validFrom and validTo')\r\n})\r\n```\r\n"}]},{"name":"04-Elements-Types-.md","content":"\r\n## Elements, Types\r\n{: #elements-types}\r\n\r\n<!-- TOC depthFrom:3 depthTo:3 -->\r\n\r\n- [pre-defined types](#pre-defined-types)\r\n- [custom-defined types](#custom-defined-types)\r\n- [struct elements](#struct-elements)\r\n- [enums](#enums)\r\n- [calculated fields](#calculated-fields)\r\n- [virtual elements](#virtual-elements)\r\n- [element constraints](#element-constraints)\r\n\r\n<!-- /TOC -->\r\n\r\n\r\n\r\n### pre-defined types\r\n\r\n\r\nThe following built-in types are provided.\r\nMapping to ANSI SQL types and to [_Edm._ types](http://docs.oasis-open.org/odata/odata/v4.0/errata03/os/complete/part3-csdl/odata-v4.0-errata03-os-part3-csdl-complete.html#_Toc453752517) given for comparison.\r\n\r\n| CDS Type | Arguments / Remarks | SQL | OData (v4) |\r\n| --- | --- | ---  | --- |\r\n| `UUID` | a 36-characters string | _varchar(36)_  | _Edm.Guid_ <sup>(1)</sup> |\r\n| `Boolean` | | _boolean_  | _Edm.Boolean_ |\r\n| `Integer` | | _integer_  | _Edm.Int32_ |\r\n| `Integer64` | | _bigint_  | _Edm.Int64_ |\r\n| `Decimal` | ( `precision`, `scale` ) | _decimal_  | _Edm.Decimal_ |\r\n| `DecimalFloat` | | _decimal_  | _Edm.Decimal_ |\r\n| `Double` | | _double_  | _Edm.Double_ |\r\n| `Date` | | _datetime_  | _Edm.Date_ <sup>(2)</sup> |\r\n| `Time` | | _datetime_  | _Edm.TimeOfDay_ <sup>(3)</sup> |\r\n| `DateTime` | _sec_ precision | _datetime_  | _Edm.DateTimeOffset_ <sup>(4)</sup> |\r\n| `Timestamp` | _µs_ precision | _timestamp_  | _Edm.DateTimeOffset_ <sup>(4)</sup> |\r\n| `String` | ( `length` ) | _nvarchar_  | _Edm.String_ |\r\n| `Binary` | ( `length` ) | _varbinary_  | _Edm.Binary_ |\r\n| `LargeString` |  | _NCLOB_  | _Edm.String_ |\r\n| `LargeBinary` |  | _BLOB_  | _Edm.Binary_ |\r\n\r\n> <sup>(1)</sup> Mapping can be changed with e.g. `@odata.Type='Edm.String'` <br>\r\n> <sup>(2)</sup> OData v2: _Edm.DateTime_ with `sap:display-format=\"Date\"` <br>\r\n> <sup>(3)</sup> OData v2: _Edm.Time_ <br>\r\n> <sup>(4)</sup> OData v2: _Edm.DateTime_ <br>\r\n\r\n\r\n### custom-defined types\r\n\r\nYou can declare custom types to reuse later on, e.g. for elements in entity definitions.\r\n\r\n```swift\r\ntype User : String(111);\r\ntype Amount {\r\n  value : Decimal(10,3);\r\n  currency : Currency;\r\n}\r\ntype Currency : Association to Currencies;\r\n\r\nentity Order {\r\n  buyer : User;\r\n  price : Amount;\r\n}\r\n```\r\n\r\n\r\n### struct elements\r\n\r\nElements can be specified with anonymous inline struct types.\r\n\r\n```swift\r\nentity Order {\r\n  buyer : String(111);\r\n  price {\r\n    value : Decimal(10,3);\r\n    currency : Currency;\r\n  };\r\n}\r\n```\r\n\r\n### enums\r\n\r\nYou can specify enumeration values for a type as a semicolon-delimited list of symbols.\r\nFor type `String`, declaration of actual values is optional; if omitted, the actual values then are the string counterparts of the symbols.\r\n\r\n```swift\r\ntype Gender : String enum { male; female; }\r\nentity Order {\r\n  status : Integer enum {\r\n    submitted = 1;\r\n    fulfilled = 2;\r\n    shipped = 3;\r\n    canceled = -1;\r\n  };\r\n}\r\n```\r\n\r\n### calculated fields\r\n{: .impl.concept}\r\n\r\nElements can be specified with a calculation expression in which you can refer to other\r\nelements of the same entity.\r\n\r\n```swift\r\nentity Employees {\r\n  addresses : Association of many Addresses;\r\n  homeAddress = addresses [kind='home'];\r\n}\r\n```\r\n\r\n\r\n\r\n### virtual elements\r\n\r\nAn element definiton can be prefixed with modifier keyword `virtual` to indicate that\r\nthis element shall not be added to persistent artifacts, i.e. tables or views in\r\nSQL databases. The reason to declare virtual elements is to be able to add metadata.\r\n\r\n```swift\r\nentity Employees {\r\n  ...\r\n  virtual something : String(11);\r\n}\r\n```\r\n\r\n\r\n### element constraints\r\n\r\nElement definitons can be augmented with constraints `unique` and `not null` as known from SQL.\r\n\r\n```swift\r\nentity Employees {\r\n  name : String(111) unique not null;\r\n}\r\n```\r\n\r\n> Note: `unique` is not yet available.\r\n\r\n<br>\r\n"},{"name":"05-Associations-.md","content":"\r\n## Associations\r\n\r\nAssociations capture relationships between entities. They are like forward-declared joins added to a a table definition in SQL.\r\n\r\n\r\n<!-- TOC depthFrom:3 depthTo:3 -->\r\n\r\n- [unmanaged](#unmanaged)\r\n- [managed to-one](#managed-to-one)\r\n- [managed to-many](#managed-to-many)\r\n- [managed many-to-many](#managed-many-to-many)\r\n- [with default filters](#with-default-filters)\r\n- [to parameterized views](#to-parameterized-views)\r\n- [Compositions](#compositions)\r\n- [... of inner types](#-of-inner-types)\r\n- [... of named types or facets](#-of-named-types-or-facets)\r\n\r\n<!-- /TOC -->\r\n\r\n\r\n\r\n### unmanaged\r\n\r\nUnmanaged Associations specify arbitrary join conditions in their `on` clause which refer to available foreign key elements. The association's name (`address` in the example below) is used as the alias for the to-be-joined target entity.\r\n\r\n```swift\r\nentity Employees {\r\n  address : Association to Addresses on address.ID = address_ID;\r\n  address_ID : Integer;  //> foreign key\r\n}\r\n```\r\n```swift\r\nentity Addresses {\r\n  key ID : Integer;\r\n}\r\n```\r\n\r\n\r\n### managed to-one\r\n\r\nFor to-one associations, CDS can automatically resolve and add requisite foreign key\r\nelements from the target's primary keys and implicitly add respective join conditions.\r\n\r\n```swift\r\nentity Employees {\r\n  address : Association to Addresses;\r\n}\r\n```\r\n\r\nThis example is equivalent to the [unmanaged example above](#unmanaged), with the foreign\r\nkey element `address_ID` being added automatically upon activation to a SQL database.\r\n\r\n> No foreign key constraints are added on database level.\r\n\r\n### managed to-many\r\n\r\nFor one-to-many associations specify an on condition following the canonical\r\nexpression pattern `<assoc>.<backlink> = $self` as in this example:\r\n\r\n```swift\r\nentity Employees {\r\n  key ID : Integer;\r\n  addresses : Association to many Addresses\r\n    on addresses.owner = $self;\r\n}\r\n```\r\n```swift\r\nentity Addresses {\r\n  owner : Association to Employees;  //> the backlink\r\n}\r\n```\r\n\r\n> The backlink can be any managed to-one association on the _many_ side pointing back to the _one_ side.\r\n\r\n\r\n### managed many-to-many\r\n{: .impl.concept}\r\n\r\nFor many-to-many associations, CDS can generate requisite link tables. You can use\r\nthe `via` parameter clause to add elements to link table reflecting attributed relationships\r\nor to use a pre-defined link table instead.\r\n\r\n```swift\r\nentity Employees {\r\n  addresses1 : Association to many Addresses;\r\n  addresses2 : Association to many Addresses via {\r\n    kind: String(11);\r\n  }\r\n  addresses3 : Association to many Addresses via Emp2Addr;\r\n}\r\n```\r\n\r\nFor the first two cases, [`cds.compile`](../node.js/api#cds-compile) would automatically add a link table,\r\nfor the second case with an additional element `kind` (&rarr; an _attributed relationship_).\r\nFor the third case it will use the pre-defined entity `Emp2Addr` that is expected to be\r\ndefined like that (names for `source/target` can be freely chosen):\r\n\r\n```swift\r\nentity Emp2Addr {\r\n  key source : Association to Employees;\r\n  key target : Association to Addresses;\r\n}\r\n```\r\n\r\n### with default filters\r\n{: .impl.concept}\r\n\r\nFor to-many associations you can optionally specify a default filter that will automatically\r\nbe applied to any usage of that association in queries unless another filter is specified explicitly.\r\n\r\n```swift\r\nentity Products {\r\n  localized : Association to many Product$Texts\r\n    with default filter lang=$env.user.lang;\r\n}\r\n```\r\n```swift\r\nentity Product$Texts {\r\n  key product : Association to Products;\r\n  key lang : String(3);\r\n  title : String(44);\r\n  descr : String(444);\r\n}\r\n```\r\n\r\n### to parameterized views\r\n{: .impl.concept}\r\n\r\nIf the target is a [parameterized view](#views-with-parameters), you can specify\r\ncorresponding arguments in an Association definition as follows:\r\n\r\n```swift\r\nentity Products {\r\n  assoc : Association to SomeParameterizedView (\r\n    param1: 4711,\r\n    param2: foo\r\n  );\r\n  foo : String;\r\n}\r\n```\r\n\r\n> The argument values for parameters are literals or expressions in which references\r\nare resolved within the current entity's elements.\r\n\r\n\r\n\r\n### Compositions\r\n\r\nCompositions are the same as Associations just with the additional information\r\nthat this Association represents a contained-in relationship. Compositions frequently\r\nshow up in to-many header-child scenarios.\r\n\r\n```swift\r\nentity Orders {\r\n  Items : Composition of many OrderItems on Items.order = $self;\r\n}\r\nentity OrderItems {\r\n  key order : Association to Orders;\r\n  product : ...;\r\n  quantity : ...;\r\n}\r\n```\r\n\r\n### ... of inner types\r\n{: .impl.concept}\r\n\r\nA managed syntactical sugar variant allows to write such Compositions in a\r\n(anynomous) inner child way:\r\n\r\n```swift\r\nentity Orders {\r\n  Items : Composition of many OrderItems { ... }\r\n  Items : Composition of many { ... }\r\n}\r\n```\r\nThis would automatically be unfolded to\r\nthe equivalent as shown in the [former example](#compositions).\r\nIf the inner struct is anonymous it will be constructed as\r\n`OrdersItems` in the example above.\r\n\r\n\r\n### ... of named types or facets\r\n{: .impl.concept}\r\n\r\nInstead of an inner type you can also specify a named type or facet which would\r\nbe unfolded the same way than anonymous inner types as shown above:\r\n\r\n```swift\r\nentity Products {\r\n  offeredQuantities : Composition of many Quantity;\r\n}\r\ntype Quantity {\r\n  value : Decimal(10,2);\r\n  unit : String(22);\r\n}\r\n```\r\n\r\n\r\n<br>\r\n"},{"name":"06-Annotations-.md","content":"\r\n## Annotations\r\n\r\n{% include links.md %}\r\n\r\nThis chapter describes how to add Annotations to model definitions written in CDL, focused on the common syntax options and fundamental concepts. Find additional information in the [OData Annotations] guide.\r\n\r\n\r\n<!-- TOC depthFrom:3 depthTo:3 -->\r\n\r\n- [annotation syntax](#annotation-syntax)\r\n- [annotation targets](#annotation-targets)\r\n- [annotation values](#annotation-values)\r\n- [records are syntax shortcuts](#records-are-syntax-shortcuts)\r\n\r\n<!-- /TOC -->\r\n\r\n\r\n### annotation syntax\r\n\r\nAnnotations in CDL are prefixed with an ___'@'___ sign and can be placed\r\nbefore a definition, after the defined name or at the end of simple definitions.\r\n\r\n```java\r\n@before entity Foo @inner {\r\n  @before simple @inner : String @after;\r\n  @before struct @inner { ...elements... }\r\n}\r\n```\r\n\r\nMultiple annotations can be placed in each spot separated by whitespaces or enclosed\r\nin `@(...)` and separated by comma &mdash; i.e. the following are equivalent:\r\n\r\n```swift\r\nentity Foo @(\r\n  my.annotation: foo,\r\n  another.one: 4711\r\n) { /* elements */ }\r\n```\r\n```swift\r\n@my.annotation:foo\r\n@another.one: 4711\r\nentity Foo { /* elements */ }\r\n```\r\n\r\nFor an `@inner` annotation only the syntax `@(...)` is available.\r\n\r\n### annotation targets\r\n\r\nYou can basically annotate any named thing in a CDS model, such as...\r\n\r\nContexts and services:\r\n\r\n```java\r\n@before [define] (context|service) Foo @inner { ... }\r\n```\r\n\r\nDefinitions and elements with simple types:\r\n\r\n```java\r\n@before [define] type Foo @inner : String @after;\r\n@before [key] anElement @inner : String @after;\r\n```\r\n\r\nEntities, facets and other struct types and elements thereof:\r\n\r\n```java\r\n@before [define] (entity|type|facet|annotation) Foo @inner {\r\n  @before simple @inner : String @after;\r\n  @before struct @inner { ...elements... };\r\n}\r\n```\r\n\r\nEnums\r\n\r\n```java\r\n... status : String @inner enum {\r\n  fulfilled @after;\r\n}\r\n```\r\n\r\nColumns in a view definition's query:\r\n\r\n```java\r\n... as SELECT from Foo {\r\n  @before expr as alias @inner : String,\r\n  ...\r\n}\r\n```\r\n\r\nParameters in view definitions:\r\n\r\n```java\r\n... with parameters (\r\n  @before param @inner : String @after\r\n) ...\r\n```\r\n\r\nActions/functions including their parameters and result elements:\r\n\r\n```java\r\n@before action doSomething @inner (\r\n  @before param @inner : String @after\r\n) returns {\r\n  @before result @inner : String @after;\r\n};\r\n```\r\n\r\n\r\n### annotation values\r\n\r\nValues can be literals or references.\r\nIf no value is given, the default value is `true` as for `@aFlag` below.\r\n\r\n```java\r\n@aFlag //= true, if no value is given\r\n@aBoolean: false\r\n@aString: 'foo'\r\n@anInteger: 11\r\n@aDecimal: 11.1\r\n@aSymbol: #foo\r\n@aReference: foo.bar\r\n@anArray: [ /* can contain any kind of value */ ]\r\n```\r\n\r\nAs described in the [CSN spec]({{csn}}#literals), the above annotations would compile to CSN as follows:\r\n\r\n```\r\n{\r\n  \"@aFlag\": true,\r\n  \"@aBoolean\": false,\r\n  \"@aString\": \"foo\",\r\n  \"@anInteger\": 11,\r\n  \"@aDecimal\": 11.1,\r\n  \"@aSymbol\": {\"#\":\"foo\"},\r\n  \"@aReference\": {\"=\":\"foo.bar\"},\r\n  \"@anArray\": [ ... ]\r\n}\r\n```\r\n\r\nNote: References (and expressions in general) are not checked nor resolved by CDS parsers or linkers. They are interpreted and evaluated only on consumption-specific modules. For example, in case of Fiori models, it's the _4odata_ and _2edm(x)_ processors.\r\n\r\n\r\n\r\n### records are syntax shortcuts\r\n\r\nAnnotations in cds are essentially flat lists of key-value pairs assigned to a target.\r\nThe record syntax &ndash; i.e. `{key:<value>, ...}` &ndash; is a shortcut notation that\r\napplies a common prefix to nested annotations.\r\nI.e. the following are equivalent:\r\n\r\n```java\r\n@Common.foo.bar\r\n@Common.foo.car: 'wheels'\r\n```\r\n```java\r\n@Common: { foo.bar, foo.car: 'wheels' }\r\n//> not yet implemented!\r\n```\r\n```java\r\n@Common.foo: { bar }\r\n@Common.foo.car: 'wheels'\r\n```\r\n```java\r\n@Common.foo: { bar, car: 'wheels'  }\r\n```\r\n.... and they would show up as follows in a parsed model (&rarr; see [CSN][]):\r\n\r\n```\r\n{\r\n  \"@Common.foo.bar\": true,\r\n  \"@Common.foo.car\": \"wheels\",\r\n}\r\n```\r\n\r\n### annotation propagation\r\n\r\nAnnotations are inherited from types and base types to dereived types, entities and elements as well as from elements of underlying entities in case of views.\r\n\r\nFor examples, given this view definition:\r\n\r\n````swift\r\nusing Books from './bookshop-model';\r\nentity BooksList as SELECT from Books {\r\n  ID, genre : Genre, title,\r\n  author.name as author\r\n};\r\n```\r\n\r\n* `BooksList` would inherit annotations from `Books`\r\n* `BooksList.ID` would inherit from `Books.ID`\r\n* `BooksList.author` would inherit from `Books.author.name`\r\n* `BooksList.genre` would inherit from type `Genre`\r\n\r\nThe rules are:\r\n\r\n**Rule #1** &mdash; _Entity-level properties and annotations are inherited from the **primary** underlying source entity &ndash; here `Books`._\r\n{: .rule}\r\n\r\n**Rule #2** &mdash; _Each element that can **unambiguously** be traced back to a single source element, inherits that element's properties**, ...**_\r\n{: .rule}\r\n\r\n**Rule #3** &mdash; _**...unless** an explicit **cast** in the select clause cuts them off, e.g. as for `genre` in our example above._\r\n{: .rule}\r\n\r\n<br>\r\n"},{"name":"06-Excluding-Clause-.md","content":"\r\n\r\n## Excluding Clause\r\n\r\nUse the `excluding` clause in combination with `SELECT *` to select all elements except for the ones listed in the exclude list.\r\n\r\n```swift\r\nSELECT from Books { * } excluding { author };\r\n```\r\n```swift\r\nSELECT from Books { *, author.name as author, author{*} }\r\nexcluding { author.town };\r\n```\r\n\r\nThe effect is about **late materialization** of signatures and staying open to late extensions.\r\nFor example assume the following definitions:\r\n\r\n```swift\r\nentity Foo { foo; bar; car; }\r\nentity Bar as SELECT from Foo excluding { bar }\r\nentity Boo as SELECT from Foo { foo, car }\r\n```\r\n\r\nA `SELECT * from Bar` would result into the very same as a query of `Boo`:\r\n\r\n```sql\r\nSELECT * from Bar --> { foo, car }\r\nSELECT * from Boo --> { foo, car }\r\n```\r\n\r\nNow assume a consumer of that package extends the definitions as follows:\r\n\r\n```swift\r\nextend Foo with { boo : String; }\r\n```\r\n\r\n... with that, queries on `Bar` and `Boo` would return different results:\r\n\r\n```sql\r\nSELECT * from Bar --> { foo, car, boo }\r\nSELECT * from Boo --> { foo, car }\r\n```\r\n"},{"name":"07-Aspects-.md","content":"\r\n## Aspects\r\n\r\n{% include links.md %}\r\n\r\n<!-- TOC depthFrom:3 depthTo:3 -->\r\n\r\n- [extend entity](#extend)\r\n- [extend view](#extend-view)\r\n- [extend services](#extend-services)\r\n- [annotate](#annotate)\r\n- [named aspects](#named-aspects)\r\n- [shortcut syntax `:`](#shortcut-syntax-)\r\n- [looks like inheritance](#looks-like-inheritance)\r\n\r\n<!-- /TOC -->\r\n\r\n\r\n\r\n### extend [ entity / type ]\r\n{: #extend}\r\n\r\nUse `extend` to add extension fields or to add/override metadata to existing\r\ndefinitions, e.g. annotations, as follows:\r\n\r\n```swift\r\nextend Foo with @title:'Foo' {\r\n  newField : String;\r\n  extend nestedStructField {\r\n    newField : String;\r\n    extend existingField @title:'Nested Field';\r\n  }\r\n}\r\nextend Bar with @title:'Bar'; // nothing for elements\r\n```\r\n\r\nNote: make sure you prepend the `extend` keyword to nested elements,\r\notherwise this would mean you want to add a new field with that name:\r\n\r\n\r\n\r\n### annotate\r\n\r\n\r\nUse `annotate` instead of `extend` if you only want to add/override annotations:\r\n\r\n```swift\r\nannotate Foo with @title:'Foo' {\r\n  nestedStructField {\r\n    existingField @title:'Nested Field';\r\n  }\r\n}\r\nannotate Bar with @title:'Bar';\r\n```\r\n\r\nThis example is effectively the same as the above one for [extend](#extend)\r\nwithout the extension fields added. Actually, `annotate` is just a shortcut with the\r\ndefault mode being switched to `extend`ing existing fields instead of adding\r\nnew ones.\r\n\r\n\r\n\r\n### extend view\r\n{: .impl.concept}\r\n\r\nUse `extend view` to extend the projection of a view entity to include more elements existing in the underlying entity:\r\n\r\n```swift\r\nextend view Foo with @title:'Foo' {\r\n  foo as bar @car,\r\n  <expression> as jar\r\n}\r\n```\r\n\r\nNote: Enhancing nested structs is not supported. Note also that you can use the common [`annotate`](#annotate) syntax if you only need to add/override annotations.\r\n\r\n\r\n\r\n\r\n### named aspects\r\n\r\nYou can use `extend` or `annotate` with pre-defined aspects, in order\r\nto apply the same extensions to multiple targets:\r\n\r\n```swift\r\nextend Foo with ManagedObject;\r\nextend Bar with ManagedObject;\r\n```\r\n```swift\r\naspect ManagedObject {\r\n  created { at: DateTime; by: User; }\r\n}\r\n```\r\n\r\nIn case of `extend` all nested fields in the named aspect are interpreted\r\nas being extension fields. In case of `annotate` they are interpreted as existing fields\r\nand the annotations are copied to the corresponding target elements.\r\n\r\nThe named extension can be anything, e.g. including other `types` or `entities`.\r\nYou can use `aspects` as shown in the example to declare definitions that are only\r\nmeant to be used in such extensions, not as types for elements.\r\n\r\n\r\n\r\n###  shortcut syntax `:`\r\n\r\nYou can use an inheritance-like syntax option to extend a definition with one or more [named aspects](#named-aspects)\r\nas follows:\r\n\r\n```swift\r\ndefine entity Foo : ManagedObject, AnotherAspect {\r\n  key ID : Integer;\r\n  name : String;\r\n  ...\r\n}\r\n```\r\n\r\nThis essentially is syntactical sugar and equivalent to using a sequence of [extends](#extend) as follows:\r\n\r\n```swift\r\ndefine entity Foo;\r\nextend Foo with ManagedObject;\r\nextend Foo with AnotherAspect;\r\nextend Foo with {\r\n  key ID : Integer;\r\n  name : String;\r\n  ...\r\n}\r\n```\r\n\r\nYou can apply this to any definition of an entity or a structured type.\r\n\r\n\r\n\r\n### looks like inheritance\r\n\r\nThe `:`-based syntax option described before looks very much like (multiple) inheritance\r\nand in fact has very much the same effects. Yet, as mentioned in the beginning of this\r\nchapter, it is not based on inheritance but on mixins, which are more powerful and also\r\navoid common problems like the infamous diamond shapes in type derivations.\r\n\r\nWhen combined with persistence mapping there are a few things to note, that goes down\r\nto which strategy to choose to map inheritance to e.g. relational models.\r\nFind some details in [_Aspects vs Inheritance_](../cds/aspects-inheritance).\r\n"},{"name":"07-Query-local-Mixins-.md","content":"\r\n## Query-local Mixins\r\n\r\nUse the `mixin...into` clause to logically add elements to the source of the query which you can use and propagate in the query's projection.\r\n\r\n```sql\r\nSELECT from Books mixin {\r\n  localized : Association to LocalizedBooks on localized.ID = ID;\r\n} into {\r\n  ID, localized.title\r\n};\r\n```\r\n"},{"name":"08-Services-.md","content":"\r\n## Services\r\n\r\n<!-- TOC depthFrom:3 depthTo:3 -->\r\n\r\n- [service definitions](#service-definitions)\r\n- [exposed entities](#exposed-entities)\r\n- [actions / functions](#actions--functions)\r\n- [derived services](#derived-services)\r\n- [extend services](#extend-services)\r\n\r\n<!-- /TOC -->\r\n\r\n\r\n\r\n### service definitions\r\n\r\nCDS allows to define service interfaces as collections of exposed entities enclosed\r\nin a `service` block which essentially is and acts the same a [`context`](#contexts):\r\n\r\n```swift\r\nservice SomeService {\r\n  entity SomeExposedEntity ...;\r\n  entity AnotherExposedEntity ...;\r\n}\r\n```\r\n\r\n\r\n### exposed entities\r\n\r\nThe entities exposed by a service are most frequently projections on entities\r\nfrom underlying data models.\r\nStandard view definitions, using [`as SELECT from`](#views) or\r\n[`as projection on`](#entity--as-projection-on) can be used for\r\nthat.\r\n\r\n```swift\r\nservice CatalogService {\r\n  entity Product as projection on data.Products {\r\n    *, created.at as since\r\n  } excluding { created };\r\n}\r\nservice MyOrders {\r\n  view Order as select from data.Orders { * } where buyer=$user.id;  //> $user not yet implemented!\r\n  entity Product as projection on CatalogService.Product;\r\n}\r\n```\r\n\r\n\r\n#### auto-promoted associations\r\n{: .impl.concept}\r\n> **TODO**\r\n\r\n\r\n\r\n### actions / functions\r\n\r\nService definitions may additionally specify `actions` and `functions` with a\r\ncomma-separated list of named and typed inbound parameters and an\r\noptional response type, which can be a reference to a declared type or\r\n(not yet implemented) the inline definition of a new (struct) type.\r\n\r\n```swift\r\nservice MyOrders {\r\n  entity Order ...;\r\n  // unbound actions / functions\r\n  type cancelOrderRet {\r\n    acknowledge: String enum { succeeded; failed; };\r\n    message: String;\r\n  }\r\n  action cancelOrder ( orderID:Integer, reason:String ) returns cancelOrderRet;\r\n  function countOrders() returns Integer;\r\n}\r\n```\r\n\r\n> The notion of actions and functions in CDS adopts that of [OData](http://docs.oasis-open.org/odata/odata/v4.0/os/part1-protocol/odata-v4.0-os-part1-protocol.html#_Toc372793737); actions and functions on service-level are _unbound_ ones.\r\n\r\n#### bound actions / functions\r\n\r\nActions and functions can also be bound to individual entities of a service, enclosed\r\nin an additional `actions` block as the last clause in an entity / view definition.\r\n\r\n```swift\r\nservice CatalogService {\r\n  entity Products as projection on data.Products { ... }\r\n    actions {\r\n      // bound actions/functions\r\n      action addRating (stars: Integer);\r\n      function getViewsCount() returns Integer;\r\n    }\r\n}\r\n```\r\n\r\n### derived services\r\n{: .impl.concept}\r\n\r\nYou can define abstract services and inherit from it in other service definitions\r\nas in this example:\r\n\r\n```swift\r\nabstract service ShoppingService {\r\n  abstract entity Articles {...}\r\n  entity Suppliers {...}\r\n  entity ShoppingCart {} actions {\r\n    submitOrder();\r\n  }\r\n}\r\n```\r\n\r\n```swift\r\nservice Bookshop : ShoppingService {\r\n  entity Books : ShoppingService.Articles {\r\n    author : Association to Authors;\r\n  }\r\n  entity Authors {...}\r\n}\r\n```\r\n\r\n\r\n### extend services\r\n\r\nYou can [extend](#extend) services with additional entities and actions\r\nmuch as you would add new entities to a context:\r\n\r\n```swift\r\nextend service CatalogService with {\r\n  entity Foo {};\r\n  function getRatings() returns Integer;\r\n}\r\n```\r\n\r\nSimilarly, you can [extend](#extend) entities with additional actions\r\nas you would add new elements:\r\n\r\n\r\n```swift\r\nextend entity CatalogService.Products with actions {\r\n  function getRatings() returns Integer;\r\n}\r\n```\r\n\r\n\r\n\r\n<br>\r\n"},{"name":"10-Namespaces-.md","content":"\r\n## Namespaces\r\n\r\n<!-- TOC depthFrom:3 -->\r\n\r\n- [`namespace` directive](#namespace-directive)\r\n- [contexts](#contexts)\r\n- [fully-qualified names](#fully-qualified-names)\r\n\r\n<!-- /TOC -->\r\n\r\n### namespace directive\r\n\r\nPlace a `namespace` directive to the top of a model to prefix the names of all subsequent definitions. This is very much as in other languages like Java.\r\n\r\n{% include _code sample='namespaces.cds' %}\r\n\r\n\r\n### contexts\r\n\r\nUse `contexts` for nested namespace sections.\r\n\r\n{% include _code sample='contexts.cds' %}\r\n\r\n\r\n### fully-qualified names\r\n\r\nA model ultimately is a collection of definitions with unique, fully-qualified names. For example, the second model above would compile to this [CSN][]:\r\n\r\n{% include _code sample='contexts.json' %}\r\n\r\n\r\n<br>\r\n"},{"name":"11-Imports-.md","content":"\r\n## Import Directives\r\n{:#imports}\r\n\r\n  - [`using` directives](#using-directives)\r\n  - [`import` directives](#import-directives)\r\n  - [model resolution](#model-resolution)\r\n\r\n\r\n### `using` directives\r\n\r\nUsing directives allow to import definitions from other cds models. As shown in line 3 below you can specify aliases to be used subsequently. You can import single definitions as well as several ones with a\r\ncommon namespace prefix, optionally choosing a local alias.\r\n\r\n{% include _code sample='using-from.cds' %}\r\n\r\nMultiple named imports via es6-like deconstructors:\r\n\r\n```swift\r\nusing { Foo as Moo, sub.Bar } from './base-model';\r\nentity Boo : Moo;\r\nentity Car : Bar;\r\n```\r\n\r\nNote: also in the deconstructor variant of `using`  shown above, you always need to specify fully-qualified names.\r\n\r\n\r\n### `import` directives\r\n{: .impl.concept}\r\n\r\nThe `import` directive extends the `using` directive to fully support syntax and semantics of [`import` statements in ES6][ES6].\r\nIn particular...\r\n\r\nImported names may omit the target's namespace prefix:\r\n\r\n```swift\r\nimport {Foo} from './base-model';\r\n```\r\n\r\nMultiple named imports via es6-like deconstructors:\r\n\r\n```swift\r\nimport { Foo as Moo, scoped.Bar } from './base-model';\r\nentity Boo : Moo;\r\nentity Car : Bar;\r\n```\r\n\r\n\r\nImports with locally chosen prefixes (independent from target namespaces):\r\n\r\n```swift\r\nimport base from './base-model';\r\nentity Foo : base.Foo;\r\nentity Bar : base.scoped.Bar;\r\n```\r\n\r\n\r\n### model resolution\r\n\r\nImports in `cds` work very much like `require` in [node][] and `imports` in [ES6][].\r\nIn fact we reuse **[Node's module loading mechanisms](https://nodejs.org/api/modules.html)**.\r\nHence the same rules apply; in short:\r\n\r\n* names starting with `./` or `../` are resolved relative to the current model\r\n* others are absolute references, fetched for in `node_modules` folders...\r\n* with `.json` or `.cds` suffixes appended in order\r\n* or from a `.../index.<json|cds>` file in case of a folder\r\n\r\n> Note: to allow for loading from pre-compiled `.json` files it is recommended\r\nto **omit `.cds` suffixes** in import statements, as shown in the examples above.\r\n\r\n\r\n<br>"},{"name":"doc","nodes":[{"name":"00-Intro-and-Benefits-.md","content":"\r\n## Why use _@sap/cds/common_?\r\n\r\nIt is strongly recommended that all applications use the common types and aspects provided through _@sap/cds/common_ in order to benefit from these features:\r\n\r\n* **concise** and **comprehensible** models &rarr; see also [Capture Intent](../guides/domain-models#capture-intent)\r\n* **foster interoperability** between all applications doing so\r\n* **proven best practices** captured from real applications\r\n* **streamlined** data models with **minimal entry barriers**\r\n* **optimized** implementations and runtime performance\r\n* **automatic** support for [localized] code lists and value helps\r\n* **extensibility** to adapt to your needs using [Aspects](../guides/domain-models#aspects)\r\n* **verticalization** through third party extension packages\r\n* **out-of-the-box** support for [Business Configuration]\r\n\r\n\r\nFor example, usage is as simple as indicated in the following sample:\r\n\r\n```swift\r\nusing { Country } from '@sap/cds/common';\r\nentity Addresses {\r\n  street  : String;\r\n  town    : String;\r\n  country : Country; //> using reuse type\r\n}\r\n```\r\n\r\n### Outcome = optimized best practice\r\n\r\nThe final outcomes in terms of modeling patterns, persistence structures, and implementations is essentially the same as what you would have done in a straightforward approach with native means --- if you would have collected design experiences from prior solutions, such as we did.\r\n\r\n**Note:** All the common reuse features discussed herein and provided through _@sap/cds/common_ are provided only through this ~100 lines .cds model. There's no additional runtime support required; it merely makes use of basic CDS modeling features as well as generic features like [localized data] and [temporal data] (which, in turn, also only need minimal runtime support with minimal overhead).\r\n\r\nIn effect, the results are **straightforward**, capturing **best practices** we learned from real business applications, with **minimal footprint**, **optimized performance** and **maximized adaptability** and **extensibility**.\r\n"},{"name":"01-Common-Aspects-.md","content":"\r\n## Common reuse aspects\r\n\r\n\r\n_@sap/cds/common_ defines the following [aspects] for use in your entity definitions. They give you not only shortcuts for concise and comprehensible models but also interoperability and out-of-the-box runtime features connected to them.\r\n\r\n### aspect `cuid`\r\n\r\nUse this as a convenient shortcut to add canonic, universally unique primary keys to your entity definitions. For example:\r\n\r\n```swift\r\nentity Foo : cuid {...}\r\n```\r\n\r\n... is equivalent to:\r\n\r\n```swift\r\nentity Foo {\r\n  key ID : UUID;\r\n  ...\r\n}\r\n```\r\n\r\n**Note:** The service provider runtimes automatically fill in UUID-typed keys like these with auto-generated UUIDs.\r\n\r\n[learn more about **canonic keys** and **UUIDs**](../guides/domain-models#use-canonic-primary-keys){: .learn-more}\r\n\r\n\r\n### aspect `managed`\r\n\r\nUse this to add four elements to capture created by/at and latest changed by/at management information for records.\r\n\r\n```swift\r\nentity Foo : managed {...}\r\n```\r\n\r\n... is essentially equivalent to:\r\n\r\n```swift\r\nentity Foo {\r\n  modifiedAt : DateTime;\r\n  createdAt  : DateTime;\r\n  createdBy  : String;\r\n  modifiedBy : String;\r\n  ...\r\n}\r\n```\r\n\r\n**In addition** to what's shown above, the pre-defined elements are annotated in a way that has the respective fields managed and filled in automatically by the generic service providers. Moreover, the fields are annotated with `@Core.Immutable` that tells Fiori clients to handle them as non-editable fields.\r\n\r\n[learn more about **generic service features**](../guides/providing-services#generic-providers){: .learn-more}\r\n\r\n\r\n### aspect `temporal`\r\n\r\nThis aspect basically adds two canonic elements, `validFrom` and `validTo` to an entity. It also adds a tag annotation that connects the cds compiler's and runtime's built-in support for _[Temporal Data]_, which covers handling date-effective records and time slices, including time travel. All you have to do is add the temporal aspect to respective entities as follows:\r\n\r\n```swift\r\nentity Contract : temporal {...}\r\n```\r\n\r\n[learn more about **temporal data**][temporal data]{: .learn-more}\r\n"},{"name":"02-Common-Types-.md","content":"\r\n## Common reuse types\r\n{:#code-types}\r\n\r\n_@sap/cds/common_ provides predefined easy-to-use types for _Countries_, _Currencies_ and _Languages_.\r\nUsing these in all applications fosters interoperability.\r\n\r\n### type `Country`\r\n[`Country`]: #country\r\n\r\nThe reuse type `Country` is defined in _@sap/cds/common_ as a simple managed [Association] to the [code list](#code-lists) for countries as follows:\r\n\r\n```swift\r\ntype Country : Association to sap.common.Countries;\r\n```\r\n\r\nHere's an example of how you would use that reuse type:\r\n\r\n{% include _code sample='using-country-type.cds' %}\r\n\r\nThe [code lists](#code-lists) define a key element `code`, which results in a foreign key column `country_code` in your SQL table for Addresses. For example:\r\n\r\n{% include _code sample='using-country-type.sql' %}\r\n\r\n[learn more about **managed associations**][Associations]{: .learn-more}\r\n\r\n\r\n\r\n### type `Currency`\r\n\r\n```swift\r\ntype Currency : Association to sap.common.Currencies;\r\n```\r\n\r\n[essentially same as for `Country`](#type-country){: .learn-more}\r\n\r\n### type `Language`\r\n\r\n```swift\r\ntype Language : Association to sap.common.Languages;\r\n```\r\n\r\n[essentially same as for `Country`](#type-country){: .learn-more}\r\n"},{"name":"03-Entities-.md","content":"\r\n## Entities, Views<!-- omit in toc -->\r\n\r\n- [entities](#entities)\r\n- [views](#views)\r\n- [views with declared signatures](#views-with-declared-signatures)\r\n- [views with parameters](#views-with-parameters)\r\n- [abstract entities](#abstract-entities)\r\n- [entity ... as projection on](#entity--as-projection-on)\r\n\r\n\r\n### entities\r\n\r\nEntities are essentially structured types representing sets of (persisted) data\r\nthat can be read and manipulated using CRUD operations. They usually contain\r\nprimary key elements. The leading `define` is optional.\r\n\r\n```swift\r\nentity Employees {\r\n  key ID : Integer;\r\n  name : String;\r\n  jobTitle : String;\r\n}\r\n```\r\nA most simple entity definition is:\r\n```\r\nentity Foo {};\r\n```\r\n\r\n### views\r\n\r\nViews are entities defined by projection on underlying entities/views, like views\r\nin SQL. The element signatures are usually inferred from the projection.\r\nThe projection can be any valid query.\r\n\r\n```swift\r\nentity SomeView as SELECT from Employees { * };\r\nentity Foo as SELECT from Bar; //> implicit {*}\r\n```\r\n\r\nViews inherit all properties and annotations from their primary underlying base entity. Their [`elements`]({{csn}}#structs) signature is **inferred** from the projection on base elements and each element inherits all properties from the respective base element.\r\n\r\nFor example, a view like that:\r\n\r\n```swift\r\nentity SomeView as SELECT from Employees {\r\n  ID, name, job.title as jobTitle\r\n};\r\n```\r\n\r\nwould probably have an inferred signature equivalent to that:\r\n```swift\r\nentity SomeView {\r\n  ID: Integer; name: String; jobTitle: String;\r\n};\r\n```\r\n\r\n\r\n### views with declared signatures\r\n{: .impl.concept}\r\n\r\nYou can optionally declare a view's expected signature explicitly. This will completely override the inferred signature. And implementation can check the inferred signature against the declared (i.e. expected) one.\r\n\r\n```swift\r\nentity SomeView {\r\n  ID: Integer; name: String; jobTitle: String;\r\n} as SELECT from Employees {\r\n  ID, name, job.title as jobTitle\r\n};\r\n```\r\n\r\n\r\n### views with parameters\r\n\r\nViews can be equipped with parameters that need to be passed in whenever that\r\nview is queried. Default values can be specified. The parameters can be referred\r\nto in the view's query using the prefix `:`.\r\n\r\n```swift\r\nentity SomeView ( foo: Integer, bar: Boolean )\r\nas SELECT * from Employees where ID=:foo;\r\n```\r\n\r\n\r\n### abstract entities\r\n\r\nYou can prefix an entity definition with the keyword `abstract` to indicate that\r\nthis entity should not have instances; i.e. just an _entity type_ declaration without\r\nan _entity set_. When activated to a database, no persistence artifacts, i.e. tables and views in SQL, are created.\r\n\r\n```swift\r\nabstract entity Foo {...}\r\nabstract entity Foo as SELECT from Bar {...};\r\n```\r\n\r\n\r\n\r\n### entity ... as projection on\r\n\r\nYou can use `as projection on` instead of `as SELECT from` to indicate restrictions on the allowed expressions of the following query.\r\n\r\n\r\n```swift\r\nentity Foo as projection on Bar {...}\r\n```\r\n\r\n> This is to support custom implementations in parsing the query, which would add respective checks.\r\nThe core `cds` parser and compiler modules themselves don't make any assumptions nor about restrictions on allowed expressions neither about when and where `as projection on` is allowed instead of `as SELECT from`.\r\n"},{"name":"04-CDS","nodes":[{"name":"11-CDL.md","content":"---\r\nlayout: cds-ref\r\nshorty: Definition Language\r\nsynopsis: >\r\n  A reference and overview of all CDS concepts and features with compact examples written in CDS' definition language.\r\npermalink: cds/cdl\r\nstatus: released\r\nuacp: Used as link target from Help Portal at https://help.sap.com/viewer/65de2977205c403bbc107264b8eccf4b/Cloud/en-US/855e00bd559742a3b8276fbed4af1008.html\r\n---\r\n\r\n# Definition Language (CDL)\r\n<style>\r\n  h2 {\r\n    font-weight: 300; font-size: 2.8em; color: #222;\r\n    border-bottom: .5px solid silver;\r\n    padding-bottom: 5px;\r\n  }\r\n  h3 {\r\n    font-weight: 400;\r\n    font-size: 1.5em;\r\n  }\r\n</style>\r\n\r\nFind here a reference of all CDS concepts and features in the form of compact examples.\r\nThe examples are given in **_CDL_**, a human-readable syntax for defining models, and **_CQL_**, an extension of SQL to write queries.\r\n\r\n\r\n{% include _toc levels=\"2,3\" %}\r\n{% include links.md %}\r\n\r\n<br>\r\nPlease refer also to [_The Nature of Models_](models) and the [_CSN specification_][CSN] to complete your understanding of CDS.\r\n\r\n<br>\r\n\r\n\r\n## Entity and Type Definitions\r\n\r\n- [Entity Definitions](#entities) --- `define entity`\r\n- [Type Definitions](#types) --- `define type`\r\n- [Predefined Types](#predefined-types)\r\n- [Structured Types](#structured-types)\r\n- [Arrayed Types](#arrayed-types)\r\n- [Virtual Elements](#virtual-elements)\r\n- [Calculated Fields](#calculated-fields)\r\n- [Default Values](#default-values)\r\n- [Constraints](#constraints)\r\n- [Enums](#enums)\r\n\r\n\r\n\r\n\r\n### Entity Definitions --- `define entity`\r\n{:#entities}\r\n\r\nEntities are structured types with named and typed elements,\r\nrepresenting sets of (persisted) data that can be read and manipulated using usual CRUD operations.\r\nThey usually contain one or more designated primary key elements:\r\n\r\n```swift\r\ndefine entity Employees {\r\n  key ID : Integer;\r\n  name : String;\r\n  jobTitle : String;\r\n}\r\n```\r\n\r\n> The `define` keyword is optional, that means `define entity Foo` is equal to `entity Foo`.\r\n\r\n\r\n### Type Definitions --- `define type`\r\n{:#types}\r\n\r\nYou can declare custom types to reuse later on, for example, for elements in entity definitions.\r\nCustom-defined types can be simple, that is derived from one of the predefined types, structure types or [Associations].\r\n\r\n```swift\r\ndefine type User : String(111);\r\ndefine type Amount {\r\n  value : Decimal(10,3);\r\n  currency : Currency;\r\n}\r\ndefine type Currency : Association to Currencies;\r\n```\r\n> The `define` keyword is optional, that means `define type Foo` is equal to `type Foo`.\r\n\r\n[Learn more about **Definitions of Named Aspects**.](#aspects){:.learn-more}\r\n\r\n\r\n\r\n\r\n### Predefined Types\r\n\r\n\r\n[See list of **Built-in Types**](types){:.learn-more}\r\n\r\n\r\n\r\n\r\n### Structured Types\r\n\r\nYou can declare and use custom struct types as follows:\r\n\r\n```swift\r\ntype Amount {\r\n  value : Decimal(10,3);\r\n  currency : Currency;\r\n}\r\nentity Books {\r\n  price : Amount;\r\n}\r\n```\r\n\r\nElements can also be specified with anonymous inline struct types.\r\nFor example, the following is equivalent to the definition of `Books` above:\r\n\r\n```swift\r\nentity Books {\r\n  price : {\r\n    value : Decimal(10,3);\r\n    currency : Currency;\r\n  };\r\n}\r\n```\r\n\r\n\r\n### Arrayed Types\r\n\r\nPrefix a type specification with `array of` or `many` to signify array types.\r\n\r\n```swift\r\nentity Foo { emails: many String; }\r\nentity Bar { emails: many { kind:String; address:String; }; }\r\nentity Car { emails: many EmailAddress; }\r\nentity Car { emails: EmailAddresses; }\r\ntype EmailAddresses : many { kind:String; address:String; }\r\ntype EmailAddress : { kind:String; address:String; }\r\n```\r\n\r\n> Keywords `many` and `array of` are mere syntax variants with identical semantics and implementations.\r\n\r\nWhen deployed to SQL databases, such fields are mapped to [LargeString](types) columns.\r\nWith OData V4, arrayed types are rendered as `Collection` in the EDM(X).\r\n\r\nGeneric support in runtimes is added over time. It's available in Node.js but not yet in Java. If not available, you need to add custom logic, for example, to serialize payloads into JSON strings and vice versa.\r\n\r\n\r\n\r\n### Virtual Elements\r\n\r\nAn element definition can be prefixed with modifier keyword `virtual`. This keyword indicates that this element isn't added to persistent artifacts, that is, tables or views in SQL databases. Virtual elements are part of OData metadata.\r\n\r\n```swift\r\nentity Employees {\r\n  ...\r\n  virtual something : String(11);\r\n}\r\n```\r\n### Literals\r\n\r\nUsing literals in CDS models is commonly used, for example, to set default values. The literals in the following table show you how to define these values in your CDS source.\r\n\r\n| Kind | Example |\r\n| --- | --- |\r\n| Null | `null` |\r\n| Boolean | `true`, `false` |\r\n| Numbers | `11` or  `2.4` |\r\n| Strings | `'foo'` |\r\n| Dates |  `'2016-11-24'` |\r\n| Times  |  `'16:11'` |\r\n| DateTimes |  `'2016-11-24T16:11'` |\r\n| Records |  `{\"foo\":<literal>, ...}` |\r\n| Arrays |  `[<literal>, ...]` |\r\n\r\n[Learn more about literals and their representation in CSN.]({{cap}}/cds/csn#literals){:.learn-more}\r\n\r\n### Calculated Fields\r\n{: .impl.concept}\r\n\r\nElements can be specified with a calculation expression in which you can refer to other elements of the same entity.\r\n\r\n```swift\r\nentity Employees {\r\n  addresses : Association to many Addresses;\r\n  homeAddress = addresses [kind='home'];\r\n}\r\n```\r\n\r\n\r\n### Default Values\r\n\r\nAs in SQL you can specify default values to fill in upon INSERTs if no value is specified for a given element.\r\n\r\n```swift\r\nentity Foo {\r\n  bar : String default 'bar';\r\n  boo : Integer default 1;\r\n}\r\n```\r\n\r\n\r\n### Type References\r\n{:#typereferences}\r\n\r\nIf you want to base an element's type on another element of the same structure, you can use the `type of` operator.\r\n\r\n```swift\r\nentity Author {\r\n  firstname : String(100);\r\n   lastname : type of firstname; // has type \"String(100)\"\r\n}\r\n```\r\n\r\nFor referencing elements of other artifacts, you can use the element access through `:`.\r\nElement references with `:` don’t require `type of` in front of them.\r\n\r\n```swift\r\nentity Employees {\r\n  firstname: type of Author:firstname;\r\n   lastname: Author:firstname; // optional type of\r\n}\r\n```\r\n\r\n\r\n### Constraints\r\n\r\nElement definitions can be augmented with constraint `not null` as known from SQL.\r\n\r\n```swift\r\nentity Employees {\r\n  name : String(111) not null;\r\n}\r\n```\r\n\r\n\r\n### Enums\r\n\r\nYou can specify enumeration values for a type as a semicolon-delimited list of symbols. String and integer enums are supported. For string types, declaration of actual values is optional; if omitted, the actual values then are the string counterparts of the symbols.\r\n\r\n```swift\r\ntype Gender : String enum { male; female; }\r\nentity Order {\r\n  status : Integer enum {\r\n    submitted =  1;\r\n    fulfilled =  2;\r\n    shipped   =  3;\r\n    canceled  = -1;\r\n  };\r\n}\r\n```\r\n\r\n\r\n<br>\r\n\r\n\r\n## Views and Projections\r\n{:#views}\r\n\r\nUse `as select from` or `as projection on` to derive new entities from existing ones by projections, very much like views in SQL. When mapped to relational databases, such entities are in fact translated to SQL views but they're frequently also used to declare projections without any SQL views involved.\r\n\r\nThe entity signature is inferred from the projection.\r\n\r\n- [The `as select from` Variant](#as-select-from)\r\n- [The `as projection on` Variant](#as-projection-on)\r\n- [Views with Inferred Signatures](#views-with-inferred-signatures)\r\n- [Views with Declared Signatures](#views-with-declared-signatures)\r\n- [Views with Nested Projections](#views-with-nested-projections)\r\n- [Views with Parameters](#views-with-parameters)\r\n\r\n\r\n### The `as select from` Variant\r\n{:#as-select-from}\r\n\r\nUse the `as select from` variant to use all possible features an underlying relational database would support using any valid [CQL] query including all query clauses.\r\n\r\n```swift\r\nentity Foo1 as SELECT from Bar; //> implicit {*}\r\nentity Foo2 as SELECT from Employees { * };\r\nentity Foo3 as SELECT from Employees LEFT JOIN Bar on Employees.ID=Bar.ID {\r\n  foo, bar as car, sum(boo) as moo\r\n} where exists (\r\n  SELECT 1 as anyXY from SomeOtherEntity as soe where soe.x = y\r\n)\r\ngroup by foo, bar\r\norder by moo asc;\r\n```\r\n\r\n\r\n### The `as projection on` Variant\r\n{:#as-projection-on}\r\n\r\nUse the `as projection on` variant instead of `as select from` to indicate that you don’t use the full power of SQL in your query. For example, having a restricted query in an entity allows us to serve such an entity from external OData services.\r\n\r\n\r\n```swift\r\nentity Foo as projection on Bar {...}\r\n```\r\n\r\nCurrently the restrictions of `as projection on` compared to `as select from` are:\r\n\r\n- no explicit, manual `JOINs`\r\n- no explicit, manual `UNIONs`\r\n- no sub selects in from clauses\r\n\r\nOver time, we can add additional checks depending on specific outbound protocols.\r\n\r\n\r\n### Views with Inferred Signatures\r\n\r\nBy default views inherit all properties and annotations from their primary underlying base entity.\r\nTheir [`elements`]({{csn}}#structured-types) signature is **inferred** from the projection on base elements.\r\nEach element inherits all properties from the respective base element.\r\n\r\nFor example, the following definition:\r\n\r\n```swift\r\nentity SomeView as SELECT from Employees {\r\n  ID,\r\n  name,\r\n  job.title as jobTitle\r\n};\r\n```\r\n\r\nMight result in this inferred signature:\r\n\r\n```swift\r\nentity SomeView {\r\n  ID: Integer;\r\n  name: String;\r\n  jobTitle: String;\r\n};\r\n```\r\n\r\n\r\n### Views with Declared Signatures\r\n{: .impl.concept}\r\n\r\nYou can optionally declare the expected signature explicitly. This declaration overrides the inferred signature. The implementation can check the inferred signature against the declared one.\r\n\r\n```swift\r\nentity SomeView {\r\n  ID: Integer; name: String; jobTitle: String;\r\n} as SELECT from Employees {\r\n  ID, name, job.title as jobTitle\r\n};\r\n```\r\n\r\n\r\n### Views with Nested Projections\r\n{: .impl.concept}\r\n\r\nUse [CQL's nested expands]({{cql}}#nested-expands) to declare projections on document structures and/or entity graphs, in turn resulting in structured document signatures.\r\n\r\n```swift\r\nentity MyOrders as select from Orders {\r\n  ID, buyer {\r\n    ID, name\r\n  },\r\n  Items {\r\n    pos, quantity, product {\r\n      ID, title\r\n    }\r\n  }\r\n};\r\n```\r\n\r\nThis projection would result in an inferred signature like that:\r\n\r\n\r\n```swift\r\nentity MyOrders {\r\n  ID : UUID;\r\n  buyer : {\r\n    ID : UUID;\r\n    name : String;\r\n  };\r\n  Items : array of {\r\n    pos : Integer;\r\n    quantity : Integer;\r\n    product : {\r\n      ID : UUID;\r\n      title : String;\r\n    }\r\n  }\r\n};\r\n```\r\n\r\n\r\n### Views with Parameters\r\n\r\nYou can equip views with parameters that are passed in whenever that view is queried. Default values can be specified. Refer to these parameters in the view's query using the prefix `:`.\r\n\r\n```swift\r\nentity SomeView ( foo: Integer, bar: Boolean )\r\nas SELECT * from Employees where ID=:foo;\r\n```\r\n[Learn more about how to expose views with parameters in **Services - Exposed Entities**.](#exposed-entities){: .learn-more}\r\n[Learn more about views with parameters for existing HANA artifactsSee in **Native SAP HANA Artifacts**.]({{cap}}/advanced/hana){: .learn-more}\r\n\r\n\r\n\r\n## Associations & Compositions\r\n{:#associations}\r\n\r\nAssociations capture relationships between entities. They are like forward-declared joins added to a table definition in SQL.\r\n\r\n- [Unmanaged Associations](#unmanaged-associations)\r\n- [Managed Associations](#managed-associations)\r\n- [To-many Associations](#to-many-associations)\r\n- [Many-to-many Associations](#many-to-many-associations)\r\n- [Managed many-to-many Associations](#managed-many-to-many-associations)\r\n- [Associations with Default Filters](#associations-with-default-filters)\r\n- [Associations to Parameterized Views](#associations-to-parameterized-views)\r\n- [Compositions](#compositions)\r\n- [Managed Compositions](#managed-compositions)\r\n\r\n\r\n### Unmanaged Associations\r\n\r\nUnmanaged associations specify arbitrary join conditions in their `on` clause, which refer to available foreign key elements. The association's name (`address` in the following example) is used as the alias for the to-be-joined target entity.\r\n\r\n```swift\r\nentity Employees {\r\n  address : Association to Addresses on address.ID = address_ID;\r\n  address_ID : Integer;  //> foreign key\r\n}\r\n```\r\n```swift\r\nentity Addresses {\r\n  key ID : Integer;\r\n}\r\n```\r\n\r\n\r\n### Managed (To-One) Associations\r\n{:#managed-associations}\r\n\r\nFor to-one associations, CDS can automatically resolve and add requisite foreign key elements from the target's primary keys and implicitly add respective join conditions.\r\n\r\n```swift\r\nentity Employees {\r\n  address : Association to Addresses;\r\n}\r\n```\r\n\r\nThis example is equivalent to the [unmanaged example above](#unmanaged-associations), with the foreign\r\nkey element `address_ID` being added automatically upon activation to a SQL database.\r\n\r\n> No foreign key constraints are added on database level.\r\n\r\n\r\n### To-many Associations\r\n\r\nFor to-many associations specify an `on` condition following the canonical expression pattern `<assoc>.<backlink> = $self` as in this example:\r\n\r\n```swift\r\nentity Employees {\r\n  key ID : Integer;\r\n  addresses : Association to many Addresses\r\n    on addresses.owner = $self;\r\n}\r\n```\r\n```swift\r\nentity Addresses {\r\n  owner : Association to Employees;  //> the backlink\r\n}\r\n```\r\n\r\n> The backlink can be any managed to-one association on the _many_ side pointing back to the _one_ side.\r\n\r\n\r\n### Many-to-many Associations\r\n\r\nFor many-to-many association, follow the common practice of resolving logical many-to-many relationships into two one-to-many associations using a link entity to connect both.\r\nFor example:\r\n\r\n```swift\r\nentity Employees { ...\r\n  addresses : Association to many Emp2Addr on addresses.emp = $self;\r\n}\r\nentity Emp2Addr {\r\n  key emp : Association to Employees;\r\n  key adr : Association to Addresses;\r\n}\r\n```\r\n\r\n[Learn more about **Managed Compositions for Many-to-many Relationships**.](#for-many-to-many-relationships){:.learn-more}\r\n\r\n\r\n\r\n### Managed many-to-many Associations\r\n{: .impl.concept}\r\n\r\nWith Managed Many-to-many Associations, CDS can generate requisite link tables automatically. You can use the `via` parameter clause to add elements to link table reflecting attributed relationships or to use a predefined link table instead.\r\n\r\n```swift\r\nentity Employees {\r\n  addresses1 : Association to many Addresses;\r\n  addresses2 : Association to many Addresses via {\r\n    kind: String(11);\r\n  };\r\n  addresses3 : Association to many Addresses via Emp2Addr;\r\n}\r\n```\r\n\r\nFor the first case, [`cds.compile`]({{cap}}/node.js/cds-compile) automatically adds a link table.\r\nFor the second case, it automatically adds a link table with an additional element `kind` (&rarr; an _attributed relationship_).\r\nFor the third case, [`cds.compile`]({{cap}}/node.js/cds-compile) uses the predefined entity `Emp2Addr` that is defined like that (names for `source/target` can be freely chosen):\r\n\r\n```swift\r\nentity Emp2Addr {\r\n  key emp : Association to Employees;\r\n  key adr : Association to Addresses;\r\n}\r\n```\r\n\r\n\r\n\r\n### Associations with Default Filters\r\n{: .impl.concept}\r\n\r\nFor to-many associations, you can optionally specify a default filter. That filter automatically\r\napplies to any usage of that association in queries, unless another filter is specified explicitly.\r\n\r\n```swift\r\nentity Products {\r\n  localized : Association to many Product$Texts\r\n    with default filter lang=$env.user.lang;\r\n}\r\n```\r\n```swift\r\nentity Product$Texts {\r\n  key product : Association to Products;\r\n  key lang : String(3);\r\n  title : String(44);\r\n  descr : String(444);\r\n}\r\n```\r\n\r\n### Associations to Parameterized Views\r\n{: .impl.concept}\r\n\r\nIf the target is a [parameterized view](#views-with-parameters), you can specify\r\ncorresponding arguments in an `Association` definition as follows:\r\n\r\n```swift\r\nentity Products {\r\n  assoc : Association to SomeParameterizedView (\r\n    param1: 4711,\r\n    param2: foo\r\n  );\r\n  foo : String;\r\n}\r\n```\r\n\r\n> The argument values for parameters are literals or expressions in which references are resolved within the current entity's elements.\r\n\r\n\r\n\r\n<br>\r\n\r\n\r\n### Compositions\r\n\r\nCompositions constitute document structures through 'contained-in' relationships.\r\nThey frequently show up in to-many header-child scenarios.\r\n\r\n```swift\r\nentity Orders {\r\n  key ID: Integer; //...\r\n  Items : Composition of many Orders.Items on Items.parent = $self;\r\n}\r\nentity Orders.Items {\r\n  key pos : Integer;\r\n  key parent : Association to Orders;\r\n  product : Association to Products;\r\n  quantity : Integer;\r\n}\r\n```\r\n\r\n> Essentially, Compositions are the same as _[associations]_, just with the additional information that this association represents a contained-in relationship so the same syntax and rules apply in their base form.\r\n\r\n\r\n### Managed Compositions of Aspects\r\n{:#managed-compositions}\r\n\r\nUse managed compositions variant to nicely reflect document structures in your domain models, without the need for separate entities, reverse associations, and unmanaged `on` conditions.\r\n\r\n\r\n#### With Inline Targets\r\n\r\n```swift\r\nentity Orders { \r\n  key ID: Integer; //...\r\n  Items : Composition of many { \r\n    key pos : Integer;\r\n    product : Association to Products;\r\n    quantity : Integer;\r\n  }\r\n}\r\n```\r\n\r\nManaged Compositions are mostly syntactical sugar: Behind the scenes, they are unfolded to the [unmanaged equivalent as shown above](#compositions) \r\nby automatically adding a new entity, the name of which being constructed as a [scoped name](#scoped-names) from the name of parent entity, followed by the name of the composition element, \r\nthat is `Orders.Items` in the previous example.\r\n\r\n\r\n#### With Named Targets\r\n\r\nInstead of anonymous target aspects you can also specify named aspects, which are unfolded the same way than anonymous inner types, as shown in the previous example:\r\n\r\n```swift\r\nentity Orders {\r\n  key ID: Integer; //...\r\n  Items : Composition of many OrderItems;\r\n}\r\naspect OrderItems { \r\n  key pos : Integer;\r\n  product : Association to Products;\r\n  quantity : Integer;\r\n}\r\n```\r\n\r\n#### For Many-to-many Relationships\r\n\r\nManaged Compositions are handy for [many-to-many relationships](#many-to-many-associations), where a link table usually is private to one side.\r\n\r\n```swift\r\nentity Teams { ...\r\n  members : Composition of many { key user: Association to Users; }\r\n}\r\nentity Users { ...\r\n  teams: Association to many Teams.members on teams.user = $self;\r\n}\r\n```\r\n\r\nAnd here's an example of an attributed many-to-many relationship:\r\n\r\n```swift\r\nentity Teams { ...\r\n  members : Composition of many {\r\n    key user : Association to Users;\r\n    role : String enum { Lead; Member; Collaborator; }\r\n  }\r\n}\r\nentity Users { ... }\r\n```\r\n\r\n\r\n\r\n\r\n## Annotations\r\n\r\nThis section describes how to add Annotations to model definitions written in CDL, focused on the common syntax options, and fundamental concepts. Find additional information in the [OData Annotations] guide. \r\n\r\n- [Annotation Syntax](#annotation-syntax)\r\n- [Annotation Targets](#annotation-targets)\r\n- [Annotation Values](#annotation-values)\r\n- [Records as Syntax Shortcuts](#records-as-syntax-shortcuts)\r\n- [The `annotate` Directive](#annotate)\r\n\r\n\r\n### Annotation Syntax\r\n\r\nAnnotations in CDL are prefixed with an `@` character and can be placed before a definition, after the defined name or at the end of simple definitions.\r\n\r\n```swift\r\n@before entity Foo @inner {\r\n  @before simpleElement @inner : String @after;\r\n  @before structElement @inner { /* elements */ }\r\n}\r\n```\r\n\r\nMultiple annotations can be placed in each spot separated by whitespaces or enclosed in `@(...)` and separated by comma - like the following are equivalent:\r\n\r\n```swift\r\nentity Foo @(\r\n  my.annotation: foo,\r\n  another.one: 4711\r\n) { /* elements */ }\r\n```\r\n```swift\r\n@my.annotation:foo\r\n@another.one: 4711\r\nentity Foo { /* elements */ }\r\n```\r\n\r\nFor an `@inner` annotation, only the syntax `@(...)` is available.\r\n\r\n### Annotation Targets\r\n\r\nYou can basically annotate any named thing in a CDS model, such as:\r\n\r\nContexts and services:\r\n\r\n```java\r\n@before [define] (context|service) Foo @inner { ... }\r\n```\r\n\r\nDefinitions and elements with simple types:\r\n\r\n```java\r\n@before [define] type Foo @inner : String @after;\r\n@before [key] anElement @inner : String @after;\r\n```\r\n\r\nEntities, aspects, and other struct types and elements thereof:\r\n\r\n```java\r\n@before [define] (entity|type|aspect|annotation) Foo @inner {\r\n  @before simple @inner : String @after;\r\n  @before struct @inner { ...elements... };\r\n}\r\n```\r\n\r\nEnums:\r\n\r\n```java\r\n... status : String @inner enum {\r\n  fulfilled @after;\r\n}\r\n```\r\n\r\nColumns in a view definition's query:\r\n\r\n```java\r\n... as SELECT from Foo {\r\n  @before expr as alias @inner : String,\r\n  ...\r\n}\r\n```\r\n\r\nParameters in view definitions:\r\n\r\n```java\r\n... with parameters (\r\n  @before param @inner : String @after\r\n) ...\r\n```\r\n\r\nActions/functions including their parameters and result elements:\r\n\r\n```java\r\n@before action doSomething @inner (\r\n  @before param @inner : String @after\r\n) returns {\r\n  @before result @inner : String @after;\r\n};\r\n```\r\n\r\n\r\n### Annotation Values\r\n\r\nValues can be literals or references. If no value is given, the default value is `true` as for `@aFlag` in the following example:\r\n\r\n```java\r\n@aFlag //= true, if no value is given\r\n@aBoolean: false\r\n@aString: 'foo'\r\n@anInteger: 11\r\n@aDecimal: 11.1\r\n@aSymbol: #foo\r\n@aReference: foo.bar\r\n@anArray: [ /* can contain any kind of value */ ]\r\n```\r\n\r\nAs described in the [CSN spec]({{csn}}#literals), the previously mentioned annotations would compile to CSN as follows:\r\n\r\n```\r\n{\r\n  \"@aFlag\": true,\r\n  \"@aBoolean\": false,\r\n  \"@aString\": \"foo\",\r\n  \"@anInteger\": 11,\r\n  \"@aDecimal\": 11.1,\r\n  \"@aSymbol\": {\"#\":\"foo\"},\r\n  \"@aReference\": {\"=\":\"foo.bar\"},\r\n  \"@anArray\": [ ... ]\r\n}\r\n```\r\n\r\nReferences (and expressions in general) aren't checked or resolved by CDS parsers or linkers. They’re interpreted and evaluated only on consumption-specific modules. For example, for SAP Fiori models, it's the _4odata_ and _2edm(x)_ processors.\r\n{:.tip}\r\n\r\n\r\n### Records as Syntax Shortcuts\r\n\r\nAnnotations in CDS are flat lists of key-value pairs assigned to a target.\r\nThe record syntax - that is, `{key:<value>, ...}` - is a shortcut notation that applies a common prefix to nested annotations.\r\nFor example, the following are equivalent:\r\n\r\n```java\r\n@Common.foo.bar\r\n@Common.foo.car: 'wheels'\r\n```\r\n```java\r\n@Common: { foo.bar, foo.car: 'wheels' }\r\n```\r\n```java\r\n@Common.foo: { bar }\r\n@Common.foo.car: 'wheels'\r\n```\r\n```java\r\n@Common.foo: { bar, car: 'wheels'  }\r\n```\r\n\r\nand they would show up as follows in a parsed model (&rarr; see [CSN][]):\r\n\r\n```\r\n{\r\n  \"@Common.foo.bar\": true,\r\n  \"@Common.foo.car\": \"wheels\",\r\n}\r\n```\r\n\r\n### Annotation Propagation\r\n\r\nAnnotations are inherited from types and base types to derived types, entities, and elements as well as from elements of underlying entities in case of views.\r\n\r\nFor examples, given this view definition:\r\n\r\n```swift\r\nusing Books from './bookshop-model';\r\nentity BooksList as SELECT from Books {\r\n  ID, genre : Genre, title,\r\n  author.name as author\r\n};\r\n```\r\n\r\n* `BooksList` would inherit annotations from `Books`\r\n* `BooksList.ID` would inherit from `Books.ID`\r\n* `BooksList.author` would inherit from `Books.author.name`\r\n* `BooksList.genre` would inherit from type `Genre`\r\n\r\nThe rules are:\r\n\r\n1. Entity-level properties and annotations are inherited from the **primary** underlying source entity --- here `Books`.\r\n\r\n2. Each element that can **unambiguously** be traced back to a single source element, inherits that element's properties.\r\n\r\n3. An explicit **cast** in the select clause cuts off the inheritance, for example, as for `genre` in our previous example.\r\n\r\n\r\n\r\n### The `annotate` Directive\r\n{:#annotate}\r\n\r\nThe `annotate` directive allows to annotate already existing definitions, that may have been [imported](#imports) from other files or projects.\r\n\r\n```swift\r\nannotate Foo with @title:'Foo' {\r\n  nestedStructField {\r\n    existingField @title:'Nested Field';\r\n  }\r\n}\r\nannotate Bar with @title:'Bar';\r\n```\r\n\r\nThe `annotate` directive a variant of the [`extend` directive](#extend).\r\nActually, `annotate` is just a shortcut with the default mode being switched to `extend`ing existing fields instead of adding new ones.\r\n\r\n<br>\r\n\r\n## Aspects\r\n\r\nCDS's aspects allow to flexibly extend definitions by new elements as well as overriding properties and annotations.\r\nThey're based on a mixin approach as known from Aspect-oriented Programming methods.\r\n\r\n- [The `extend` Directive](#extend)\r\n- [Named Aspects](#aspect) --- `define aspect`\r\n- [Shortcut Syntax `:`](#includes)\r\n- [Looks Like Inheritance](#looks-like-inheritance)\r\n- [Extending Views / Projections](#extend-view)\r\n\r\n\r\n### The `extend` Directive\r\n{: #extend}\r\n\r\nUse `extend` to add extension fields or to add/override metadata to existing definitions, for example, annotations, as follows:\r\n\r\n```swift\r\nextend Foo with @title:'Foo' {\r\n  newField : String;\r\n  extend nestedStructField {\r\n    newField : String;\r\n    extend existingField @title:'Nested Field';\r\n  }\r\n}\r\nextend Bar with @title:'Bar'; // nothing for elements\r\n```\r\n\r\nMake sure that you prepend the `extend` keyword to nested elements, otherwise this would mean that you want to add a new field with that name:\r\n{:.tip}\r\n\r\n[Learn more about the **annotate** Directive.](#annotate){:.learn-more}\r\n\r\n\r\n\r\n### Named Aspects --- `define aspect`\r\n{:#aspect}\r\n\r\nYou can use `extend` or `annotate` with predefined aspects, to apply the same extensions to multiple targets:\r\n\r\n```swift\r\nextend Foo with ManagedObject;\r\nextend Bar with ManagedObject;\r\n```\r\n```swift\r\naspect ManagedObject {\r\n  created { at: Timestamp; _by: User; }\r\n}\r\n```\r\n\r\n> The `define` keyword is optional, that means `define aspect Foo` is equal to `aspect Foo`.\r\n\r\nIf you use `extend`, all nested fields in the named aspect are interpreted as being extension fields. If you use `annotate`, the nested fields are interpreted as existing fields and the annotations are copied to the corresponding target elements.\r\n\r\nThe named extension can be anything, for example, including other `types` or `entities`.\r\nUse keyword `aspect` as shown in the example to declare definitions that are only meant to be used in such extensions, not as types for elements.\r\n\r\n\r\n\r\n### Includes -- `:` as Shortcut Syntax\r\n{:#includes}\r\n\r\nYou can use an inheritance-like syntax option to extend a definition with one or more [named aspects](#aspect)\r\nas follows:\r\n\r\n```swift\r\ndefine entity Foo : ManagedObject, AnotherAspect {\r\n  key ID : Integer;\r\n  name : String;\r\n  ...\r\n}\r\n```\r\n\r\nThis is syntactical sugar and equivalent to using a sequence of [extends](#extend) as follows:\r\n\r\n```swift\r\ndefine entity Foo {}\r\nextend Foo with ManagedObject;\r\nextend Foo with AnotherAspect;\r\nextend Foo with {\r\n  key ID : Integer;\r\n  name : String;\r\n  ...\r\n}\r\n```\r\n\r\nYou can apply this to any definition of an entity or a structured type.\r\n\r\n\r\n\r\n### Looks Like Inheritance\r\n\r\nThe `:`-based syntax option described before looks very much like (multiple) inheritance and in fact has very much the same effects. Yet, as mentioned in the beginning of this\r\nsection, it isn’t based on inheritance but on mixins, which are more powerful and also avoid common problems like the infamous diamond shapes in type derivations.\r\n\r\nWhen combined with persistence mapping there are a few things to note, that goes down to which strategy to choose to map inheritance to, for example, relational models. See [_Aspects vs Inheritance_](../cds/aspects-inheritance) for more details.\r\n\r\n\r\n### Extending Views and Projections\r\n{: #extend-view}\r\n\r\nUse the `extend projection` variant to extend the projection of a view entity to include more elements existing in the underlying entity:\r\n\r\n```swift\r\nextend projection Foo with @title:'Foo' {\r\n  foo as bar @car\r\n}\r\n```\r\n\r\nEnhancing nested structs isn’t supported. Note also that you can use the common [`annotate`](#annotate) syntax, to just add/override annotations of a view's elements.\r\n{:.tip}\r\n\r\n<br>\r\n\r\n\r\n## Services\r\n\r\n- [Service Definitions](#service-definitions)\r\n- [Exposed Entities](#exposed-entities)\r\n- [(Auto-) Redirected Associations](#auto-redirect)\r\n- [Auto-exposed Targets](#auto-expose)\r\n- [Custom Actions/Functions](#actions)\r\n- [Custom-defined Events](#events)\r\n- [Extending Services](#extend-service)\r\n- [Derived Services](#derived-services)\r\n\r\n\r\n### Service Definitions\r\n\r\nCDS allows to define service interfaces as collections of exposed entities enclosed in a `service` block, which essentially is and acts the same a [`context`](#context):\r\n\r\n```swift\r\nservice SomeService {\r\n  entity SomeExposedEntity { ... };\r\n  entity AnotherExposedEntity { ... };\r\n}\r\n```\r\n\r\nThe endpoint of the exposed service is constructed by its name, following some conventions (the string `service` is dropped and kebab-case is enforced). If you want to overwrite the path, you can add the `@path` annotation as follows:\r\n\r\n```swift\r\n@path: 'myCustomServicePath'\r\nservice SomeService { ... }\r\n```\r\n\r\n\r\n### Exposed Entities\r\n\r\nThe entities exposed by a service are most frequently projections on entities from underlying data models.\r\nStandard view definitions, using [`as SELECT from`](#views) or [`as projection on`](#as-projection-on), can be used for\r\nexposing entities.\r\n\r\n```swift\r\nservice CatalogService {\r\n  entity Product as projection on data.Products {\r\n    *, created.at as since\r\n  } excluding { created };\r\n}\r\nservice MyOrders {\r\n  view Order as select from data.Orders { * } where buyer=$user.id;  //> $user not yet implemented!\r\n  entity Product as projection on CatalogService.Product;\r\n}\r\n```\r\n\r\nYou can optionally add annotations such as `@readonly` or `@insertonly` to exposed entities, which, will be enforced by the CAP runtimes in Java and Node.js.\r\n{:.tip}\r\n\r\nEntities can be also exposed as views with parameters:\r\n\r\n```swift\r\nservice MyOrders {\r\n  view OrderWithParameter( foo: Integer ) as select from data.Orders where id=:foo;\r\n}\r\n```\r\nA [`view with parameter`](#views-with-parameters) modeled in the previous example, can be exposed as follows:\r\n\r\n```swift\r\nservice SomeService {\r\n  view ViewInService( p1: Integer, p2: Boolean ) as select from data.SomeView(foo: :p1, bar: :p2) {*};\r\n}\r\n```\r\nThen the OData request for views with parameters should look like this:\r\n\r\n```swift\r\nGET: /OrderWithParameter(foo=5)/Set or GET: /OrderWithParameter(5)/Set\r\nGET: /ViewInService(p1=5, p2=true)/Set\r\n```\r\n\r\n\r\n### (Auto-) Redirected Associations\r\n{:#auto-redirect}\r\n\r\nWhen exposing related entities, associations are automatically redirected. This ensures that clients can navigate between projected entities as expected. For example:\r\n\r\n```swift\r\nservice AdminService {\r\n  entity Books as projection on my.Books;\r\n  entity Authors as projection on my.Authors;\r\n  //> AdminService.Authors.books refers to AdminService.Books\r\n}\r\n```\r\n\r\n#### Resolving Ambiguities \r\n\r\nAuto-redirection fails if a target can't be resolved unambiguously, that is, when there is more than one projection with the same minimal 'distance' to the source. For example, compiling the following model with two projection on `my.Books` would produce this error:\r\n\r\n{:.danger-title}  \r\nTarget \"Books\" is exposed in service \"AdminService\" by multiple projections \"AdminService.ListOfBooks\", \"AdminService.Books\" - no implicit redirection.\r\n{:.danger} \r\n\r\n```swift\r\nservice AdminService {\r\n  entity ListOfBooks as projection on my.Books;\r\n  entity Books as projection on my.Books;\r\n  entity Authors as projection on my.Authors;\r\n  //> which one should AdminService.Authors.books refers to?\r\n}\r\n```\r\n\r\n#### Using `redirected to` with projected Associations\r\n\r\nYou can use `redirected to` to resolve the ambiguity as follows:\r\n\r\n```swift\r\nservice AdminService {\r\n  ...\r\n  entity Authors as projection on my.Authors { *,\r\n    books : redirected to Books //> resolved ambiguity\r\n  };\r\n}\r\n```\r\n\r\n#### Using `@cds.redirection.target` Annotations\r\n\r\nAlternatively, you can use the boolean annotation `@cds.redirection.target` with value `true` to make an entity a preferred redirection target, or with value `false` to exclude an entity as target for auto-redirection.\r\n\r\n```swift\r\nservice AdminService {\r\n  @cds.redirection.target: true\r\n  entity ListOfBooks as projection on my.Books;\r\n  ...\r\n}\r\n```\r\n\r\n### Auto-Exposed Entities\r\n\r\n{:#auto-expose}\r\n\r\nAnnotate entities with `@cds.autoexpose` to automatically expose them in services containing entities with Association referring to them. \r\n\r\nFor example, given the following entity definitions:\r\n\r\n```swift\r\n// schema.cds\r\nnamespace schema;\r\nentity Bar @cds.autoexpose { key id: Integer; }\r\n\r\nusing { sap.common.CodeList } from '@sap/cds/common';\r\nentity Car : CodeList { key code: Integer; }\r\n//> inherits  @cds.autoexpose from  sap.common.CodeList\r\n```\r\n\r\n... a service definition like this:\r\n\r\n```swift\r\nusing { schema as my } from './schema.cds';\r\nservice Zoo {\r\n  entity Foo { //...\r\n    bar : Association to my.Bar;\r\n    car : Association to my.Car;\r\n  }\r\n}\r\n```\r\n\r\n... would result in the service being automatically extended like this:\r\n\r\n```swift\r\nextend service Zoo with { // auto-exposed entities:\r\n   @readonly entity Foo_bar as projection on Bar;\r\n   @readonly entity Foo_car as projection on Car;\r\n}\r\n```\r\n\r\nYou can still expose such entities explicitly, for example, to make them read-write:\r\n\r\n```swift\r\nservice Sue {\r\n  entity Foo { /*...*/ }\r\n  entity Bar as projection on my.Bar;\r\n}\r\n```\r\n\r\n[Learn more about **CodeLists in `@sap/cds/common`**.][{{cap}}/cds/common#code-lists]{:.learn-more}\r\n\r\n### Custom Actions and Functions\r\n{:#actions}\r\n\r\nWithin service definitions, you can additionally specify `actions` and `functions`. Use a comma-separated list of named and typed inbound parameters and an\r\noptional response type, which can be either a:\r\n\r\n- [Predefined Type](types)\r\n- [Reference to a custom-defined type](#types)\r\n- [Inline definition of an anonymous structured type](#structured-types)\r\n\r\n```swift\r\nservice MyOrders {\r\n  entity Order { /*...*/ };\r\n  // unbound actions / functions\r\n  type cancelOrderRet {\r\n    acknowledge: String enum { succeeded; failed; };\r\n    message: String;\r\n  }\r\n  action cancelOrder ( orderID:Integer, reason:String ) returns cancelOrderRet;\r\n  function countOrders() returns Integer;\r\n  function getOpenOrders() returns array of Order;\r\n}\r\n```\r\n\r\nThe notion of actions and functions in CDS adopts that of [OData](http://docs.oasis-open.org/odata/odata/v4.0/os/part1-protocol/odata-v4.0-os-part1-protocol.html#_Toc372793737); actions and functions on service-level are _unbound_ ones.\r\n{:.tip}\r\n\r\n\r\n#### Bound Actions and Functions\r\n{: #bound-actions}\r\n\r\nActions and functions can also be bound to individual entities of a service, enclosed in an additional `actions` block as the last clause in an entity/view definition.\r\n\r\n```swift\r\nservice CatalogService {\r\n  entity Products as projection on data.Products { ... }\r\n    actions {\r\n      // bound actions/functions\r\n      action addRating (stars: Integer);\r\n      function getViewsCount() returns Integer;\r\n    }\r\n}\r\n```\r\n\r\n\r\n### Custom-Defined Events\r\n{:#events .impl.beta}\r\n\r\nSimilar to [Actions and Functions][actions] you can declare `events`, which a service emits via messaging channels. Essentially, an event declaration looks very much like a type definition, specifying the event's name and the type structure of the event messages' payload.\r\n\r\n```swift\r\nservice MyOrders { ...\r\n  event OrderCanceled {\r\n    orderID: Integer;\r\n    reason: String;\r\n  }\r\n}\r\n```\r\n\r\n### Extending Services\r\n{:#extend-service}\r\n\r\nYou can [extend](#extend) services with additional entities and actions much as you would add new entities to a context:\r\n\r\n```swift\r\nextend service CatalogService with {\r\n  entity Foo {};\r\n  function getRatings() returns Integer;\r\n}\r\n```\r\n\r\nSimilarly, you can [extend](#extend) entities with additional actions\r\nas you would add new elements:\r\n\r\n\r\n```swift\r\nextend entity CatalogService.Products with actions {\r\n  function getRatings() returns Integer;\r\n}\r\n```\r\n\r\n\r\n### Derived Services\r\n{: .impl.concept}\r\n\r\nDefine abstract services and inherit from it in other service definitions as in this example:\r\n\r\n```swift\r\nabstract service ShoppingService {\r\n  abstract entity Articles {...}\r\n  entity Suppliers {...}\r\n  entity ShoppingCart {} actions {\r\n    action submitOrder();\r\n  }\r\n}\r\n```\r\n\r\n```swift\r\nservice Bookshop : ShoppingService {\r\n  entity Books : ShoppingService.Articles {\r\n    author : Association to Authors;\r\n  }\r\n  entity Authors {...}\r\n}\r\n```\r\n\r\n\r\n\r\n<br>\r\n\r\n## Namespaces\r\n\r\n- [The `namespace` Directive](#namespace)\r\n- [The `context` Directive](#context)\r\n- [Fully Qualified Names](#fully-qualified-names)\r\n\r\n\r\n### The `namespace` Directive\r\n{:#namespace}\r\n\r\nTo prefix the names of all subsequent definitions, place a `namespace` directive at the top of a model. This is comparable to other languages, like Java.\r\n\r\n{% include _code sample='namespaces.cds' %}\r\n\r\n\r\n### The `context` Directive\r\n{:#context}\r\n\r\nUse `contexts` for nested namespace sections.\r\n\r\n{% include _code sample='contexts.cds' %}\r\n\r\n\r\n\r\n### Scoped Definitions\r\n{:#scoped-names}\r\n\r\nYou can define types and entities with other definitions' names as prefixes:\r\n\r\n```swift\r\nnamespace foo.bar;\r\nentity Foo {}           //> foo.bar.Foo\r\nentity Foo.Bar {}       //> foo.bar.Foo.Bar\r\ntype Foo.Bar.Car {}     //> foo.bar.Foo.Bar.Car\r\n```\r\n\r\n\r\n### Fully Qualified Names\r\n\r\nA model ultimately is a collection of definitions with unique, fully qualified names. For example, the second model above would compile to this [CSN][]:\r\n\r\n{% include _code sample='contexts.json' %}\r\n\r\n\r\n<br>\r\n\r\n## Import Directives\r\n{:#imports}\r\n\r\n  - [The `using` Directive](#using)\r\n  - [The `import` Directive](#import)\r\n  - [Model Resolution](#model-resolution)\r\n\r\n\r\n### The `using` Directive\r\n{:#using}\r\n\r\nUsing directives allows to import definitions from other CDS models. As shown in line three below you can specify aliases to be used subsequently. You can import single definitions as well as several ones with a common namespace prefix. Optional: Choose a local alias.\r\n\r\n{% include _code sample='using-from.cds' %}\r\n\r\nMultiple named imports through es6-like deconstructors:\r\n\r\n```swift\r\nusing { Foo as Moo, sub.Bar } from './base-model';\r\nentity Boo : Moo { /*...*/ }\r\nentity Car : Bar { /*...*/ }\r\n```\r\n\r\n> Also in the deconstructor variant of `using` shown in the previous example, specify fully qualified names.\r\n\r\n\r\n### The `import` Directive\r\n{: #import .impl.concept}\r\n\r\nThe `import` directive extends the `using` directive to fully support syntax and semantics of [`import` statements in ES6][ES6].\r\n\r\nImported names can omit the target's namespace prefix:\r\n\r\n```swift\r\nimport {Foo} from './base-model';\r\n```\r\n\r\nMultiple named imports through es6-like deconstructors:\r\n\r\n```swift\r\nimport { Foo as Moo, scoped.Bar } from './base-model';\r\nentity Boo : Moo;\r\nentity Car : Bar;\r\n```\r\n\r\n\r\nImports with locally chosen prefixes (independent from target namespaces):\r\n\r\n```swift\r\nimport base from './base-model';\r\nentity Foo : base.Foo;\r\nentity Bar : base.scoped.Bar;\r\n```\r\n\r\n\r\n### Model Resolution\r\n\r\nImports in `cds` work very much like `require` in [node][] and `imports` in [ES6][].\r\nIn fact, we reuse **[Node's module loading mechanisms](https://nodejs.org/api/modules.html#modules_all_together)**.\r\nHence, the same rules apply:\r\n\r\n* Relative path resolution\r\n  Names starting with `./` or `../` are resolved relative to the current model.\r\n* Resolving absolute references\r\n  They're fetched for in `node_modules` folders:\r\n  * Files having `.cds`, `.csn`, or `.json` as suffixes, appended in order\r\n  * Folders, from either the file set in `cds.main` in the folder's `package.json` or `index.<cds|csn|json>` file.\r\n\r\nTo allow for loading from precompiled `.json` files it’s recommended to **omit `.cds` suffixes** in import statements, as shown in the provided examples.\r\n{:.tip}\r\n"},{"name":"12-CSN.md","content":"---\r\nlayout: cds-ref\r\nshorty: Schema Notation\r\nsynopsis: >\r\n  Specification of CSN, CDS' canonical format for representing CDS models as plain JavaScript objects, similar to [JSON Schema].\r\npermalink: cds/csn\r\nstatus: released\r\nuacp: Used as link target from Help Portal at https://help.sap.com/viewer/65de2977205c403bbc107264b8eccf4b/Cloud/en-US/855e00bd559742a3b8276fbed4af1008.html\r\n---\r\n\r\n# Schema Notation (CSN)\r\n\r\nCSN (pronounced as \"_Season_\") is a notation for compact representations of CDS models — tailored to serve as an optimized format to share and interpret models with minimal footprint and dependencies.\r\n\r\nIt’s similar to [JSON Schema][] but goes beyond JSON's abilities, in order to capture full-blown _Entity-Relationship Models_ and [Extensions](#aspects). This makes CSN models a perfect source to generate target models, such as [OData/EDM][odata] or [OpenAPI] interfaces, as well as persistence models for SQL or NoSQL databases.\r\n\r\n[JSON Schema]: https://json-schema.org\r\n\r\n\r\n\r\n#### Content\r\n{% include _toc levels=\"2,3\" %}\r\n{% include links.md %}\r\n\r\n\r\n\r\n## Anatomy\r\n\r\nA CSN model in **JSON**:\r\n\r\n```json\r\n{\r\n  \"requires\": [ \"@sap/cds/common\", \"./db/schema\" ],\r\n  \"definitions\": {\r\n    \"some.type\": { \"type\": \"cds.String\", \"length\": 11 },\r\n    \"another.type\": { \"type\": \"some.type\" },\r\n    \"structured.type\": { \"elements\": {\r\n      \"foo\": { \"type\": \"cds.Integer\" },\r\n      \"bar\": { \"type\": \"cds.String\" }\r\n    }}\r\n  },\r\n  \"extensions\": [\r\n    { \"extend\":\"Foo\", \"elements\":{\r\n      \"bar\": { \"type\": \"cds.String\" }\r\n    }}\r\n  ]\r\n}\r\n```\r\n\r\nThe same model in **YAML**:\r\n\r\n```yaml\r\nrequires:\r\n  - @sap/cds/common\r\n  - ./db/schema,\r\ndefinitions:\r\n  some.type: {type: cds.String, length: 11}\r\n  another.type: {type: some.type }\r\n  structured.type:\r\n    elements:\r\n      foo: {type: cds.Integer}\r\n      bar: {type: cds.String}\r\nextensions: [\r\n  - extend: Foo\r\n    elements: \r\n      bar: {type: cds.String}\r\n]\r\n```\r\n\r\nThe same model as a **plain JavaScript** object:\r\n\r\n```js\r\n({\r\n  requires:[ '@sap/cds/common', './db/schema' ],\r\n  definitions: {\r\n    'some.type': { type:\"cds.String\", length:11 },\r\n    'another.type': { type:\"some.type\" },\r\n    'structured.type': { elements: {\r\n      'foo': { type:\"cds.Integer\" },\r\n      'bar': { type:\"cds.String\" }\r\n    }}\r\n  },\r\n  extensions: [\r\n    { extend:'Foo', elements:{\r\n      'bar': { type:\"cds.String\" }\r\n    }\r\n  ],\r\n})\r\n```\r\n\r\nFor the remainder of this spec, you see examples in plain JavaScript representation with the following **conventions**:\r\n\r\n```js\r\n({property:...})   // a CSN-specified property name\r\n({'name':...})     // a definition's declared name\r\n\"value\"            // a string value, including referred names\r\n11, true           // number and boolean literal values\r\n```\r\n\r\n#### Properties\r\n* [`requires`](#imports) --- an array listing [imported models](#imports)\r\n* [`definitions`](#definitions) ---  a dictionary of named [definitions](#definitions)\r\n* [`extensions`](#aspects) --- an array of unnamed [aspects](#aspects)\r\n* [`i18n`](#i18n) --- a dictionary of dictionaries of [text translations](#i18n)\r\n\r\nAll properties are optional. For example, one model could contain a few definitions, while another one only contains some extensions.\r\n{:.tip}\r\n\r\n> References are case-sensitive. All references in properties like `type` or `target` use exactly the same notation regarding casing as their targets' names. To avoid problems when translating models to case-insensitive environments like SQL databases, avoid case-significant names and references. For example, avoid two different definitions in the same scope whose names only differ in casing, such as `foo` and `Foo`.\r\n\r\n\r\n\r\n\r\n## Literals\r\n\r\nThere are several places where literals can show up in models, such as in SQL expressions, calculated fields, or annotations.\r\n\r\nStandard literals are represented as in JSON:\r\n\r\n| Kind | Example |\r\n| --- | --- |\r\n| Globals | `true`, `false`, `null` |\r\n| Numbers<sup>1</sup> | `11` or  `2.4` |\r\n| Strings | `\"foo\"` |\r\n| Dates<sup>2</sup> |  `\"2016-11-24\"` |\r\n| Times<sup>2</sup>  |  `\"16:11\"` |\r\n| DateTimes<sup>2</sup> |  `\"2016-11-24T16:11\"` |\r\n| Records |  `{\"foo\":<literal>, ...}` |\r\n| Arrays |  `[<literal>, ...]` |\r\n\r\nIn addition, CSN specifies these special forms for references, expressions, and `enum` symbols:\r\n\r\n| Kind | Example |\r\n| --- | --- |\r\n| Unparsed Expressions | `{\"=\":\"foo.bar < 9\"}` |\r\n| Enum symbols<sup>3</sup> |  `{\"#\":\"asc\"}` |\r\n\r\n#### Remarks\r\n\r\n><sup>1</sup> This is as in JSON and shares the same issues when decimals are mapped to doubles with potential rounding errors. The same applies to Integer64. Use strings to avoid that, if applicable.\r\n>\r\n><sup>2</sup> Also, as in JSON, dates, and times are represented just as strings as specified in [ISO 8601][]; consumers are assumed to know the types and handle the values correctly.\r\n>\r\n><sup>3</sup> As enum symbols are equal to their values, it frequently suffices to just provide them as strings. Similar to time and dates in CSN and JSON, the consumers are assumed to know the types and handle the values correctly. The  `{\"#\":...}` syntax option is to serve cases where you have to distinguish the kind only based on the provided value, for example, in untyped annotations.\r\n\r\n\r\n\r\n\r\n\r\n## Definitions\r\n\r\nEach entry in the `definitions` dictionary is essentially a type definition. The name is the absolute, fully qualified name of the definition, and the value is a record with the definition details.\r\n\r\n\r\n#### Example\r\n\r\n```js\r\n({definitions:{\r\n  'Name':     {type:\"cds.String\"},\r\n  'Currency': {type:\"cds.String\", length:3},\r\n  'USD':      {type:\"Currency\"},\r\n  'Amount':   {elements:{\r\n    'value':    {type:\"cds.Decimal\", precision:11, scale:3},\r\n    'currency': {type:\"Currency\"},\r\n  }},\r\n  'SortOrder':{enum:{ 'asc':{}, 'desc':{} }}\r\n}})\r\n```\r\n\r\nThe __name__ of a definition is its key in the enclosing dictionary, like in `definitions` for top-level entries or in `elements` for structured types and entities.\r\n\r\nNames **must**:\r\n* Be nonempty strings.\r\n* Neither start, nor end with `.` or `::`.\r\n* Not contain substrings `..` or `:::`.\r\n* Not contain the substring `::` more than once.\r\n\r\n\r\n#### Properties\r\n\r\n* `kind` --- one of `context`, `service`, `entity`, `type`, `action`, `function`, or `annotation`\r\n* `type` --- an optional base type that this definition is derived from\r\n* [`elements`][elements] --- optional dictionary of [_elements_][elements] in case of structured types\r\n\r\nProperty `kind` is always omitted for [elements][] and can be omitted for top-level [type definitions](#type-definitions). These examples are semantically equivalent:\r\n\r\n```js\r\nFoo1 = { type:\"cds.String\" }\r\nFoo2 = { type:\"cds.String\", kind:\"type\" }\r\n```\r\n\r\n\r\n\r\n\r\n\r\n## Type Definitions\r\n\r\nCustom-defined types are entries in [`definitions`](#definitions) with an optional property `kind`=`\"type\"` and the following properties.\r\n\r\n| Property | Used for |\r\n| --- | --- |\r\n| `type` | [Scalar Types](#scalar-types), [Structured Types][struct], and [Associations](#associations) |\r\n| `elements` | [Structured Types][struct] |\r\n| `items` | [Arrayed Types][arrays] |\r\n| `enum` | [Enumeration Types][enum] |\r\n\r\n\r\n\r\n#### Example\r\n\r\n```js\r\n({definitions: {\r\n  'scalar.type': {type:\"cds.String\", length:3 },\r\n  'struct.type': {elements:{ 'foo': {type:\"cds.Integer\"}}},\r\n  'arrayed.type': {items:{type:\"cds.Integer\"}},\r\n  'enum.type':   {enum:{ 'asc':{}, 'desc':{} }}\r\n}})\r\n```\r\n\r\n#### Properties\r\n[kind]: #kind\r\n[type]: #type\r\n\r\n* `kind` --- omitted or _`\"type\"`_\r\n* `type` --- the base type, this definition is derived from\r\n* [`elements`][elements] --- optional element definitions for [_structured types_][struct].\r\n* [`items`][arrays] --- optional definition of item types for [_arrayed types_][arrays].\r\n* [`enum`][enum] --- an optional dictionary of enum members for [_enumeration types_][enum].\r\n* `value` --- a constant [literal value](#literals) or calculation expression\r\n* `default` --- a default [value or expression](#literals)\r\n* `localized` _= true_ if this type was declared like _foo : localized String_\r\n* `...` --- other type-specific properties, for example, a String's `length`\r\n\r\n\r\n\r\n### Scalar Types\r\n[scalar]: #scalar-types\r\n\r\nScalar types always have property `type` specified, plus optional type-specific parameter properties.\r\n\r\n```js\r\n({definitions:{\r\n  'scalar.type': {type:\"cds.String\", length:3 },\r\n}})\r\n```\r\n\r\nSee the [CDL reference docs]({{cap}}/cds/types) for an overview of CDS' built-in types.\r\n\r\nWhile in [CDS sources][CDL] you can refer to these types without prefix, they always have to be specified with their **fully qualified names in CSN**, for example:\r\n\r\n```js\r\n({definitions: {\r\n  'Foo': { type:\"cds.Integer\" },\r\n  'Bar': { type:\"cds.Decimal\", precision:11, scale:3 },\r\n}})\r\n```\r\n\r\n\r\n### Structured Types\r\n\r\n[struct]: #structured-types\r\n[elements]: #structured-types\r\n[Structured Types]: #structured-types\r\n\r\nStructured types are signified by the presence of an `elements` property. The value of `elements` is a dictionary of `elements`. The name is the local name of the element and the values in turn are [Type Definitions](#type-definitions).\r\n\r\nThe optional property `includes` contains a list of fully qualified entity-, aspect-, or type-names. Elements, actions, and annotations from those definitions are then copied into the structured type.\r\n\r\n```js\r\n({definitions:{\r\n  'structured.type': {elements:{\r\n    'foo': {type:\"cds.Integer\"},\r\n    'bar': {type:\"cds.String\"}\r\n  }}\r\n}})\r\n```\r\n\r\n\r\n### Arrayed Types\r\n[arrays]: #arrayed-types\r\n\r\nArrayed types are signified by the presence of a property `items`. The value of which is in turn a [type definition](#type-definitions) that specifies the arrayed items' type.\r\n\r\n```js\r\n({definitions:{\r\n  'arrayed.type': {items:{type:\"cds.Integer\"}}\r\n}})\r\n```\r\n\r\n\r\n### Enumeration Types\r\n[enum]: #enumeration-types\r\n\r\nThe `enum` property is a dictionary of enum member elements with the name being the enum symbol and the value being a [CQN literal value expression]({{cxn}}#literal-values). The literal expression optionally specifies a constant `val` as a [literal](#literals) plus optional annotations. An enumeration type can specify an explicit `type` (for example, _Decimal_) but can also omit it and refer from given enumeration values, or _String_ as default.\r\n\r\n```js\r\n({definitions:{\r\n  'Gender': {enum:{\r\n    'male':{},\r\n    'female':{}\r\n  }},\r\n  'Status': {enum:{\r\n    'submitted': {val:1},\r\n    'fulfilled': {val:2}\r\n  }},\r\n  'Rating': {type:\"cds.Decimal\", enum:{\r\n    'low':    {val:0},\r\n    'medium': {val:50},\r\n    'high':   {val:100}\r\n  }}\r\n}})\r\n```\r\n\r\n\r\n\r\n\r\n\r\n## Entity Definitions\r\n[entities]: #entity-definitions\r\n[entity]: #entity-definitions\r\n\r\nEntities are [structured types][struct] with **_kind_** =`'entity'`. In addition, one or more elements usually have property `key` set to true, to flag the entity's primary key.\r\n\r\n#### Example\r\n\r\n```js\r\n({definitions:{\r\n  'Products': {kind:\"entity\", elements:{\r\n    'ID':     {type:\"cds.Integer\", key:true},\r\n    'title':  {type:\"cds.String\", notNull:true},\r\n    'price':  {type:\"Amount\", virtual:true},\r\n  }}\r\n}})\r\n```\r\n\r\n#### Properties\r\n\r\n* `kind` --- is always _`\"entity\"`_\r\n* `elements` --- as in [Structured Types], optionally equipped with one or more of these boolean properties:\r\n  * `key` --- signifies that the element is (part of) the primary key\r\n  * `virtual` --- has this element ignored in generic persistence mapping\r\n  * `notNull` --- the _not null_ constraint as in SQL\r\n* `includes` --- as in [Structured Types]\r\n\r\n\r\n\r\n### View Definitions\r\n[views]: #view-definitions\r\n[view]: #view-definitions\r\n\r\nViews are entities defined as projections on underlying entities. In CSN, views are signified by the presence of property `query`, which captures the projection as a [CQN] expression.\r\n\r\n\r\n#### Example\r\n\r\n```js\r\n({definitions:{\r\n  'Foo': { kind:\"entity\", query: {\r\n    SELECT:{\r\n      from: {ref:['Bar']},\r\n      columns: [ {ref:['title']}, {ref:['price']} ]\r\n    }\r\n  }}\r\n}})\r\n```\r\n\r\n#### Properties\r\n\r\n* `kind` --- mandatory; always _`\"entity\"`_\r\n* `query` --- the parsed query in [CQN] format\r\n* `elements` --- optional [elements signature](#views-with-declared-signatures), omitted and inferred\r\n* `params` --- optional [parameters](#views-with-parameters)\r\n\r\n\r\n\r\n### Views with Declared Signatures\r\n\r\nViews with declared signatures have the additional property `elements` filled in as in [entities]:\r\n\r\n```js\r\n({definitions:{\r\n  'with.declared.signature': {kind:\"entity\",\r\n    elements: {\r\n      'title': {type:\"cds.String\"},\r\n      'price': {type:\"Amount\"}\r\n    },\r\n    query: { SELECT:{...} },\r\n  }\r\n}})\r\n```\r\n\r\n\r\n### Views with Parameters\r\n\r\nViews with parameters have an additional property `params` --- an optional dictionary of parameter [type definitions](#type-definitions):\r\n\r\n```js\r\n({definitions:{\r\n  'with.params': {kind:\"entity\",\r\n    params: { 'ID': { type: 'cds.Integer' } },\r\n    query: { SELECT:{...} },\r\n  }\r\n}})\r\n```\r\n\r\n\r\n\r\n\r\n\r\n## Associations\r\n\r\nAssociations are like [scalar type definitions][scalar] with `type` being `cds.Association` or `cds.Composition` plus additional properties specifying the association's `target` and optional information like `on` conditions or foreign `keys`.\r\n\r\n### Basic to-one Associations\r\n\r\nThe basic form of associations is *to-one* associations to a designated target:\r\n\r\n```js\r\n({definitions:{\r\n  'Books': { kind:\"entity\", elements:{\r\n    'author': { type:\"cds.Association\", target:\"Authors\" },\r\n  }},\r\n  //> an association type-def\r\n  'Currency': { type:\"cds.Association\", target:\"Currencies\" },\r\n}})\r\n```\r\n\r\n\r\n\r\n### Associations with specified `cardinality`\r\n\r\nAdd property `cardinality` to explicitly specify a *to-one* or *to-many* relationship:\r\n\r\n```js\r\n({definitions:{\r\n  'Authors': { kind:\"entity\", elements:{\r\n    'books': { type:\"cds.Association\", target:\"Books\", cardinality:{max:\"*\"} },\r\n  }},\r\n}})\r\n```\r\n\r\nProperty `cardinality` is an object `{src?,min?,max}`with...\r\n\r\n* `src` set to `1` give a hint to database optimizers, that a source entity always exists\r\n* `min` specifying the target's minimum cardinality --- default: 0\r\n* `max` specifying the target's maximum cardinality --- default: 1\r\n\r\nIn summary, the default cardinality is _[0..1,0..1]_, which means *to-one*.\r\n\r\n### Associations with Specified `on` Condition\r\n\r\nSo-called *unmanaged* associations have an explicitly specified `on` condition:\r\n\r\n```js\r\n({definitions:{\r\n  'Authors': { kind:\"entity\", elements:{\r\n    'books': { type:\"cds.Association\", target:\"Books\", cardinality{max:\"*\"},\r\n      on: [{ref:['books', 'author']}, '=', {ref:['$self']}]\r\n    },\r\n  }}\r\n }})\r\n```\r\n\r\n\r\n\r\n### Associations with specified `keys`\r\n\r\nManaged to-one associations automatically use the target's designated primary `key` elements. You can overrule this by explicitly specifying alternative target properties to be used in the `keys` property:\r\n\r\n```js\r\n({definitions:{\r\n  'Books': {kind:\"entity\", elements:{\r\n    'genre': {type:\"cds.Association\", target:\"Genres\", keys:[\r\n      {ref:[\"category\"], as:\"cat\"},\r\n      {ref:[\"name\"]},\r\n    ]},\r\n  }},\r\n}})\r\n```\r\n\r\nProperty `keys` has the format and mechanisms of [CQN projections]({{cqn}}#select).\r\n\r\n\r\n\r\n## Annotations\r\n\r\nAnnotations are represented as properties, prefixed with `@`.\r\nThis format applies to type/entity-level annotations as well as to element-level ones.\r\n\r\n#### Example\r\n\r\n```js\r\n({definitions:{\r\n  'Employees': {kind:\"entity\",\r\n    '@title':\"Mitarbeiter\",\r\n    '@readonly':true,\r\n    elements:{\r\n      'firstname': {type:\"cds.String\", '@title':\"Vorname\"},\r\n      'surname':   {type:\"cds.String\", '@title':\"Nachname\"},\r\n    }\r\n  },\r\n}})\r\n```\r\n\r\nAnnotations are used to add custom information to definitions, the prefixed `@` acts as a protection against conflicts with built-in/standard properties. They’re flat lists of key-value pairs, with keys being fully qualified property names and values being represented as introduced in the section [Literals and Expressions](#literals).\r\n\r\n\r\n\r\n\r\n\r\n## Aspects\r\n\r\nIn parsed-only models, the top-level property `extensions` holds an array of unapplied extensions or annotations (&rarr; see also [Aspects in CDL]({{cdl}}#aspects)). The entries are of this form:\r\n\r\n```js\r\next = { extend|annotate: <name>, <property>: <value>, … }\r\n```\r\n\r\nwith:\r\n\r\n- `extend` or `annotate` referring to the definition to be extended or annotated\r\n- `<property>` being the property that should be extended, for example, `elements` if an entity\r\n  should be extended with further elements\r\n\r\n\r\n\r\n### Extend with \\<named aspect\\>\r\n\r\nThe most basic form allows to express an extension of a named definition with another named definition (&rarr; see [Named Aspects]({{cdl}}#aspect)):\r\n\r\n```js\r\ncsn = { extensions:[\r\n  { extend:\"TargetDefinition\", includes:[\"NamedAspect\"]}\r\n]}\r\n```\r\n\r\n\r\n\r\n\r\n### Extend with \\<anonymous aspect\\>\r\n\r\nThe form `{ extend:<target>, <property>: <value>, … }` allows to add elements to an existing [struct] definition as well as to add or override annotations of the target definition:\r\n\r\n```js\r\ncsn = { extensions:[\r\n\r\n  // extend Foo with @foo { ..., bar: String; }\r\n  {\r\n    extend: \"Foo\",\r\n    '@foo': true,\r\n    elements: {\r\n      // adds a new element 'bar'\r\n      bar: { type: \"cds.String\", '@bar': true },\r\n    }\r\n  },\r\n\r\n]}\r\n```\r\n\r\n\r\n### annotate with \\<anonymous aspect\\>\r\n\r\nThe form `{ annotate:<target>, with:{...} }` allows to add or override annotations of the target definition as well as those of nested elements:\r\n\r\n```js\r\ncsn = {extensions:[\r\n\r\n  // annotate Foo with @foo;\r\n  { annotate:\"Foo\", '@foo':true },\r\n\r\n  // annotate Foo with @foo { boo @boo }\r\n  { annotate:\"Foo\", '@foo':true, elements: {\r\n    // annotates existing element 'boo'\r\n    boo: {'@boo':true },\r\n  }},\r\n\r\n]}\r\n```\r\n\r\n\r\n\r\n## Services\r\n\r\nServices are definitions with _kind =`'service'`_:\r\n\r\n```js\r\n({definitions:{\r\n  'MyOrders': {kind:\"service\"}\r\n}})\r\n```\r\n\r\n\r\n\r\n### Actions / Functions\r\n{: .h2}\r\n\r\nService definitions (for _unbound_ actions/functions) as well as entity definitions\r\n(for _bound_ actions/functions) can have an additional property `actions`.\r\nThe keys of these `actions` are the (local) names of actions/functions.\r\n\r\n\r\n#### Example\r\n\r\n```js\r\n({definitions:{\r\n  'MyOrders': {kind:\"service\", actions:{\r\n    'cancelOrder': {kind:\"action\",\r\n      params:{\r\n        'orderID': {type:\"cds.Integer\"},\r\n        'reason':  {type:\"cds.String\"},\r\n      },\r\n      returns: {elements:{\r\n        'ack': {enum:{ 'succeeded':{}, 'failed':{} }},\r\n        'msg': {type:\"cds.String\"},\r\n      }}\r\n    }\r\n  }}\r\n}})\r\n```\r\n\r\n#### Properties\r\n\r\n* `kind` --- either `'action'` or `'function'` as in _OData_\r\n* `params` --- a dictionary with the values being\r\n  [Type Definitions](#type-definitions)\r\n* `returns` --- a [Type Definition](#type-definitions)\r\n  describing the response\r\n\r\n> The definition of the response can be a reference to a declared type or the inline definition of a new (struct) type.\r\n\r\n\r\n\r\n\r\n\r\n## Imports\r\n\r\nThe `requires` property lists other models to import definitions from. \r\n\r\n#### Example\r\n\r\n```js\r\n({\r\n  requires:[ '@sap/cds/common', './db/schema' ],\r\n  ...\r\n})\r\n```\r\n\r\nAs in Node.js the filenames are either absolute module names or relative \r\nfilenames, starting with `./` or `../`.\r\n\r\n## i18n\r\nA CSN may optionally contain a top-level `i18n` property, which can contain translated texts. The expected structure is as follows:\r\n\r\n```js\r\n({\r\n  \"i18n\": {\r\n    \"language-key\": {\r\n      \"text-key\": \"some string\"\r\n    }\r\n  }\r\n})\r\n```\r\n\r\nThis data must be written and handled by the application, there’s no out-of-the-box support for this by CAP.\r\n"},{"name":"21-CQL.md","content":"---\r\nlayout: cds-ref\r\nshorty: Query Language\r\nsynopsis: >\r\n  Documents the CDS Query Language (aka CQL) which is an extension of the standard SQL SELECT statement.\r\npermalink: cds/cql\r\nstatus: released\r\nuacp: Used as link target from Help Portal at https://help.sap.com/viewer/65de2977205c403bbc107264b8eccf4b/Cloud/en-US/855e00bd559742a3b8276fbed4af1008.html\r\n---\r\n\r\n\r\n# Query Language (CQL)\r\n\r\nCDS QL is based on standard SQL, which it enhances by...\r\n\r\n{% include _toc levels=\"2,3\" %}\r\n{% include links.md %}\r\n\r\n## Postfix Projections\r\n\r\nCQL allows to put projections, that means, the `SELECT` clause, behind the `FROM` clause enclosed in curly braces. For example, the following are equivalent:\r\n\r\n```sql\r\nSELECT name, address.street from Authors;\r\n```\r\n```sql\r\nSELECT from Authors { name, address.street };\r\n```\r\n\r\n\r\n### Nested Expands\r\n{: .impl.concept}\r\n\r\nPostfix projections can be appended to any column referring to a struct element or an association and hence be nested.\r\nThis allows **expand** results along associations and hence read deeply structured documents:\r\n\r\n```sql\r\nSELECT from Authors {\r\n   name, address { street, town { name, country }}\r\n};\r\n```\r\n\r\nThis actually executes three correlated queries to authors, addresses, and towns and returns a structured result set like that:\r\n\r\n```js\r\nresults = [\r\n  {\r\n    name: 'Victor Hugo',\r\n    address: {\r\n      street: '6 Place des Vosges', town: {\r\n        name: 'Paris',\r\n        country: 'France'\r\n      }\r\n    }\r\n  }, {\r\n    name: 'Emily Brontë', ...\r\n  }, ...\r\n]\r\n```\r\n\r\n> This is rather a feature tailored to NoSQL databases and has no equivalent in standard SQL as it requires structured result sets. Some SQL vendors allow things like that with non-scalar subqueries in SELECT clauses.\r\n\r\n\r\n### Nested Inlines\r\n{: .impl.concept}\r\n\r\nPut a **`\".\"`** before the opening brace to **inline** the target elements and avoid writing lengthy lists of paths to read several elements from the same target. For example:\r\n\r\n```sql\r\nSELECT from Authors {\r\n   name, address.{ street, town.{ name, country }}\r\n};\r\n```\r\n\r\n... is equivalent to:\r\n\r\n```sql\r\nSELECT from Authors {\r\n  name,\r\n  address.street,\r\n  address.town.name,\r\n  address.town.country\r\n};\r\n```\r\n\r\n\r\n### Smart `*` Selector\r\n\r\nWithin postfix projections, the `*` operator queries are handled slightly different than in plain SQL select clauses.\r\n\r\n#### Example:\r\n\r\n```swift\r\nSELECT from Books { *, author.name as author }\r\n```\r\n\r\n Queries like in our example, would result in duplicate element effects for `author` in SQL, while in CQL explicitly defined columns following a `*` replaces equally named columns inferred before.\r\n\r\n\r\n\r\n## Path Expressions\r\n\r\nUse path expressions to navigate along associations and/or struct elements in any of the SQL clauses as follows:\r\n\r\n* In `from` clauses:\r\n\r\n```sql\r\nSELECT from Authors[name='Emily Brontë'].books;\r\nSELECT from Books:authors.towns;\r\n```\r\n\r\n* In `select` clauses:\r\n\r\n```sql\r\nSELECT title, author.name from Books;\r\nSELECT *, author.address.town.name from Books;\r\n\r\n```\r\n* In `where` clauses:\r\n\r\n```sql\r\nSELECT from Books where author.name='Emily Brontë';\r\n\r\n```\r\n* The same is valid for `group by`, `having`, and `order by`.\r\n\r\n\r\n### Path Expressions in `from` Clauses\r\n\r\nPath expressions in from clauses allow to fetch only those entries from a target entity, which are associated to a parent entity. They unfold to _SEMI JOINS_ in plain SQL queries. For example, the previous mentioned queries would unfold to the following plain SQL counterparts:\r\n\r\n```sql\r\nSELECT * from Books WHERE EXISTS (\r\n  SELECT 1 from Authors WHERE Authors.ID = Books.author_ID\r\n    AND Authors.name='Emily Brontë'\r\n);\r\n```\r\n```sql\r\nSELECT * from Towns WHERE EXISTS (\r\n  SELECT 1 from Authors WHERE Authors.town_ID = Towns.ID AND EXISTS (\r\n    SELECT 1 from Books WHERE Books.author_ID = Authors.ID\r\n  )\r\n);\r\n```\r\n\r\n### Path Expressions in All Other Clauses\r\n\r\nPath expressions in all other clauses are very much like standard SQL's column expressions with table aliases as single prefixes. CQL essentially extends the standard behavior to paths with multiple prefixes, each resolving to a table alias from a corresponding `LEFT OUTER JOIN`. For example, the path expressions in the previous mentioned queries would unfold to the following plain SQL queries:\r\n\r\n```sql\r\nSELECT Books.title, author.name from Books\r\nLEFT JOIN Authors author ON author.ID = Books.author_ID;\r\n```\r\n```sql\r\nSELECT Books.*, author_address_town.name from Books\r\nLEFT JOIN Authors author ON author.ID = Books.author_ID\r\nLEFT JOIN Addresses author_address ON author_address.ID = author.address_ID\r\nLEFT JOIN Towns author_address_town ON author_address_town.ID = author_address.town_ID;\r\n```\r\n```sql\r\nSELECT Books.* from Books\r\nLEFT JOIN Authors author ON author.ID = Books.author_ID\r\nWHERE author.name='Emily Brontë'\r\n```\r\n\r\nAll column references get qualified &rarr; in contrast to plain SQL joins there’s no risk of ambiguous or conflicting column names.\r\n{:.tip}\r\n\r\n### With Infix Filters\r\n\r\nAppend infix filters to associations in path expressions to narrow the resulting joins. For example:\r\n\r\n```sql\r\nSELECT books[genre='Mystery'].title from Authors\r\n WHERE name='Agatha Christie'\r\n```\r\n\r\n... unfolds to:\r\n```sql\r\nSELECT books.title from Authors\r\nLEFT JOIN Books books ON ( books.author_ID = Authors.ID )\r\n  AND ( books.genre = 'Mystery' )  --> from Infix Filter\r\nWHERE Authors.name='Agatha Christie';\r\n```\r\n\r\n### Exists Predicate\r\n{:.impl.concept}\r\n\r\nUse a filtered path expression to test if any element of the associated collection matches the given filter:\r\n\r\n```sql\r\nSELECT FROM Authors {name} WHERE EXISTS books[year = 2000]\r\n```\r\n\r\n...unfolds to:\r\n```sql\r\nSELECT name\r\nFROM Authors a\r\nWHERE EXISTS (\r\n        SELECT 1\r\n        FROM Books b\r\n        WHERE b.author_id = a.id\r\n            AND b.year = 2000\r\n    )\r\n```\r\n\r\n## CDL-Style Casts\r\n\r\nInstead of SQL-style type casts you can alternatively use [CDL]-style casts, that means, as in the element of an entity definition.\r\nFor example, the following statements are equivalent:\r\n\r\n```sql\r\nSELECT cast (foo+1 as Decimal) as bar from Foo;  -- standard SQL\r\nSELECT from Foo { foo+1 as bar : Decimal };      -- CDL-style\r\n```\r\n[learn more about CDL type definitions]({{cdl}}#types){:.learn-more}\r\n\r\nSQL-style type casts aren’t yet supported.\r\n{:.tip}\r\n\r\n## Excluding Clause\r\n\r\nUse the `excluding` clause in combination with `SELECT *` to select all elements except for the ones listed in the exclude list.\r\n\r\n```swift\r\nSELECT from Books { * } excluding { author }\r\n```\r\n\r\nThe effect is about **late materialization** of signatures and staying open to late extensions.\r\nFor example assume the following definitions:\r\n\r\n```swift\r\nentity Foo { foo : String; bar : String; car : String; }\r\nentity Bar as SELECT from Foo excluding { bar };\r\nentity Boo as SELECT from Foo { foo, car };\r\n```\r\n\r\nA `SELECT * from Bar` would result into the same as a query of `Boo`:\r\n\r\n```sql\r\nSELECT * from Bar --> { foo, car }\r\nSELECT * from Boo --> { foo, car }\r\n```\r\n\r\nNow, assume a consumer of that package extends the definitions as follows:\r\n\r\n```swift\r\nextend Foo with { boo : String; }\r\n```\r\n\r\nWith that, queries on `Bar` and `Boo` would return different results:\r\n\r\n```sql\r\nSELECT * from Bar --> { foo, car, boo }\r\nSELECT * from Boo --> { foo, car }\r\n```\r\n\r\n\r\n## Query-Local Mixins\r\n\r\nUse the `mixin...into` clause to logically add unmanaged associations to the source of the query, which you can use and propagate in the query's projection. This is only supported in postfix notation.\r\n\r\n```sql\r\nSELECT from Books mixin {\r\n  localized : Association to LocalizedBooks on localized.ID = ID;\r\n} into {\r\n  ID, localized.title\r\n};\r\n```\r\n"},{"name":"31-Types.md","content":"---\r\nlayout: cds-ref\r\nshorty: Built-in Types\r\nsynopsis: >\r\n  Find here a brief overview of the predefined types shipped with CDS.\r\npermalink: cds/types\r\nstatus: released\r\n---\r\n\r\n\r\n# Built-in Types\r\n\r\n{% include links.md %}\r\n\r\nThe following built-in types are provided:\r\n\r\n\r\n| CDS Type | Arguments / Remarks | Example Value | SQL <sup>(5)</sup> |\r\n| --- | --- | ---  | --- |\r\n| `UUID` | an opaque 36-characters string <sup>(1)</sup> | `'be071623-8699-4106-b6fa-8e3cb04c261e'`| _NVARCHAR(36)_  |\r\n| `Boolean` | | `true` | _BOOLEAN_  |\r\n| `Integer` | | `1337` | _INTEGER_  |\r\n| `Integer64` | | `1337` | _BIGINT_  |\r\n| `Decimal` | ( `precision`, `scale` ) <sup>(2)</sup> | `15.2` | _DECIMAL_  |\r\n| `Double` | | `15.2` | _DOUBLE_  |\r\n| `Date` | | `'2021-06-27'` | _DATE_  |\r\n| `Time` | | `'07:59:59'` | _TIME_  |\r\n| `DateTime` | _sec_ precision | `'2021-06-27T14:52:23Z'` | _TIMESTAMP_  |\r\n| `Timestamp` | 0.1 _µs_ precision <sup>(3)</sup> | `'2021-06-27T14:52:23.123Z'` |  _TIMESTAMP_  |\r\n| `String` | ( `length` ) <sup>(4)</sup> | `'hello world'` | _NVARCHAR_  |\r\n| `Binary` | ( `length` ) <sup>(4)</sup> | |  _VARBINARY_  |\r\n| `LargeBinary` |  | | _BLOB_  |\r\n| `LargeString` |  | `'hello world'` | _NCLOB_  |\r\n\r\n\r\n### Remarks\r\n\r\n\r\n> <sup>(1)</sup> At runtime, UUIDs are treated as opaque values and are, for example, not converted to lower case on input. UUIDs generated in the application are [RFC 4122](https://tools.ietf.org/html/rfc4122)-compliant. See [Don't Interpret UUIDs!]({{cap}}/guides/domain-models#dont-interpret-uuids) for details.\r\n\r\n> <sup>(2)</sup> Arguments `precision` and `scale` are optional → if omitted a *decfloat* type is used\r\n\r\n> <sup>(3)</sup> Up to 7 digits of fractional seconds; if a data is given with higher precision truncation may occur\r\n\r\n> <sup>(4)</sup> Argument `length` is optional → use options `cds.cdsc.defaultStringLength` and `cds.cdsc.defaultBinaryLength` to control the project-specific default length used for OData and SQL backends. If not set, the global default length 5000 is used for SQL backends.\r\n\r\n> <sup>(5)</sup> Mapping to ANSI SQL types are given for comparison. Note though, that you need to have the specification of your target database in mind when considering, for example, length restrictions.\r\n\r\n\r\n### See also...\r\n\r\n[**Mapping to OData EDM types**]({{cap}}/advanced/odata#type-mapping){:.learn-more}\r\n\r\n[**HANA-native Data Types**]({{cap}}/advanced/hana#hana-types){:.learn-more}"},{"name":"33-common.cds.md","content":"---\r\nlayout: cds-ref\r\nshorty: \\@sap/cds/common\r\nsynopsis: >\r\n  Introduces _@sap/cds/common_ a prebuilt CDS model shipped with `@sap/cds` that provides common types and aspects.\r\npermalink: cds/common\r\nstatus: released\r\nuacp: Used as link target from Help Portal at https://help.sap.com/viewer/65de2977205c403bbc107264b8eccf4b/Cloud/en-US/855e00bd559742a3b8276fbed4af1008.html\r\n---\r\n\r\n# Common Types & Aspects\r\n_@sap/cds/common_\r\n{:.subtitle}\r\n\r\nCDS ships with a prebuilt model _@sap/cds/common_ that provides common types and aspects.\r\n\r\n#### Content\r\n{% include _toc levels=\"2,3\" %}\r\n{% include links.md %}\r\n\r\n[ISO 3166]: https://en.wikipedia.org/wiki/ISO_3166\r\n[ISO 3166-1]: https://en.wikipedia.org/wiki/ISO_3166-1\r\n[ISO 3166-2]: https://en.wikipedia.org/wiki/ISO_3166-2\r\n[ISO 3166-3]: https://en.wikipedia.org/wiki/ISO_3166-3\r\n[ISO 4217]: https://en.wikipedia.org/wiki/ISO_4217\r\n[ISO/IEC 15897]: https://en.wikipedia.org/wiki/ISO/IEC_15897\r\n\r\n\r\n## Why Use _@sap/cds/common_?\r\n\r\nIt’s recommended that all applications use the common types and aspects provided through _@sap/cds/common_ to benefit from these features:\r\n\r\n* **Concise** and **comprehensible** models &rarr; see also [Conceptual Modeling](../guides/domain-models#conceptual-modeling)\r\n* **Foster interoperability** between all applications\r\n* **Proven best practices** captured from real applications\r\n* **Streamlined** data models with **minimal entry barriers**\r\n* **Optimized** implementations and runtime performance\r\n* **Automatic** support for [localized] code lists and value helps\r\n* **Extensibility** using [Aspects](../guides/domain-models#aspects)\r\n* **Verticalization** through third-party extension packages\r\n\r\nFor example, usage is as simple as indicated in the following sample:\r\n\r\n```swift\r\nusing { Country } from '@sap/cds/common';\r\nentity Addresses {\r\n  street  : String;\r\n  town    : String;\r\n  country : Country; //> using reuse type\r\n}\r\n```\r\n\r\n### Outcome = Optimized Best Practice\r\n\r\nThe final outcomes in terms of modeling patterns, persistence structures, and implementations is essentially the same as with native means, if you would have collected design experiences from prior solutions, such as we did.\r\n\r\nAll the common reuse features of _@sap/cds/common_ are provided only through this ~100 line .cds model. Additional runtime support isn't required. _@sap/cds/common_ merely uses basic CDS modeling features as well as generic features like [localized data] and [temporal data] (which only need minimal runtime support with minimal overhead).\r\n{:.tip}\r\n\r\nIn effect, the results are **straightforward**, capturing **best practices** we learned from real business applications, with **minimal footprint**, **optimized performance**, and **maximized adaptability** and **extensibility**.\r\n\r\n\r\n## Common Reuse Aspects\r\n\r\n_@sap/cds/common_ defines the following [aspects] for use in your entity definitions. They give you shortcuts, for concise and comprehensible models, interoperability and out-of-the-box runtime features connected to them.\r\n\r\n\r\n### Aspect `cuid`\r\n\r\nUse `cuid` as a convenient shortcut, to add canonical, universally unique primary keys to your entity definitions. These examples are equivalent:\r\n\r\n```swift\r\nentity Foo : cuid {...}\r\n```\r\n\r\n\r\n```swift\r\nentity Foo {\r\n  key ID : UUID;\r\n  ...\r\n}\r\n```\r\n\r\n> The service provider runtimes automatically fill in UUID-typed keys like these with auto-generated UUIDs.\r\n\r\n[Learn more about **canonical keys** and **UUIDs**.](../guides/domain-models#use-canonic-primary-keys){: .learn-more}\r\n\r\n\r\n### Aspect `managed`\r\n\r\nUse `managed`, to add four elements to capture _created by/at_ and latest _modified by/at_ management information for records. The following examples are equivalent-\r\n\r\n```swift\r\nentity Foo : managed {...}\r\n```\r\n\r\n\r\n```swift\r\nentity Foo {\r\n  createdAt  : Timestamp @cds.on.insert : $now;\r\n  createdBy  : User      @cds.on.insert : $user;\r\n  modifiedAt : Timestamp @cds.on.insert : $now  @cds.on.update : $now;\r\n  modifiedBy : User      @cds.on.insert : $user @cds.on.update : $user;\r\n  ...\r\n}\r\n```\r\n\r\n`modifiedAt` and `modifiedBy` are set whenever the respective row was modified, that means, also during `CREATE` operations.\r\n{:.tip}\r\n\r\nThe annotations `@cds.on.insert/update` are handled in generic service providers so to fill-in those fields automatically.\r\n\r\n[Learn more about **generic service features**.](../guides/providing-services#managed-data){: .learn-more}\r\n\r\n\r\n### Aspect `temporal`\r\n\r\nThis aspect basically adds two canonical elements, `validFrom` and `validTo` to an entity. It also adds a tag annotation that connects the CDS compiler's and runtime's built-in support for _[Temporal Data]_. This built-in support covers handling date-effective records and time slices, including time travel. All you have to do is, add the temporal aspect to respective entities as follows:\r\n\r\n```swift\r\nentity Contract : temporal {...}\r\n```\r\n\r\n[Learn more about **temporal data**.][temporal data]{: .learn-more}\r\n\r\n\r\n## Common Reuse Types\r\n{:#code-types}\r\n\r\n_@sap/cds/common_ provides predefined easy-to-use types for _Countries_, _Currencies_, and _Languages_. Use these in all applications to foster interoperability.\r\n\r\n### Type `Country`\r\n[`Country`]: #country\r\n\r\nThe reuse type `Country` is defined in _@sap/cds/common_ as a simple managed [Association] to the [code list](#code-lists) for countries as follows:\r\n\r\n```swift\r\ntype Country : Association to sap.common.Countries;\r\n```\r\n\r\nHere's an example of how you would use that reuse type:\r\n\r\n{% include _code sample='using-country-type.cds' %}\r\n\r\nThe [code lists](#code-lists) define a key element `code`, which results in a foreign key column `country_code` in your SQL table for Addresses. For example:\r\n\r\n{% include _code sample='using-country-type.sql' %}\r\n\r\n[Learn more about **managed associations**.][Associations]{: .learn-more}\r\n\r\n\r\n### Type `Currency`\r\n\r\n```swift\r\ntype Currency : Association to sap.common.Currencies;\r\n```\r\n\r\n[It’s the same as for `Country`.](#type-country){: .learn-more}\r\n\r\n### Type `Language`\r\n\r\n```swift\r\ntype Language : Association to sap.common.Languages;\r\n```\r\n\r\n[It’s the same as for `Country`.](#type-country){: .learn-more}\r\n\r\n\r\n## Common Code Lists\r\n{: #code-lists}\r\n\r\nAs seen in the previous section, the reuse types `Country`, `Currency`, and `Language` are defined as associations to respective code list entities. They act as code list tables for respective elements in your domain model.\r\n\r\n> You rarely have to refer to the code lists in consuming models, but always only do so transitively by using the corresponding reuse types [as shown above](#code-types).\r\n\r\n\r\n### Aspect `sap.common.CodeList`\r\n\r\nThis is the base definition for the three code list entities in _@sap/cds/common_. It can also be used for your own code lists.\r\n\r\n```swift\r\naspect sap.common.CodeList {\r\n  name  : localized String(111);\r\n  descr : localized String(1111);\r\n}\r\n```\r\n[Learn more about **localized** keyword.][localized]{: .learn-more}\r\n\r\n\r\n### Entity `sap.common.Countries`\r\n\r\nThe code list entity for countries is meant to be used with **[ISO 3166-1] two-letter alpha codes** as primary keys. For example, `'GB'` for the United Kingdom. Nevertheless, it's defined as `String(3)` to allow you to fill in three-letter codes, if needed.\r\n\r\n```swift\r\nentity sap.common.Countries : CodeList {\r\n  key code : String(3); //> ISO 3166-1 alpha-2 codes (or alpha-3)\r\n}\r\n```\r\n\r\n\r\n### Entity `sap.common.Currencies`\r\n\r\nThe code list entity for currencies is meant to be used with **[ISO 4217] three-letter alpha codes** as primary keys, for example, `'USD'` for US Dollar. In addition, it provides an element to hold common currency symbols.\r\n\r\n```swift\r\nentity sap.common.Currencies : CodeList {\r\n  key code : String(3); //> ISO 4217 alpha-3 codes\r\n  symbol : String(2); //> for example, $, €, £, ₪, ...\r\n}\r\n```\r\n\r\n\r\n### Entity `sap.common.Languages`\r\n\r\nThe code list entity for countries is meant to be used with POSIX locales as defined in **[ISO/IEC 15897]** as primary keys. For example, `'en_GB'` for British English.\r\n\r\n```swift\r\nentity sap.common.Languages : CodeList {\r\n  key code : String(5); //> for example, en_GB\r\n}\r\n```\r\n[Learn more on **normalized locales**.](../guides/i18n#normalized-locales){: .learn-more}\r\n\r\n\r\n### SQL Persistence\r\n\r\nThe following table definition represents the resulting SQL persistence of the countries code list:\r\n\r\n{% include _code sample='sap-common-countries.sql' label='none' %}\r\n\r\n\r\n### SQL Persistence and Localized Texts\r\n\r\nIn addition, the generic [localized data] support triggered through the `localized` keyword adds these additional tables and views to efficiently deal with translations:\r\n\r\n{% include _code sample='sap-common-countries_texts.sql' label='none' %}\r\n{% include _code sample='sap-common-countries_localized.sql' label='none' %}\r\n\r\n[Learn more about **localized data**.][localized data]{: .learn-more}\r\n\r\n\r\n### Minimalistic Design by Intent\r\n{:label=none}\r\n{: #minimalistic-design-by-intend}\r\n\r\nThe models for code lists are intentionally minimalistic to keep the entry barriers as low as possible, focusing on the bare minimum of what all applications generally need: a unique code and localizable fields for name and full name or descriptions.\r\n\r\n**ISO alpha codes** for languages, countries, and currencies were chosen because they:\r\n\r\n1. Are most common (most projects would choose that)\r\n2. Are most efficient (as these codes are also frequently displayed on UIs)\r\n3. Guarantee minimal entry barriers (bringing about 1 above)\r\n4. Guarantee best support (for example, by readable foreign keys)\r\n\r\nAssumption is that ~80% of all apps don't need more than what is already covered in this minimalistic model. Yet, in case you need more, you can easily leverage CDS standard features to adapt and extend these base models to your needs as demonstrated in the section [Adapting to your needs](#adapting-to-your-needs).\r\n\r\n\r\n## Providing Initial Data\r\n\r\nTo fill code lists with data, a business application would frequently connect to and use _[Business Configuration]_ services. This allows customers to adjust the data for code lists individually. Alternatively or in addition, you can also provide initial data for the code lists by placing CSV files in a folder called `csv` next to your data models.\r\n\r\nThe following is an example of a `csv` file to provide data for countries:\r\n\r\n{% include _code sample='db/csv/sap.common-Countries.csv' %}\r\n\r\n[Learn more about **Providing Initial Data**.](../guides/databases#providing-initial-data){: .learn-more}\r\n\r\n\r\n### Add Translated Texts\r\n\r\nIn addition, you can provide translations for the `sap.common.Countries_texts` table as follows:\r\n\r\n{% include _code sample='db/csv/sap.common-Countries_texts.csv' %}\r\n\r\n[Learn more about **Localization/i18n**.][localization]{: .learn-more}\r\n\r\n\r\n### Using Tools like Excel\r\n\r\nYou can use Excel or similar tools to maintain these files. For example, the following screenshot shows how we maintained the above two files in Numbers on a Mac:\r\n\r\n![csv in numbers](assets/csv-numbers.png)\r\n\r\n\r\n## Adapting to Your Needs\r\n\r\nAs stated, the predefined definitions are minimalistic by intent. Yet, as _@sap/cds/common_ is also just a CDS model, you can apply all the standard features provided by [CDS][CDL], especially CDS' [Aspects] to adapt, and extend these definitions to your needs.\r\n\r\nLet's look at a few examples of what could be done. You can combine these extensions in an effective model.\r\n\r\nYou can do such extensions in the models of your project. You can also collect your extensions into reuse packages and share them as common definitions with several consuming projects, similar to _@sap/cds/common_ itself.\r\n{:.tip}\r\n\r\n[Learn more about providing reuse packages.]({{cap}}/guides/reuse-and-compose){: .learn-more}\r\n\r\n\r\n### Adding Detailed Fields as of [ISO 3166-1]\r\n\r\n{% include _code sample='your-common.1.cds' %}\r\n\r\n> Value lists in SAP Fiori automatically search in the new text fields as well.\r\n\r\n\r\n### Protecting Certain Entries\r\n\r\nSome application logic might have to be hard-coded against certain entries in code lists. Therefore, these entries have to be protected against changes and removal. For example, let's assume a code list for payment methods defined as follows:\r\n\r\n```swift\r\nentity PaymentMethods : sap.common.CodeList {\r\n  code : String(11);\r\n}\r\n```\r\n\r\nLet's further assume the entires with code `Main` and `Travel` are required by implementations and hence must not be changed or removed. Have a look at a couple of solutions.\r\n\r\n\r\n#### Generic Solution\r\n{:.impl.concept}\r\n\r\nOne option is to add an [automatic validation](../guides/providing-services#input-validation) based on certain annotations. For example:\r\n\r\n```swift\r\nannotate PaymentMethods {\r\n  code @assert.nottouched: ['Main','Travel'];\r\n}\r\n```\r\n\r\nHowever, the generic logic behind this validation isn’t trivial and an implementation is pending.\r\n\r\n\r\n#### Programmatic Solution\r\n\r\nA fallback, and at the same time, the most open, and most flexible approach, is to use a custom handler to assert that. For example, in Node.js:\r\n\r\n```js\r\nsrv.on ('DELETE', 'PaymentMethods', req=>{\r\n  const entry = req.query.DELETE.where[2].val\r\n  if (['Main','Travel'].includes(entry))\r\n    return req.reject(403, 'these entries must not be deleted')\r\n})\r\n```\r\n\r\n\r\n### Using Different Foreign Keys\r\n\r\nLet's assume you prefer to have references to the latest code list entries without adjusting foreign keys. This can be achieved by adding and using numeric ISO codes for foreign keys instead of the alpha codes.\r\n\r\n{% include _code sample='your-common.2.cds' %}\r\n\r\nYou can use your own definition of `Country` instead of the one from _@sap/cds/common_ in your models as follows:\r\n\r\n{% include _code sample='using-numcodes.cds' %}\r\n\r\n\r\n### Mapping to SAP S/4HANA or ABAP Table Signatures\r\n\r\n{% include _code sample='your-common.3.cds' %}\r\n\r\nThese views are updatable on SAP HANA and many other databases. You can also use CDS to expose them through corresponding OData services in order to facilitate integration with SAP S/4HANA or older ABAP backends.\r\n\r\n\r\n## Adding Own Code Lists\r\n\r\nAs another example of adaptations, let's add support for subdivisions, that means regions, as of [ISO 3166-2] to countries.\r\n\r\n\r\n### Defining a New Code List Entity\r\n\r\n{% include _code sample='your-common.4.1.cds' %}\r\n\r\n`Regions` is a new, custom-defined code list entity defined in the same way as the predefined ones in _@sap/cds/common_. In particular, it inherits all elements and annotations from the base definition [`sap.common.CodeList`](#code-lists). For example, the `@cds.autoexpose` annotation, which provides that `Regions` is auto-exposed in any OData service that has exposed entities with associations to it. The localization of the predefined elements `name` and `descr` is also inherited.\r\n\r\n\r\n### Defining a New Reuse Type\r\n\r\nFollowing the pattern for codes in _@sap/cds/common_ a bit more, you can also define a reuse type for regions as a managed association:\r\n\r\n{% include _code sample='your-common.4.2.cds' %}\r\n\r\n\r\n### Using the New Reuse Type and Code List\r\n\r\nThis finally allows you to add respective elements, the same way you do it with predefined reuse types. These elements receive the same support from built-in generic features. For example:\r\n\r\n{% include _code sample='using-region-type.cds' %}\r\n\r\n\r\n## Code Lists with Validity\r\n\r\nEven ISO codes may change over time and you may have to react to that in your applications. For example, when Burma was renamed to Myanmar in 1989. Let's investigate strategies on how that can be updated in our code lists.\r\n\r\n\r\n### Accommodating Changes\r\n\r\nThe renaming from Burma to Myanmar in 1989, was reflected in [ISO 3166] as follows (_the alpha-4 codes as specified in [ISO 3166-3] signify entries officially deleted from [ISO 3166-1] code lists_):\r\n\r\n| Name | Alpha-2 | Alpha-3 | Alpha-4 | Numeric |\r\n| --- | --- | --- | --- | --- |\r\n| Burma | BU | BUR | BUMM | 104\t|\r\n| Myanmar | MM | MMR | | 104\t|\r\n\r\nBy default, and with the given default definitions in _@sap/cds/common_, this would have been reflected as a new entry for Myanmar and you'd have the following choices on what to do with the existing records in your data:\r\n\r\n* **(a)** adjust foreign keys for records so that it always reflects the current state\r\n* **(b)** keep foreign keys as is for cases where the old records reflect the state effective at the time they were created or valid\r\n\r\n\r\n### Exclude Outdated Entries from Pick Lists (Optional)\r\n\r\nAlthough outdated entries like the one for Burma have to remain in the code lists as targets for references from historic records in other entities, you would certainly want to exclude it from all pick lists used in UIs when entering new data. This is how you could achieve that:\r\n\r\n\r\n#### 1. Extend the Common Code List Entity\r\n\r\n```swift\r\nusing { sap.common.Countries } from '@sap/cds/common';\r\nextend Countries with { validFrom: Date; validTo: Date; }\r\n```\r\n\r\n\r\n#### 2. Fill Validity Boundaries in Code Lists:\r\n\r\n| code | name | validFrom | validTo |\r\n| --- | --- | --- | --- | --- |\r\n| BU | Burma | | 1989-06-18 |\r\n| MM | Myanmar | 1989-06-18 |\r\n\r\n\r\n#### 3. Add Custom Handlers to Narrow Queries\r\n\r\n```js\r\nsrv.before ('READ','sap_common_Countries', req => {\r\n  req.query.where ('current_date between validFrom and validTo')\r\n})\r\n```\r\n"}]},{"name":"04-Elements-Types-.md","content":"\r\n## Elements, Types\r\n{: #elements-types}\r\n\r\n<!-- TOC depthFrom:3 depthTo:3 -->\r\n\r\n- [pre-defined types](#pre-defined-types)\r\n- [custom-defined types](#custom-defined-types)\r\n- [struct elements](#struct-elements)\r\n- [enums](#enums)\r\n- [calculated fields](#calculated-fields)\r\n- [virtual elements](#virtual-elements)\r\n- [element constraints](#element-constraints)\r\n\r\n<!-- /TOC -->\r\n\r\n\r\n\r\n### pre-defined types\r\n\r\n\r\nThe following built-in types are provided.\r\nMapping to ANSI SQL types and to [_Edm._ types](http://docs.oasis-open.org/odata/odata/v4.0/errata03/os/complete/part3-csdl/odata-v4.0-errata03-os-part3-csdl-complete.html#_Toc453752517) given for comparison.\r\n\r\n| CDS Type | Arguments / Remarks | SQL | OData (v4) |\r\n| --- | --- | ---  | --- |\r\n| `UUID` | a 36-characters string | _varchar(36)_  | _Edm.Guid_ <sup>(1)</sup> |\r\n| `Boolean` | | _boolean_  | _Edm.Boolean_ |\r\n| `Integer` | | _integer_  | _Edm.Int32_ |\r\n| `Integer64` | | _bigint_  | _Edm.Int64_ |\r\n| `Decimal` | ( `precision`, `scale` ) | _decimal_  | _Edm.Decimal_ |\r\n| `DecimalFloat` | | _decimal_  | _Edm.Decimal_ |\r\n| `Double` | | _double_  | _Edm.Double_ |\r\n| `Date` | | _datetime_  | _Edm.Date_ <sup>(2)</sup> |\r\n| `Time` | | _datetime_  | _Edm.TimeOfDay_ <sup>(3)</sup> |\r\n| `DateTime` | _sec_ precision | _datetime_  | _Edm.DateTimeOffset_ <sup>(4)</sup> |\r\n| `Timestamp` | _µs_ precision | _timestamp_  | _Edm.DateTimeOffset_ <sup>(4)</sup> |\r\n| `String` | ( `length` ) | _nvarchar_  | _Edm.String_ |\r\n| `Binary` | ( `length` ) | _varbinary_  | _Edm.Binary_ |\r\n| `LargeString` |  | _NCLOB_  | _Edm.String_ |\r\n| `LargeBinary` |  | _BLOB_  | _Edm.Binary_ |\r\n\r\n> <sup>(1)</sup> Mapping can be changed with e.g. `@odata.Type='Edm.String'` <br>\r\n> <sup>(2)</sup> OData v2: _Edm.DateTime_ with `sap:display-format=\"Date\"` <br>\r\n> <sup>(3)</sup> OData v2: _Edm.Time_ <br>\r\n> <sup>(4)</sup> OData v2: _Edm.DateTime_ <br>\r\n\r\n\r\n### custom-defined types\r\n\r\nYou can declare custom types to reuse later on, e.g. for elements in entity definitions.\r\n\r\n```swift\r\ntype User : String(111);\r\ntype Amount {\r\n  value : Decimal(10,3);\r\n  currency : Currency;\r\n}\r\ntype Currency : Association to Currencies;\r\n\r\nentity Order {\r\n  buyer : User;\r\n  price : Amount;\r\n}\r\n```\r\n\r\n\r\n### struct elements\r\n\r\nElements can be specified with anonymous inline struct types.\r\n\r\n```swift\r\nentity Order {\r\n  buyer : String(111);\r\n  price {\r\n    value : Decimal(10,3);\r\n    currency : Currency;\r\n  };\r\n}\r\n```\r\n\r\n### enums\r\n\r\nYou can specify enumeration values for a type as a semicolon-delimited list of symbols.\r\nFor type `String`, declaration of actual values is optional; if omitted, the actual values then are the string counterparts of the symbols.\r\n\r\n```swift\r\ntype Gender : String enum { male; female; }\r\nentity Order {\r\n  status : Integer enum {\r\n    submitted = 1;\r\n    fulfilled = 2;\r\n    shipped = 3;\r\n    canceled = -1;\r\n  };\r\n}\r\n```\r\n\r\n### calculated fields\r\n{: .impl.concept}\r\n\r\nElements can be specified with a calculation expression in which you can refer to other\r\nelements of the same entity.\r\n\r\n```swift\r\nentity Employees {\r\n  addresses : Association of many Addresses;\r\n  homeAddress = addresses [kind='home'];\r\n}\r\n```\r\n\r\n\r\n\r\n### virtual elements\r\n\r\nAn element definiton can be prefixed with modifier keyword `virtual` to indicate that\r\nthis element shall not be added to persistent artifacts, i.e. tables or views in\r\nSQL databases. The reason to declare virtual elements is to be able to add metadata.\r\n\r\n```swift\r\nentity Employees {\r\n  ...\r\n  virtual something : String(11);\r\n}\r\n```\r\n\r\n\r\n### element constraints\r\n\r\nElement definitons can be augmented with constraints `unique` and `not null` as known from SQL.\r\n\r\n```swift\r\nentity Employees {\r\n  name : String(111) unique not null;\r\n}\r\n```\r\n\r\n> Note: `unique` is not yet available.\r\n\r\n<br>\r\n"},{"name":"05-Associations-.md","content":"\r\n## Associations\r\n\r\nAssociations capture relationships between entities. They are like forward-declared joins added to a a table definition in SQL.\r\n\r\n\r\n<!-- TOC depthFrom:3 depthTo:3 -->\r\n\r\n- [unmanaged](#unmanaged)\r\n- [managed to-one](#managed-to-one)\r\n- [managed to-many](#managed-to-many)\r\n- [managed many-to-many](#managed-many-to-many)\r\n- [with default filters](#with-default-filters)\r\n- [to parameterized views](#to-parameterized-views)\r\n- [Compositions](#compositions)\r\n- [... of inner types](#-of-inner-types)\r\n- [... of named types or facets](#-of-named-types-or-facets)\r\n\r\n<!-- /TOC -->\r\n\r\n\r\n\r\n### unmanaged\r\n\r\nUnmanaged Associations specify arbitrary join conditions in their `on` clause which refer to available foreign key elements. The association's name (`address` in the example below) is used as the alias for the to-be-joined target entity.\r\n\r\n```swift\r\nentity Employees {\r\n  address : Association to Addresses on address.ID = address_ID;\r\n  address_ID : Integer;  //> foreign key\r\n}\r\n```\r\n```swift\r\nentity Addresses {\r\n  key ID : Integer;\r\n}\r\n```\r\n\r\n\r\n### managed to-one\r\n\r\nFor to-one associations, CDS can automatically resolve and add requisite foreign key\r\nelements from the target's primary keys and implicitly add respective join conditions.\r\n\r\n```swift\r\nentity Employees {\r\n  address : Association to Addresses;\r\n}\r\n```\r\n\r\nThis example is equivalent to the [unmanaged example above](#unmanaged), with the foreign\r\nkey element `address_ID` being added automatically upon activation to a SQL database.\r\n\r\n> No foreign key constraints are added on database level.\r\n\r\n### managed to-many\r\n\r\nFor one-to-many associations specify an on condition following the canonical\r\nexpression pattern `<assoc>.<backlink> = $self` as in this example:\r\n\r\n```swift\r\nentity Employees {\r\n  key ID : Integer;\r\n  addresses : Association to many Addresses\r\n    on addresses.owner = $self;\r\n}\r\n```\r\n```swift\r\nentity Addresses {\r\n  owner : Association to Employees;  //> the backlink\r\n}\r\n```\r\n\r\n> The backlink can be any managed to-one association on the _many_ side pointing back to the _one_ side.\r\n\r\n\r\n### managed many-to-many\r\n{: .impl.concept}\r\n\r\nFor many-to-many associations, CDS can generate requisite link tables. You can use\r\nthe `via` parameter clause to add elements to link table reflecting attributed relationships\r\nor to use a pre-defined link table instead.\r\n\r\n```swift\r\nentity Employees {\r\n  addresses1 : Association to many Addresses;\r\n  addresses2 : Association to many Addresses via {\r\n    kind: String(11);\r\n  }\r\n  addresses3 : Association to many Addresses via Emp2Addr;\r\n}\r\n```\r\n\r\nFor the first two cases, [`cds.compile`](../node.js/api#cds-compile) would automatically add a link table,\r\nfor the second case with an additional element `kind` (&rarr; an _attributed relationship_).\r\nFor the third case it will use the pre-defined entity `Emp2Addr` that is expected to be\r\ndefined like that (names for `source/target` can be freely chosen):\r\n\r\n```swift\r\nentity Emp2Addr {\r\n  key source : Association to Employees;\r\n  key target : Association to Addresses;\r\n}\r\n```\r\n\r\n### with default filters\r\n{: .impl.concept}\r\n\r\nFor to-many associations you can optionally specify a default filter that will automatically\r\nbe applied to any usage of that association in queries unless another filter is specified explicitly.\r\n\r\n```swift\r\nentity Products {\r\n  localized : Association to many Product$Texts\r\n    with default filter lang=$env.user.lang;\r\n}\r\n```\r\n```swift\r\nentity Product$Texts {\r\n  key product : Association to Products;\r\n  key lang : String(3);\r\n  title : String(44);\r\n  descr : String(444);\r\n}\r\n```\r\n\r\n### to parameterized views\r\n{: .impl.concept}\r\n\r\nIf the target is a [parameterized view](#views-with-parameters), you can specify\r\ncorresponding arguments in an Association definition as follows:\r\n\r\n```swift\r\nentity Products {\r\n  assoc : Association to SomeParameterizedView (\r\n    param1: 4711,\r\n    param2: foo\r\n  );\r\n  foo : String;\r\n}\r\n```\r\n\r\n> The argument values for parameters are literals or expressions in which references\r\nare resolved within the current entity's elements.\r\n\r\n\r\n\r\n### Compositions\r\n\r\nCompositions are the same as Associations just with the additional information\r\nthat this Association represents a contained-in relationship. Compositions frequently\r\nshow up in to-many header-child scenarios.\r\n\r\n```swift\r\nentity Orders {\r\n  Items : Composition of many OrderItems on Items.order = $self;\r\n}\r\nentity OrderItems {\r\n  key order : Association to Orders;\r\n  product : ...;\r\n  quantity : ...;\r\n}\r\n```\r\n\r\n### ... of inner types\r\n{: .impl.concept}\r\n\r\nA managed syntactical sugar variant allows to write such Compositions in a\r\n(anynomous) inner child way:\r\n\r\n```swift\r\nentity Orders {\r\n  Items : Composition of many OrderItems { ... }\r\n  Items : Composition of many { ... }\r\n}\r\n```\r\nThis would automatically be unfolded to\r\nthe equivalent as shown in the [former example](#compositions).\r\nIf the inner struct is anonymous it will be constructed as\r\n`OrdersItems` in the example above.\r\n\r\n\r\n### ... of named types or facets\r\n{: .impl.concept}\r\n\r\nInstead of an inner type you can also specify a named type or facet which would\r\nbe unfolded the same way than anonymous inner types as shown above:\r\n\r\n```swift\r\nentity Products {\r\n  offeredQuantities : Composition of many Quantity;\r\n}\r\ntype Quantity {\r\n  value : Decimal(10,2);\r\n  unit : String(22);\r\n}\r\n```\r\n\r\n\r\n<br>\r\n"},{"name":"06-Annotations-.md","content":"\r\n## Annotations\r\n\r\n{% include links.md %}\r\n\r\nThis chapter describes how to add Annotations to model definitions written in CDL, focused on the common syntax options and fundamental concepts. Find additional information in the [OData Annotations] guide.\r\n\r\n\r\n<!-- TOC depthFrom:3 depthTo:3 -->\r\n\r\n- [annotation syntax](#annotation-syntax)\r\n- [annotation targets](#annotation-targets)\r\n- [annotation values](#annotation-values)\r\n- [records are syntax shortcuts](#records-are-syntax-shortcuts)\r\n\r\n<!-- /TOC -->\r\n\r\n\r\n### annotation syntax\r\n\r\nAnnotations in CDL are prefixed with an ___'@'___ sign and can be placed\r\nbefore a definition, after the defined name or at the end of simple definitions.\r\n\r\n```java\r\n@before entity Foo @inner {\r\n  @before simple @inner : String @after;\r\n  @before struct @inner { ...elements... }\r\n}\r\n```\r\n\r\nMultiple annotations can be placed in each spot separated by whitespaces or enclosed\r\nin `@(...)` and separated by comma &mdash; i.e. the following are equivalent:\r\n\r\n```swift\r\nentity Foo @(\r\n  my.annotation: foo,\r\n  another.one: 4711\r\n) { /* elements */ }\r\n```\r\n```swift\r\n@my.annotation:foo\r\n@another.one: 4711\r\nentity Foo { /* elements */ }\r\n```\r\n\r\nFor an `@inner` annotation only the syntax `@(...)` is available.\r\n\r\n### annotation targets\r\n\r\nYou can basically annotate any named thing in a CDS model, such as...\r\n\r\nContexts and services:\r\n\r\n```java\r\n@before [define] (context|service) Foo @inner { ... }\r\n```\r\n\r\nDefinitions and elements with simple types:\r\n\r\n```java\r\n@before [define] type Foo @inner : String @after;\r\n@before [key] anElement @inner : String @after;\r\n```\r\n\r\nEntities, facets and other struct types and elements thereof:\r\n\r\n```java\r\n@before [define] (entity|type|facet|annotation) Foo @inner {\r\n  @before simple @inner : String @after;\r\n  @before struct @inner { ...elements... };\r\n}\r\n```\r\n\r\nEnums\r\n\r\n```java\r\n... status : String @inner enum {\r\n  fulfilled @after;\r\n}\r\n```\r\n\r\nColumns in a view definition's query:\r\n\r\n```java\r\n... as SELECT from Foo {\r\n  @before expr as alias @inner : String,\r\n  ...\r\n}\r\n```\r\n\r\nParameters in view definitions:\r\n\r\n```java\r\n... with parameters (\r\n  @before param @inner : String @after\r\n) ...\r\n```\r\n\r\nActions/functions including their parameters and result elements:\r\n\r\n```java\r\n@before action doSomething @inner (\r\n  @before param @inner : String @after\r\n) returns {\r\n  @before result @inner : String @after;\r\n};\r\n```\r\n\r\n\r\n### annotation values\r\n\r\nValues can be literals or references.\r\nIf no value is given, the default value is `true` as for `@aFlag` below.\r\n\r\n```java\r\n@aFlag //= true, if no value is given\r\n@aBoolean: false\r\n@aString: 'foo'\r\n@anInteger: 11\r\n@aDecimal: 11.1\r\n@aSymbol: #foo\r\n@aReference: foo.bar\r\n@anArray: [ /* can contain any kind of value */ ]\r\n```\r\n\r\nAs described in the [CSN spec]({{csn}}#literals), the above annotations would compile to CSN as follows:\r\n\r\n```\r\n{\r\n  \"@aFlag\": true,\r\n  \"@aBoolean\": false,\r\n  \"@aString\": \"foo\",\r\n  \"@anInteger\": 11,\r\n  \"@aDecimal\": 11.1,\r\n  \"@aSymbol\": {\"#\":\"foo\"},\r\n  \"@aReference\": {\"=\":\"foo.bar\"},\r\n  \"@anArray\": [ ... ]\r\n}\r\n```\r\n\r\nNote: References (and expressions in general) are not checked nor resolved by CDS parsers or linkers. They are interpreted and evaluated only on consumption-specific modules. For example, in case of Fiori models, it's the _4odata_ and _2edm(x)_ processors.\r\n\r\n\r\n\r\n### records are syntax shortcuts\r\n\r\nAnnotations in cds are essentially flat lists of key-value pairs assigned to a target.\r\nThe record syntax &ndash; i.e. `{key:<value>, ...}` &ndash; is a shortcut notation that\r\napplies a common prefix to nested annotations.\r\nI.e. the following are equivalent:\r\n\r\n```java\r\n@Common.foo.bar\r\n@Common.foo.car: 'wheels'\r\n```\r\n```java\r\n@Common: { foo.bar, foo.car: 'wheels' }\r\n//> not yet implemented!\r\n```\r\n```java\r\n@Common.foo: { bar }\r\n@Common.foo.car: 'wheels'\r\n```\r\n```java\r\n@Common.foo: { bar, car: 'wheels'  }\r\n```\r\n.... and they would show up as follows in a parsed model (&rarr; see [CSN][]):\r\n\r\n```\r\n{\r\n  \"@Common.foo.bar\": true,\r\n  \"@Common.foo.car\": \"wheels\",\r\n}\r\n```\r\n\r\n### annotation propagation\r\n\r\nAnnotations are inherited from types and base types to dereived types, entities and elements as well as from elements of underlying entities in case of views.\r\n\r\nFor examples, given this view definition:\r\n\r\n````swift\r\nusing Books from './bookshop-model';\r\nentity BooksList as SELECT from Books {\r\n  ID, genre : Genre, title,\r\n  author.name as author\r\n};\r\n```\r\n\r\n* `BooksList` would inherit annotations from `Books`\r\n* `BooksList.ID` would inherit from `Books.ID`\r\n* `BooksList.author` would inherit from `Books.author.name`\r\n* `BooksList.genre` would inherit from type `Genre`\r\n\r\nThe rules are:\r\n\r\n**Rule #1** &mdash; _Entity-level properties and annotations are inherited from the **primary** underlying source entity &ndash; here `Books`._\r\n{: .rule}\r\n\r\n**Rule #2** &mdash; _Each element that can **unambiguously** be traced back to a single source element, inherits that element's properties**, ...**_\r\n{: .rule}\r\n\r\n**Rule #3** &mdash; _**...unless** an explicit **cast** in the select clause cuts them off, e.g. as for `genre` in our example above._\r\n{: .rule}\r\n\r\n<br>\r\n"},{"name":"06-Excluding-Clause-.md","content":"\r\n\r\n## Excluding Clause\r\n\r\nUse the `excluding` clause in combination with `SELECT *` to select all elements except for the ones listed in the exclude list.\r\n\r\n```swift\r\nSELECT from Books { * } excluding { author };\r\n```\r\n```swift\r\nSELECT from Books { *, author.name as author, author{*} }\r\nexcluding { author.town };\r\n```\r\n\r\nThe effect is about **late materialization** of signatures and staying open to late extensions.\r\nFor example assume the following definitions:\r\n\r\n```swift\r\nentity Foo { foo; bar; car; }\r\nentity Bar as SELECT from Foo excluding { bar }\r\nentity Boo as SELECT from Foo { foo, car }\r\n```\r\n\r\nA `SELECT * from Bar` would result into the very same as a query of `Boo`:\r\n\r\n```sql\r\nSELECT * from Bar --> { foo, car }\r\nSELECT * from Boo --> { foo, car }\r\n```\r\n\r\nNow assume a consumer of that package extends the definitions as follows:\r\n\r\n```swift\r\nextend Foo with { boo : String; }\r\n```\r\n\r\n... with that, queries on `Bar` and `Boo` would return different results:\r\n\r\n```sql\r\nSELECT * from Bar --> { foo, car, boo }\r\nSELECT * from Boo --> { foo, car }\r\n```\r\n"},{"name":"07-Aspects-.md","content":"\r\n## Aspects\r\n\r\n{% include links.md %}\r\n\r\n<!-- TOC depthFrom:3 depthTo:3 -->\r\n\r\n- [extend entity](#extend)\r\n- [extend view](#extend-view)\r\n- [extend services](#extend-services)\r\n- [annotate](#annotate)\r\n- [named aspects](#named-aspects)\r\n- [shortcut syntax `:`](#shortcut-syntax-)\r\n- [looks like inheritance](#looks-like-inheritance)\r\n\r\n<!-- /TOC -->\r\n\r\n\r\n\r\n### extend [ entity / type ]\r\n{: #extend}\r\n\r\nUse `extend` to add extension fields or to add/override metadata to existing\r\ndefinitions, e.g. annotations, as follows:\r\n\r\n```swift\r\nextend Foo with @title:'Foo' {\r\n  newField : String;\r\n  extend nestedStructField {\r\n    newField : String;\r\n    extend existingField @title:'Nested Field';\r\n  }\r\n}\r\nextend Bar with @title:'Bar'; // nothing for elements\r\n```\r\n\r\nNote: make sure you prepend the `extend` keyword to nested elements,\r\notherwise this would mean you want to add a new field with that name:\r\n\r\n\r\n\r\n### annotate\r\n\r\n\r\nUse `annotate` instead of `extend` if you only want to add/override annotations:\r\n\r\n```swift\r\nannotate Foo with @title:'Foo' {\r\n  nestedStructField {\r\n    existingField @title:'Nested Field';\r\n  }\r\n}\r\nannotate Bar with @title:'Bar';\r\n```\r\n\r\nThis example is effectively the same as the above one for [extend](#extend)\r\nwithout the extension fields added. Actually, `annotate` is just a shortcut with the\r\ndefault mode being switched to `extend`ing existing fields instead of adding\r\nnew ones.\r\n\r\n\r\n\r\n### extend view\r\n{: .impl.concept}\r\n\r\nUse `extend view` to extend the projection of a view entity to include more elements existing in the underlying entity:\r\n\r\n```swift\r\nextend view Foo with @title:'Foo' {\r\n  foo as bar @car,\r\n  <expression> as jar\r\n}\r\n```\r\n\r\nNote: Enhancing nested structs is not supported. Note also that you can use the common [`annotate`](#annotate) syntax if you only need to add/override annotations.\r\n\r\n\r\n\r\n\r\n### named aspects\r\n\r\nYou can use `extend` or `annotate` with pre-defined aspects, in order\r\nto apply the same extensions to multiple targets:\r\n\r\n```swift\r\nextend Foo with ManagedObject;\r\nextend Bar with ManagedObject;\r\n```\r\n```swift\r\naspect ManagedObject {\r\n  created { at: DateTime; by: User; }\r\n}\r\n```\r\n\r\nIn case of `extend` all nested fields in the named aspect are interpreted\r\nas being extension fields. In case of `annotate` they are interpreted as existing fields\r\nand the annotations are copied to the corresponding target elements.\r\n\r\nThe named extension can be anything, e.g. including other `types` or `entities`.\r\nYou can use `aspects` as shown in the example to declare definitions that are only\r\nmeant to be used in such extensions, not as types for elements.\r\n\r\n\r\n\r\n###  shortcut syntax `:`\r\n\r\nYou can use an inheritance-like syntax option to extend a definition with one or more [named aspects](#named-aspects)\r\nas follows:\r\n\r\n```swift\r\ndefine entity Foo : ManagedObject, AnotherAspect {\r\n  key ID : Integer;\r\n  name : String;\r\n  ...\r\n}\r\n```\r\n\r\nThis essentially is syntactical sugar and equivalent to using a sequence of [extends](#extend) as follows:\r\n\r\n```swift\r\ndefine entity Foo;\r\nextend Foo with ManagedObject;\r\nextend Foo with AnotherAspect;\r\nextend Foo with {\r\n  key ID : Integer;\r\n  name : String;\r\n  ...\r\n}\r\n```\r\n\r\nYou can apply this to any definition of an entity or a structured type.\r\n\r\n\r\n\r\n### looks like inheritance\r\n\r\nThe `:`-based syntax option described before looks very much like (multiple) inheritance\r\nand in fact has very much the same effects. Yet, as mentioned in the beginning of this\r\nchapter, it is not based on inheritance but on mixins, which are more powerful and also\r\navoid common problems like the infamous diamond shapes in type derivations.\r\n\r\nWhen combined with persistence mapping there are a few things to note, that goes down\r\nto which strategy to choose to map inheritance to e.g. relational models.\r\nFind some details in [_Aspects vs Inheritance_](../cds/aspects-inheritance).\r\n"},{"name":"07-Query-local-Mixins-.md","content":"\r\n## Query-local Mixins\r\n\r\nUse the `mixin...into` clause to logically add elements to the source of the query which you can use and propagate in the query's projection.\r\n\r\n```sql\r\nSELECT from Books mixin {\r\n  localized : Association to LocalizedBooks on localized.ID = ID;\r\n} into {\r\n  ID, localized.title\r\n};\r\n```\r\n"},{"name":"08-Services-.md","content":"\r\n## Services\r\n\r\n<!-- TOC depthFrom:3 depthTo:3 -->\r\n\r\n- [service definitions](#service-definitions)\r\n- [exposed entities](#exposed-entities)\r\n- [actions / functions](#actions--functions)\r\n- [derived services](#derived-services)\r\n- [extend services](#extend-services)\r\n\r\n<!-- /TOC -->\r\n\r\n\r\n\r\n### service definitions\r\n\r\nCDS allows to define service interfaces as collections of exposed entities enclosed\r\nin a `service` block which essentially is and acts the same a [`context`](#contexts):\r\n\r\n```swift\r\nservice SomeService {\r\n  entity SomeExposedEntity ...;\r\n  entity AnotherExposedEntity ...;\r\n}\r\n```\r\n\r\n\r\n### exposed entities\r\n\r\nThe entities exposed by a service are most frequently projections on entities\r\nfrom underlying data models.\r\nStandard view definitions, using [`as SELECT from`](#views) or\r\n[`as projection on`](#entity--as-projection-on) can be used for\r\nthat.\r\n\r\n```swift\r\nservice CatalogService {\r\n  entity Product as projection on data.Products {\r\n    *, created.at as since\r\n  } excluding { created };\r\n}\r\nservice MyOrders {\r\n  view Order as select from data.Orders { * } where buyer=$user.id;  //> $user not yet implemented!\r\n  entity Product as projection on CatalogService.Product;\r\n}\r\n```\r\n\r\n\r\n#### auto-promoted associations\r\n{: .impl.concept}\r\n> **TODO**\r\n\r\n\r\n\r\n### actions / functions\r\n\r\nService definitions may additionally specify `actions` and `functions` with a\r\ncomma-separated list of named and typed inbound parameters and an\r\noptional response type, which can be a reference to a declared type or\r\n(not yet implemented) the inline definition of a new (struct) type.\r\n\r\n```swift\r\nservice MyOrders {\r\n  entity Order ...;\r\n  // unbound actions / functions\r\n  type cancelOrderRet {\r\n    acknowledge: String enum { succeeded; failed; };\r\n    message: String;\r\n  }\r\n  action cancelOrder ( orderID:Integer, reason:String ) returns cancelOrderRet;\r\n  function countOrders() returns Integer;\r\n}\r\n```\r\n\r\n> The notion of actions and functions in CDS adopts that of [OData](http://docs.oasis-open.org/odata/odata/v4.0/os/part1-protocol/odata-v4.0-os-part1-protocol.html#_Toc372793737); actions and functions on service-level are _unbound_ ones.\r\n\r\n#### bound actions / functions\r\n\r\nActions and functions can also be bound to individual entities of a service, enclosed\r\nin an additional `actions` block as the last clause in an entity / view definition.\r\n\r\n```swift\r\nservice CatalogService {\r\n  entity Products as projection on data.Products { ... }\r\n    actions {\r\n      // bound actions/functions\r\n      action addRating (stars: Integer);\r\n      function getViewsCount() returns Integer;\r\n    }\r\n}\r\n```\r\n\r\n### derived services\r\n{: .impl.concept}\r\n\r\nYou can define abstract services and inherit from it in other service definitions\r\nas in this example:\r\n\r\n```swift\r\nabstract service ShoppingService {\r\n  abstract entity Articles {...}\r\n  entity Suppliers {...}\r\n  entity ShoppingCart {} actions {\r\n    submitOrder();\r\n  }\r\n}\r\n```\r\n\r\n```swift\r\nservice Bookshop : ShoppingService {\r\n  entity Books : ShoppingService.Articles {\r\n    author : Association to Authors;\r\n  }\r\n  entity Authors {...}\r\n}\r\n```\r\n\r\n\r\n### extend services\r\n\r\nYou can [extend](#extend) services with additional entities and actions\r\nmuch as you would add new entities to a context:\r\n\r\n```swift\r\nextend service CatalogService with {\r\n  entity Foo {};\r\n  function getRatings() returns Integer;\r\n}\r\n```\r\n\r\nSimilarly, you can [extend](#extend) entities with additional actions\r\nas you would add new elements:\r\n\r\n\r\n```swift\r\nextend entity CatalogService.Products with actions {\r\n  function getRatings() returns Integer;\r\n}\r\n```\r\n\r\n\r\n\r\n<br>\r\n"},{"name":"10-Namespaces-.md","content":"\r\n## Namespaces\r\n\r\n<!-- TOC depthFrom:3 -->\r\n\r\n- [`namespace` directive](#namespace-directive)\r\n- [contexts](#contexts)\r\n- [fully-qualified names](#fully-qualified-names)\r\n\r\n<!-- /TOC -->\r\n\r\n### namespace directive\r\n\r\nPlace a `namespace` directive to the top of a model to prefix the names of all subsequent definitions. This is very much as in other languages like Java.\r\n\r\n{% include _code sample='namespaces.cds' %}\r\n\r\n\r\n### contexts\r\n\r\nUse `contexts` for nested namespace sections.\r\n\r\n{% include _code sample='contexts.cds' %}\r\n\r\n\r\n### fully-qualified names\r\n\r\nA model ultimately is a collection of definitions with unique, fully-qualified names. For example, the second model above would compile to this [CSN][]:\r\n\r\n{% include _code sample='contexts.json' %}\r\n\r\n\r\n<br>\r\n"},{"name":"11-Imports-.md","content":"\r\n## Import Directives\r\n{:#imports}\r\n\r\n  - [`using` directives](#using-directives)\r\n  - [`import` directives](#import-directives)\r\n  - [model resolution](#model-resolution)\r\n\r\n\r\n### `using` directives\r\n\r\nUsing directives allow to import definitions from other cds models. As shown in line 3 below you can specify aliases to be used subsequently. You can import single definitions as well as several ones with a\r\ncommon namespace prefix, optionally choosing a local alias.\r\n\r\n{% include _code sample='using-from.cds' %}\r\n\r\nMultiple named imports via es6-like deconstructors:\r\n\r\n```swift\r\nusing { Foo as Moo, sub.Bar } from './base-model';\r\nentity Boo : Moo;\r\nentity Car : Bar;\r\n```\r\n\r\nNote: also in the deconstructor variant of `using`  shown above, you always need to specify fully-qualified names.\r\n\r\n\r\n### `import` directives\r\n{: .impl.concept}\r\n\r\nThe `import` directive extends the `using` directive to fully support syntax and semantics of [`import` statements in ES6][ES6].\r\nIn particular...\r\n\r\nImported names may omit the target's namespace prefix:\r\n\r\n```swift\r\nimport {Foo} from './base-model';\r\n```\r\n\r\nMultiple named imports via es6-like deconstructors:\r\n\r\n```swift\r\nimport { Foo as Moo, scoped.Bar } from './base-model';\r\nentity Boo : Moo;\r\nentity Car : Bar;\r\n```\r\n\r\n\r\nImports with locally chosen prefixes (independent from target namespaces):\r\n\r\n```swift\r\nimport base from './base-model';\r\nentity Foo : base.Foo;\r\nentity Bar : base.scoped.Bar;\r\n```\r\n\r\n\r\n### model resolution\r\n\r\nImports in `cds` work very much like `require` in [node][] and `imports` in [ES6][].\r\nIn fact we reuse **[Node's module loading mechanisms](https://nodejs.org/api/modules.html)**.\r\nHence the same rules apply; in short:\r\n\r\n* names starting with `./` or `../` are resolved relative to the current model\r\n* others are absolute references, fetched for in `node_modules` folders...\r\n* with `.json` or `.cds` suffixes appended in order\r\n* or from a `.../index.<json|cds>` file in case of a folder\r\n\r\n> Note: to allow for loading from pre-compiled `.json` files it is recommended\r\nto **omit `.cds` suffixes** in import statements, as shown in the examples above.\r\n\r\n\r\n<br>"},{"name":"Formatting-Options.md","content":"## Code Formatting\r\n\r\nCDS-LSP provides a functionality called _code formatting,_ also known as _beautify._\r\nCode formatting alters whitespaces and line breaks in existing CDS code to follow\r\na unified code style and to aid the eye reading the code.\r\n\r\nCode formatting can be triggered by means of the `textDocument/formatting` LSP request or, when using CDS-LSP via editors such as VSCode, through\r\nthe corresponding commands such as _format document_ or _format highlighted section._\r\n\r\n### Formatting Options\r\n\r\nCDS-LSP provides a comprehensive set of options to adjust fine details of code formatting.\r\nThe options are classified in several categories.\r\n\r\n#### Parent options and child options\r\n\r\nSome formatting options are assigned a _parent option_ that allows to enable or disable a subset of semantically related _child options_ at once.\r\n\r\n_Disabling_ a parent option also disables the child options.\r\n\r\n_Enabling_ a parent option restores the previous state of all its child options.\r\nWhen a parent option is enabled, its child option can be either enabled or disabled.\r\n\r\n#### Available options\r\n\r\nAn overview of available options is given in what follows.\r\n\r\n| Option Key                           | Default Value | Description                                                                                                                                    | Parent Option                 |\r\n|--------------------------------------|---------------|------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------|\r\n| alignAfterKey                        | true          | Align _element identifiers_ after optional `key` keyword                                                                                       |                               |\r\n| alignAnnotations                     | true          | Align _annotations_                                                                                                                            |                               |\r\n| alignPreAnnotations                  | true          | Align annotations before items. If multiple annotations exist in a line, they are aligned in a tabular way                                     | alignAnnotations              |\r\n| alignPostAnnotations                 | true          | Align annotations after items                                                                                                                  | alignAnnotations              |\r\n| alignColonsInAnnotations             | true          | Align _colons_ in annotations                                                                                                                  | alignAnnotations              |\r\n| alignValuesInAnnotations             | true          | Align _values_ in annotations                                                                                                                  | alignAnnotations              |\r\n| alignActionsAndFunctions             | true          | Align parts of _actions_ and _functions_                                                                                                       |                               |\r\n| alignActionNames                     | true          | Align the names of _functions_ and _actions_                                                                                                   | alignActionsAndFunctions      |\r\n| alignActionReturns                   | true          | Align the `returns` keyword of _actions_ and _functions_                                                                                       | alignActionsAndFunctions      |\r\n| alignAs                              | true          | Align the `as` keyword                                                                                                                         |                               |\r\n| alignAsInEntities                    | true          | Align the `as` keyword in entities. Alignment scope: encompassing context                                                                      | alignAs                       |\r\n| alignAsInSelectItems                 | true          | Align the `as` keyword in entity `select` items                                                                                                | alignAs                       |\r\n| alignAsInUsing                       | true          | Align the `as` keyword in `using` statements                                                                                                   | alignAs                       |\r\n| alignExpressionsAndConditions        | true          | Align parts of _expressions_ and _conditions_, including left- and right-hand side and operator                                                |                               |\r\n| alignExprAndCondWithinBlock          | true          | Align parts of _expressions_ and _conditions_ within the encompassing block rather than throughout the whole statement                         | alignExpressionsAndConditions |\r\n| alignTypes                           | true          | Align _element types_ within entities, type or annotation specifications                                                                       |                               |\r\n| alignColonsBeforeTypes               | true          | Align _colons_ before element types                                                                                                            | alignTypes                    |\r\n| alignEqualsAfterTypes                | true          | Align _assignment operators_ `=` after element types                                                                                           | alignTypes                    |\r\n| alignTypesWithinBlock                | true          | Align _element types_ (and _colons_) within the encompassing block rather than throughout the whole statement                                  | alignTypes                    |\r\n| alignCompositionStructToRight        | true          | Align _struct_ defined in `composition` to the right                                                                                           | alignTypes                    |\r\n| cqlKeywordCapitalization             | lower         | How _CQL keywords_ are capitalized                                                                                                             |                               |\r\n| keepAnnotationsInOriginalLine        | keepLine      | Either keeps the line structure of _annotations_ or wraps each annotation in separate line                                                     |                               |\r\n| keepEmptyBracketsTogether            | true          | Keep _bracket pairs_ `{} [] ()` together rather than separating them with whitespace                                                           |                               |\r\n| keepSingleLinedBlocksTogether        | true          | Avoid single-lined _blocks_ of the same type being separated by empty lines                                                                    |                               |\r\n| keepOriginalEmptyLines               | true          | Prevent deletion of consecutive empty lines below the limit. If disabled, allow consecutive empty lines to be removed depending on the context |                               |\r\n| maxKeepEmptyLines                    | 2             | Maximum number of consecutive _empty lines_ to keep. Empty lines below this limit may still be removed depending on other settings             |                               |\r\n| openingBraceInNewLine                | false         | Wrap line before opening _brace_                                                                                                               |                               |\r\n| selectInNewLine                      | true          | Start `select` statement of entity or view definition in a new line (indented)                                                                 |                               |\r\n| tabSize                              | 2             | Specify the number of spaces per indentation level                                                                                             |                               |\r\n| finalNewline                         | true          | Insert newline character at the end of the file                                                                                                |                               |\r\n| maxDocCommentLine                    | 60            | Wrap doc comment lines at given length                                                                                                         |                               |\r\n| whitespaceBeforeColon                | true          | Use blank to separate item from following _colon_                                                                                              |                               |\r\n| whitespaceAfterColon                 | true          | Use blank to separate _colon_ from following item                                                                                              |                               |\r\n| whitespaceAfterComma                 | true          | Use blank to separate _comma_ from following item                                                                                              |                               |\r\n| whitespaceAroundAlignedOps           | true          | Use blank before and after aligned _binary operators_ and _colons_                                                                             |                               |\r\n| whitespaceAroundBinaryOps            | true          | Use blank before and after _binary operators_                                                                                                  |                               |\r\n| whitespaceWithinBrackets             | false         | Use blank after opening and before closing _brackets_ `{} [] ()`                                                                               |                               |\r\n"},{"name":"settings.md","content":"# CDS Language Server Settings\r\n\r\nCDS-LS can be configured via file or IDE options (through language server protocol aka LSP)\r\n\r\nOptions overlay in that order:\r\n- $CDS_LS_DIR/.cds-lsp/.settings.json\r\n- $WORKSPACE/.cds-lsp/.settings.json\r\n- IDE options\r\n\r\ni.e. IDE options ultimately win \r\n\r\nPossible options are described in JSON schema.<br> \r\nSee vscode-cds/package.json#contributes.configuration.properties<br>\r\nWrap them in a _settings_ node e.g.\r\n```\r\n{\r\n    \"settings\": {\r\n        \"cds\": {\r\n            \"workspaceValidationMode\": \"OpenEditorsOnly\"\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n"}]},{"name":"Formatting-Options.md","content":"## Code Formatting\r\n\r\nCDS-LSP provides a functionality called _code formatting,_ also known as _beautify._\r\nCode formatting alters whitespaces and line breaks in existing CDS code to follow\r\na unified code style and to aid the eye reading the code.\r\n\r\nCode formatting can be triggered by means of the `textDocument/formatting` LSP request or, when using CDS-LSP via editors such as VSCode, through\r\nthe corresponding commands such as _format document_ or _format highlighted section._\r\n\r\n### Formatting Options\r\n\r\nCDS-LSP provides a comprehensive set of options to adjust fine details of code formatting.\r\nThe options are classified in several categories.\r\n\r\n#### Parent options and child options\r\n\r\nSome formatting options are assigned a _parent option_ that allows to enable or disable a subset of semantically related _child options_ at once.\r\n\r\n_Disabling_ a parent option also disables the child options.\r\n\r\n_Enabling_ a parent option restores the previous state of all its child options.\r\nWhen a parent option is enabled, its child option can be either enabled or disabled.\r\n\r\n#### Available options\r\n\r\nAn overview of available options is given in what follows.\r\n\r\n| Option Key                           | Default Value | Description                                                                                                                                    | Parent Option                 |\r\n|--------------------------------------|---------------|------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------|\r\n| alignAfterKey                        | true          | Align _element identifiers_ after optional `key` keyword                                                                                       |                               |\r\n| alignAnnotations                     | true          | Align _annotations_                                                                                                                            |                               |\r\n| alignPreAnnotations                  | true          | Align annotations before items. If multiple annotations exist in a line, they are aligned in a tabular way                                     | alignAnnotations              |\r\n| alignPostAnnotations                 | true          | Align annotations after items                                                                                                                  | alignAnnotations              |\r\n| alignColonsInAnnotations             | true          | Align _colons_ in annotations                                                                                                                  | alignAnnotations              |\r\n| alignValuesInAnnotations             | true          | Align _values_ in annotations                                                                                                                  | alignAnnotations              |\r\n| alignActionsAndFunctions             | true          | Align parts of _actions_ and _functions_                                                                                                       |                               |\r\n| alignActionNames                     | true          | Align the names of _functions_ and _actions_                                                                                                   | alignActionsAndFunctions      |\r\n| alignActionReturns                   | true          | Align the `returns` keyword of _actions_ and _functions_                                                                                       | alignActionsAndFunctions      |\r\n| alignAs                              | true          | Align the `as` keyword                                                                                                                         |                               |\r\n| alignAsInEntities                    | true          | Align the `as` keyword in entities. Alignment scope: encompassing context                                                                      | alignAs                       |\r\n| alignAsInSelectItems                 | true          | Align the `as` keyword in entity `select` items                                                                                                | alignAs                       |\r\n| alignAsInUsing                       | true          | Align the `as` keyword in `using` statements                                                                                                   | alignAs                       |\r\n| alignExpressionsAndConditions        | true          | Align parts of _expressions_ and _conditions_, including left- and right-hand side and operator                                                |                               |\r\n| alignExprAndCondWithinBlock          | true          | Align parts of _expressions_ and _conditions_ within the encompassing block rather than throughout the whole statement                         | alignExpressionsAndConditions |\r\n| alignTypes                           | true          | Align _element types_ within entities, type or annotation specifications                                                                       |                               |\r\n| alignColonsBeforeTypes               | true          | Align _colons_ before element types                                                                                                            | alignTypes                    |\r\n| alignEqualsAfterTypes                | true          | Align _assignment operators_ `=` after element types                                                                                           | alignTypes                    |\r\n| alignTypesWithinBlock                | true          | Align _element types_ (and _colons_) within the encompassing block rather than throughout the whole statement                                  | alignTypes                    |\r\n| alignCompositionStructToRight        | true          | Align _struct_ defined in `composition` to the right                                                                                           | alignTypes                    |\r\n| cqlKeywordCapitalization             | lower         | How _CQL keywords_ are capitalized                                                                                                             |                               |\r\n| keepAnnotationsInOriginalLine        | keepLine      | Either keeps the line structure of _annotations_ or wraps each annotation in separate line                                                     |                               |\r\n| keepEmptyBracketsTogether            | true          | Keep _bracket pairs_ `{} [] ()` together rather than separating them with whitespace                                                           |                               |\r\n| keepSingleLinedBlocksTogether        | true          | Avoid single-lined _blocks_ of the same type being separated by empty lines                                                                    |                               |\r\n| keepOriginalEmptyLines               | true          | Prevent deletion of consecutive empty lines below the limit. If disabled, allow consecutive empty lines to be removed depending on the context |                               |\r\n| maxKeepEmptyLines                    | 2             | Maximum number of consecutive _empty lines_ to keep. Empty lines below this limit may still be removed depending on other settings             |                               |\r\n| openingBraceInNewLine                | false         | Wrap line before opening _brace_                                                                                                               |                               |\r\n| selectInNewLine                      | true          | Start `select` statement of entity or view definition in a new line (indented)                                                                 |                               |\r\n| tabSize                              | 2             | Specify the number of spaces per indentation level                                                                                             |                               |\r\n| finalNewline                         | true          | Insert newline character at the end of the file                                                                                                |                               |\r\n| maxDocCommentLine                    | 60            | Wrap doc comment lines at given length                                                                                                         |                               |\r\n| whitespaceBeforeColon                | true          | Use blank to separate item from following _colon_                                                                                              |                               |\r\n| whitespaceAfterColon                 | true          | Use blank to separate _colon_ from following item                                                                                              |                               |\r\n| whitespaceAfterComma                 | true          | Use blank to separate _comma_ from following item                                                                                              |                               |\r\n| whitespaceAroundAlignedOps           | true          | Use blank before and after aligned _binary operators_ and _colons_                                                                             |                               |\r\n| whitespaceAroundBinaryOps            | true          | Use blank before and after _binary operators_                                                                                                  |                               |\r\n| whitespaceWithinBrackets             | false         | Use blank after opening and before closing _brackets_ `{} [] ()`                                                                               |                               |\r\n"},{"name":"settings.md","content":"# CDS Language Server Settings\r\n\r\nCDS-LS can be configured via file or IDE options (through language server protocol aka LSP)\r\n\r\nOptions overlay in that order:\r\n- $CDS_LS_DIR/.cds-lsp/.settings.json\r\n- $WORKSPACE/.cds-lsp/.settings.json\r\n- IDE options\r\n\r\ni.e. IDE options ultimately win \r\n\r\nPossible options are described in JSON schema.<br> \r\nSee vscode-cds/package.json#contributes.configuration.properties<br>\r\nWrap them in a _settings_ node e.g.\r\n```\r\n{\r\n    \"settings\": {\r\n        \"cds\": {\r\n            \"workspaceValidationMode\": \"OpenEditorsOnly\"\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n"}]},{"name":"INSTALLATION.md","content":"# Installation\r\n\r\n```@sap/cds-lsp``` is a language server. As such it needs a client to operate. This is typically an IDE. \r\nToday, most of the popular IDEs come with support for language servers. Basically there are two kinds of integration, specific and generic.\r\n\r\n### Specific IDE support\r\nOften, a plug-in or extension component for a specific language wraps the corresponding language server. For ```@sap/cds-lsp``` there are specific extensions for\r\n- [Visual Studio Code](https://cap.cloud.sap/docs/get-started/tools#vscode)\r\n- [Eclipse](https://cap.cloud.sap/docs/get-started/tools#eclipse)\r\n### Generic IDE support\r\nFor other IDEs there exist generic client plug-ins for language servers. Examples:\r\n  - [VIM](https://www.vim.org/) has several options, e.g. [ALE](https://github.com/dense-analysis/ale)\r\n  - [Jetbrain IDEs](https://www.jetbrains.com/products.html#type=ide) (IntelliJ IDEA, WebStorm, ...), e.g. [LSP Support](https://plugins.jetbrains.com/plugin/10209-lsp-support) or [lsp4intellij](https://github.com/ballerina-platform/lsp4intellij) \r\n  - Emacs, ...\r\n\r\n#### Requirements\r\n```@sap/cds-lsp``` is a NodeJS module. As such it requires NodeJS installed on the client machine. Minimum version is 10.16+.\r\n\r\n#### Start-up\r\n\r\n##### NPM Installation\r\n\r\n1) Create an empty folder and ```cd``` into it\r\n2) Execute ```npm i @sap/cds-lsp``` to download the language server and all its dependencies\r\n\r\nThis will create a sub-folder ```node_modules``` with all required npm modules.\r\nIt will also create a platform specific shell script to start the language server. It is located in the ```node_modules/.bin``` sub-folder and is called ```cds-lsp```. \r\n\r\nThe shell script uses ```stdio``` as connection channel (see [below](#connection-channels)) \r\n\r\n##### Custom Installation\r\n\r\n1) Get the download URL for the tarball with ```npm view @sap/cds-lsp```\r\n2) Download the tarball\r\n3) Extract the TGZ file\r\n4) In the ```package``` folder execute ```npm i```.\r\n\r\nThe simplest form to start the language server is ```node <cds-lsp folder>/lib/server```.\r\n\r\n##### Connection channels\r\n\r\n```@sap/cds-lsp``` can communicate to a client via one of three different connection channels (see the documentation of the client plug-in for details which channels are supported)\r\n- ```stdio``` (default): the language server listens on ```stdin``` for requests and sends responses to ```stdout```\r\n- ```node-ipc``` (if the client runs with NodeJS): add ```--node-ipc``` as a command-line argument\r\n- ```sockets```: add ```--socket=<port>``` as a command-line argument\r\n\r\nFor details see the similar json-language-server integration [docs](https://github.com/vscode-langservers/vscode-json-languageserver#integrate).\r\n\r\n#### Syntax Highlighting\r\nFor performance reasons, the language server protocol does not provide support for syntax highlighting. A TextMate grammar aside of the language server provides this. ```@sap/cds-lsp``` comes with a [TextMate grammar](https://macromates.com/manual/en/language_grammars) file [included](./syntaxes/cds.tmLanguage.json) for the CDS language. \r\n\r\nWhile specific client extensions usually integrate this by default, a generic integration requires to configure this separately.\r\nSome IDEs have TextMate support built-in. Others require another plug-in, a TextMate client. \r\nRefer to the corresponding documentation how to configure a custom TextMate grammar file. CDS source files have the ```.cds``` file extension. \r\n"},{"name":"README.md","content":"# CDS Language Server\r\n\r\nThe CDS language server implements the Language Server Protocol ([LSP](https://github.com/Microsoft/language-server-protocol))\r\nfor SAP's Core Data Services ([CDS](https://cap.cloud.sap/docs/cds/cdl)).\r\nIt can be used in many popular IDEs like, for example, [Visual Studio Code](https://cap.cloud.sap/docs/get-started/tools#vscode)\r\nor [Eclipse](https://cap.cloud.sap/docs/get-started/tools#eclipse).\r\nIt provides many useful features for working with and enjoying CDS sources.\r\n\r\n## Features\r\n\r\n- Syntax highlighting via Textmate grammar\r\n\r\n- Additional semantic highlighting\r\n\r\n- Source code validation providing diagnostics (error messages, warnings, ...)\r\n\r\n- Where-used navigation to\r\n    - definition\r\n    - references\r\n    - highlight occurrences\r\n\r\n- Code completion for\r\n    - keywords\r\n    - identifiers incl. not yet imported identifiers with corresponding `using` statement\r\n    - using paths and artifacts incl. showing README.md documentation as details\r\n    - i18n translation IDs\r\n    - turn on/off formatting regions\r\n\r\n- Snippets for typical CDS language construct<br/> (with documentation extracts of [capire](https://cap.cloud.sap/docs/cds/cdl) explaining language concepts)<br/> like\r\n    - namespace and context\r\n    - using\r\n    - service\r\n    - type\r\n    - entity and projections, ...\r\n    - element, associations, and compositions\r\n    - extend and annotate\r\n    - annotations for documentation\r\n\r\n- Quick fixes to\r\n    - create using statement for unknown artifacts\r\n    - maintain missing translation\r\n    - convert `@cds.doc` and `@description` annotations to doc comments\r\n\r\n- Inventory (symbols) for\r\n    - current file\r\n    - workspace incl. query capabilities to select, for example, artifact types, names, also include reuse models\r\n\r\n- Hover information based on\r\n    - doc comments\r\n    - `@title`, `@description` and ~~`@cds.doc`~~ (deprecated) annotations\r\n    - translations\r\n\r\n- Code formatting\r\n    - whole document\r\n    - selected range\r\n    - on-the-fly when completing statements using ```;``` or ```}```\r\n    - on save (depending on the IDE)\r\n    - on paste (depending on the IDE)\r\n    - with many options, configurable using\r\n        - settings file\r\n        - command line switches\r\n        - Config UI with simulation of options for Visual Studio Code and Eclipse\r\n        - JSON schema for textual support\r\n    - also for markdown in doc comments\r\n\r\n- Code formatting via CLI\r\n\r\n- Translation support\r\n    - properties, JSON, and CSV files\r\n    - navigate to translation definitions from translation IDs like ```'{i18n>customerName}'```\r\n    - show translations on hover\r\n    - quickfix to maintain missing translations\r\n\r\n- Plugin framework for external handlers of annotation domains\r\n\r\n## Usage\r\n\r\nThe CDS language server can only be used as part of an IDE extension or plugin. See [Installation](#installation) for more details.\r\n\r\nA code formatter for CDS source files is included.\r\n\r\n## Installation\r\n\r\nRefer to the [installation details](./INSTALLATION.md).\r\n\r\n## License\r\nThis package is provided under the terms of the [SAP Developer License Agreement](https://tools.hana.ondemand.com/developer-license-3_1.txt).\r\n"}]