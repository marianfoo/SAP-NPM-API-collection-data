[{"name":"CHANGELOG.md","content":"# Change Log\r\nAll notable changes to this project will be documented in this file.\r\n\r\nThis project adheres to [Semantic Versioning](http://semver.org/).\r\n\r\nThe format is based on [Keep a Changelog](http://keepachangelog.com/).\r\n\r\n## 11.2.1 - 2022-06-15\r\n\r\n### Fixed\r\n- When user-api/attributes fails to get user attributes, it returns the basic user details\r\n\r\n## 11.2.0 - 2022-06-14\r\n\r\n### Added\r\n- Expose the Redis retry strategy as an application router configuration.\r\n\r\n### Fixed\r\n- Support compressing multipart/mixed content type when compressResponseMixedTypeContent is configured in xs-app.json\r\n- Avoid token exchange in case of expired login token\r\n- Correct a null pointer exception issue in user-api-middleware\r\n\r\n## 11.1.0 - 2022-06-06\r\n\r\n### Added\r\n- Enhance user-api: both endpoints with user scopes, \"attributes\" endpoint with user attributes (including custom attributes)\r\n- Support TrustAll for Private-link proxy type\r\n\r\n### Fixed\r\n- SAML Assertion via Cloud Connector issue\r\n- ARBE cookie: null while working with multiple backends.\r\n\r\n## 11.0.1 - 2022-05-15\r\n\r\n### Fixed\r\n- ARBE cookie size issue\r\n\r\n## 11.0.0 - 2022-05-09\r\n\r\n### Added\r\n- Support node version 14 and node version 16 instead of node version 12 and node version 14\r\n\r\n### Updated dependencies\r\n- async removed\r\n\r\n## 10.15.4 - 2022-05-08\r\n\r\n### Fixed\r\n- Instance level destination handling\r\n- Error handling when calling svc2Approuter middleware\r\n\r\n### Updated dependencies\r\n- deps: @sap/xssec@3.2.13\r\n- Caret (^) added to: @sap/audit-logging,@sap/e2e-trace,@sap/logging,@sap/xssec,async,node-forge,urijs\r\n\r\n\r\n## 10.15.3 - 2022-04-26\r\n\r\n### Fixed\r\n- Request contains an invalid x-csrf-token\r\n\r\n## 10.15.2 - 2022-04-24\r\n\r\n### Fixed\r\n- Improve readme documentation\r\n- Token xsrf undefined, when approuter bound to external session storage \r\n\r\n### Updated dependencies\r\n- deps: @sap/logging@6.1.1\r\n- deps: async@3.2.3\r\n\r\n## 10.15.1 - 2022-04-07\r\n\r\n### Updated dependencies\r\n- should-send-same-site-none removed\r\n- request.js removed\r\n- moment removed\r\n- deps: urijs@1.19.11\r\n- deps: @sap/logging@6.1.0\r\n\r\n## 10.15.0 -  2022-04-03\r\n\r\n### Added\r\n- External session management support in service2approuter flow\r\n- Return auditLog, if has multi-tenant plan oauth2, as a dependency during subscription creation\r\n- Write auditLog error message into subscription tenant, when approuter runs in multi-tenant mode\r\n- Private-link proxy type support\r\n- Error stack in error-handler\r\n\r\n### Updated dependencies\r\n- deps: body-parser@1.2.0\r\n\r\n### Fixed\r\n- Type error in case of missing app.services\r\n\r\n## 10.14.2 -  2022-03-23\r\n\r\n### Updated dependencies\r\n- deps: node-forge@1.3.0\r\n\r\n## 10.14.1 -  2022-03-23\r\n\r\n### Fixed\r\n- Cookie addition in decrypt cookies and check in merge cookies\r\n- Improve destination service resilience in SaaS Approuter\r\n\r\n## 10.14.0 - 2022-03-15\r\n\r\n### Added\r\n- Auto-Pipeline for ioredis support\r\n\r\n### Fixed\r\n- web sockets fixed status code\r\n- IAS logout page redirect\r\n- convert environment variable EXTERNAL_REVERSE_PROXY to boolean type\r\n\r\n### Updated dependencies\r\n- bluebird removed\r\n\r\n## 10.13.2 - 2022-03-08\r\n\r\n### Fixed\r\n- Change log level to info for missing host destination\r\n- Null object error for user property\r\n\r\n### Updated dependencies\r\n- deps: urijs@1.19.10\r\n- deps: @sap/audit-logging@5.5.1\r\n- deps: @sap/xsenv@3.2.1\r\n\r\n## 10.13.1 - 2022-03-01\r\n\r\n### Fixed\r\n- Add check for correlationId header existence in getCorrelationId\r\n\r\n## 10.13.0 - 2022-02-27\r\n\r\n### Added \r\n- Support multiple zoneIds in same IAS tenant\r\n\r\n### Fixed\r\n- Avoid reading uaa property from a null object\r\n- Improve error handling in exchange token\r\n\r\n### Updated dependencies\r\n- deps: urijs@1.19.8\r\n- deps: axios@0.26.0\r\n\r\n## 10.12.0 - 2022-01-30\r\n\r\n### Added \r\n- Replace 'request' module by 'axios'\r\n- Support query params in user-api\r\n\r\n### Updated dependencies\r\n- deps: tough-cookie@4.0.0\r\n\r\n## 10.11.3 - 2022-01-25\r\n\r\n### Updated dependencies\r\n- deps: @sap/audit-logging@5.4.1\r\n- deps: @sap/xssec@3.2.12\r\n\r\n## 10.11.2 - 2022-01-13\r\n\r\n### Updated dependencies\r\n- deps: scmp@1.0.0\r\n\r\n## 10.11.1 - 2022-01-12\r\n\r\n### Updated dependencies\r\n- deps: node-forge@1.2.1\r\n\r\n## 10.11.0 - 2022-01-11\r\n\r\n### Added\r\n- POST method support for logout flows\r\n- New env. variable to skip loading client_credentials tokens on approuter start\r\n- Adding minimumTokenValidity from env variable\r\n\r\n### Fixed\r\n- Get uaadomain from subscription manager in case XSUAA is not bound\r\n- Logs reduction -remove stackTrace on error log level\r\n- Websocket try to get status code from message string when statusCode property undefined\r\n- isDynamicRouting read defaultEnv.json file only in development environment\r\n- accessToken references\r\n\r\n### Updated dependencies\r\n- deps: node-forge@1.2.0\r\n\r\n## 10.10.4 - 2021-12-16\r\n\r\n### Fixed\r\n- SameSite cookie property concatenation   \r\n\r\n## 10.10.3 - 2021-12-13\r\n\r\n### Fixed\r\n- Handle bad cookie decryption error\r\n- Fix missing session when token validity too short\r\n- Set client_credentials token by tenant timeout to 5000 ms\r\n- setXForwardedFor remove headers correction\r\n\r\n### Added\r\n- Adding serverKeepAlive from env variable to routerConfig\r\n\r\n### Updated dependencies\r\n- deps: @sap/audit-logging@5.3.0\r\n- deps: debug@4.3.2 \r\n- deps: uuid@8.3.2\r\n- deps: scmp@2.1.0\r\n\r\n## 10.10.2 - 2021-12-02\r\n\r\n### Fixed\r\n- Adding expiration date on login-callback-provider check \r\n- Increase client_credentials token request timeout to 5000 ms\r\n- Protect accessToken references\r\n\r\n### Updated dependencies\r\n- deps: compressible@2.0.18\r\n- deps: sap/xssec@3.2.11\r\n\r\n## 10.10.1 - 2021-11-21\r\n\r\n### Fixed\r\n- Avoid sending certificates if not authentication type is client certificate or trusted certificate\r\n\r\n## 10.10.0 - 2021-11-18\r\n\r\n### Added\r\n- Propagate correlationId to xssec and UAA requests\r\n- Support compression of response content with multipart/mixed content type\r\n\r\n### Fixed\r\n- Subscriber destination consumption in public flows\r\n- Samesite attribute in callback login response header\r\n- Support destination trust certificate propagation (format pem)\r\n\r\n### Updated dependencies\r\n- deps: sap/xssec@3.2.10\r\n\r\n## 10.9.2 - 2021-11-09\r\n\r\n### Fixed\r\n- Backend invalid cookies handling\r\n- Add checking for missing xsappConfig file along with xs-app.json on configuration load\r\n\r\n\r\n### Updated dependencies\r\n- deps: cf-nodejs-logging-support@6.11.0\r\n- deps: validator@13.7.0\r\n\r\n## 10.9.1 - 2021-10-28\r\n\r\n### Fixed\r\n- Missing HTML5 repo token in cache failure \r\n\r\n## 10.9.0 - 2021-10-24\r\n\r\n### Added\r\n- Additional cookie logs\r\n- Support client certificate authentication (format p12)\r\n- Change log level to info for backend logs \r\n- IAS token support in service to approuter flow\r\n\r\n### Updated dependencies\r\n- deps: sap/xssec@3.2.8\r\n\r\n## 10.8.2 - 2021-10-11\r\n\r\n### Fixed\r\n- Remove clientsecret validation for mtls\r\n\r\n## 10.8.1 - 2021-10-07\r\n\r\n### Added\r\n- New audit log SDK support\r\n- Kyma Redis credentials documentation\r\n\r\n### Fixed\r\n- Redis credentials handling in Kyma\r\n- X509 client secret validation in uua schema \r\n\r\n### Updated dependencies\r\n- deps: http-proxy-agent@4.0.1\r\n- deps: https-proxy-agent@5.0.0\r\n- deps: @sap/audit-logging@5.1.0\r\n\r\n## 10.8.0 - 2021-09-13\r\n\r\n### Added\r\n- Propagate destination headers in approuter\r\n\r\n### Fixed\r\n- Sessions expiration in Redis\r\n- Connections to Redis on Azure with premium plan\r\n- Same site support for Lax value\r\n- Request url with code parameter will be directed to authentication, in case it is required\r\n- Session handling documentation\r\n- When application name does not adhere to regex, the request will be directed to main routing configuration file\r\n \r\n## 10.7.1 - 2021-08-30\r\n\r\n### Added\r\n- Skip xs-app.json cache support\r\n- Login with XSUAA certificates \r\n- Mutual Transport Layer Security (mTLS) handling\r\n- Single use token support\r\n\r\n## 10.6.1 - 2021-08-03\r\n\r\n### Fixed\r\n- Subscription callback requests will be directed to main routing configuration file \r\n- App. config response headers modify additional headers value\r\n\r\n## 10.6.0 - 2021-07-28\r\n\r\n### Added\r\n- HTML5 Application Repository Tenant Awareness support\r\n\r\n### Fixed\r\n- nullifying the Redis client when there's a connection issue with Redis\r\n- Clear interval when  calling approuter.close()\r\n\r\n## 10.5.1 - 2021-07-25\r\n\r\n### Fixed\r\n- Return error immediately when reaches login callback middleware via query parameters\r\n\r\n### Updated dependencies\r\n- deps: urijs@1.19.7\r\n\r\n## 10.5.0 - 2021-07-14\r\n\r\n### Added\r\n- Support of the configuration of the minimal logging level for the cf-nodejs-logging-support library\r\n\r\n### Fixed\r\n- Return an error code when calling login callback directly\r\n- Fix for request traces that crash the application router \r\n\r\n## 10.4.3 - 2021-07-05\r\n\r\n### Fixed\r\n- Display log with tenant ID, also when using direct routing URIs\r\n- Support of session management with redis with multiple nodes plans\r\n\r\n## 10.4.2 - 2021-06-13\r\n\r\n### Fixed\r\n- Correcting additional bug when Websocket Proxy is crashing if excluding a route by DIRECT_ROUTING_URI_PATTERN\r\n\r\n## 10.4.1 - 2021-06-09\r\n\r\n### Fixed\r\n- Changing \"favico.ico\" to \"favicon.ico\" as a predefined direct routing URI\r\n- Parsing client certificate for non-CF SMS subscription\r\n- Improving logs in path-rewriter, request-handler, service-to-approuter-middleware, oauth2-strategy\r\n- Adding cache-Control header ('no-cache, no-store') to the User API response\r\n- Correcting a bug when Websocket Proxy is crashing if excluding a route by DIRECT_ROUTING_URI_PATTERN\r\n\r\n### Updated dependencies\r\n- deps: ws@7.4.6\r\n\r\n## 10.4.0 - 2021-05-24\r\n\r\n### Added\r\n- External session management support\r\n\r\n### Fixed\r\n- Client certificate handling for non-CF SMS subscription\r\n- Expose License\r\n\r\n## 10.3.0 - 2021-05-11\r\n\r\n### Added\r\n- CLIENT_CERTIFICATE_HEADER_NAME configuration for non CF flows\r\n- Support of SAP statistics for reporting the request performance\r\n- AfterRequestHandler and backendTimeout extension support\r\n\r\n### Fixed\r\n- Lazy html5-repo client-credentials token creation in case it could not be created during startup\r\n- Added \"login\" as a pre-configured direct URI route to prevent unnecessary calls to the HTML5 Application Repository\r\n\r\n### Updated dependencies\r\n- deps: cf-nodejs-logging-support@6.7.0\r\n\r\n## 10.2.0 - 2021-04-11\r\n\r\n### Added\r\n- Support of routing directly to the routing configuration file (xs-app.json) of the application router using the DIRECT_ROUTING_URI_PATTERNS environment variable \r\n- Caching support for destinations from destination service\r\n\r\n### Fixed\r\n- Verify cookie when IAS and XSUAA bound\r\n- Websockest pong callback handling\r\n- Empty getDependencies configuration handling in SaaS Registry subscription\r\n- Handle SMS apiURLs in K8S\r\n- Encode redirect logout url parameters in case of xsuaa authentication\r\n\r\n## 10.1.0 - 2021-03-21\r\n\r\n### Added\r\n- If you are using Identity Authentication (IAS), you can now use subdomains in multitenant URLs\r\n- Identity Authentication (IAS) is fully supported (no longer a Beta feature)\r\n\r\n### Fixed\r\n- Destination token exchange when using destinations on instance level\r\n\r\n## 10.0.0 - 2021-03-10\r\n\r\n### Added\r\n- Support node version 12 and node version 14 instead of node version 10 and node version 12\r\n\r\n## 9.4.0 - 2021-03-09\r\n\r\n### Added\r\n- Support the consumption of destinations from the provider subaccount via the preferLocal property\r\n- Support of cross-origin resource sharing via the application router configuration file (xs-app.json)\r\n\r\n### Fixed\r\n- logout flow while using system plan XSUAA instance\r\n- missing scope in XSUAA token after refresh\r\n\r\n### Updated dependencies\r\n- deps: lodash@4.17.21\r\n- deps: @sap/audit-logging@4.2.0\r\n- deps: @sap/logging@6.0.3\r\n\r\n## 9.3.0 - 2021-02-24\r\n\r\n### Fixed\r\n- user-api consumption from local approuter\r\n- avoid endless loop when calling approuter with /login/callback\r\n\r\n### Added\r\n- Service to approuter is not beta anymore, README file changed\r\n\r\n### Updated dependencies\r\n- deps: urijs@1.19.6\r\n\r\n## 9.2.0 - 2021-02-14\r\n\r\n### Added\r\n- Support of custom response headers via the application router configuration file (xs-app.json)\r\n\r\n### Fixed\r\n- Verify application key without query parameters\r\n\r\n### Updated dependencies\r\n- deps: e2e-trace@3.0.0\r\n- deps: xsenv@3.1.0\r\n\r\n## 9.1.0 - 2021-01-21\r\n\r\n### Added\r\n- User API\r\n\r\n### Fixed\r\n- Connectivity authentication issue in IAS flow\r\n- Initialize server keepAliveTimeout to zero\r\n\r\n### Updated dependencies\r\n-  deps: @sap/audit-logging@3.2.0\r\n\r\n## 9.0.2 - 2021-01-14\r\n\r\n### Fixed\r\n- Options handling for extensibility case when html5 repo is bound\r\n- Logout request handling when approuter session times out\r\n- Use \"http_header\" section of authTokens from the Destination Service response\r\n\r\n### Updated dependencies\r\n- deps: urijs@1.19.5\r\n\r\n## 9.0.1 - 2020-12-20\r\n\r\n### Fixed\r\n- Subprotocol handling in websockets flows\r\n\r\n### Updated dependencies\r\n- deps: validator@13.5.2\r\n- deps: @sap/logging@6.0.2\r\n\r\n## 9.0.0 - 2020-12-06\r\n\r\n### Added\r\n- IAS authentication support\r\n- Forward IAS token to destination\r\n- IAS authentication with  XSUAA authorization\r\n- Subscription manager (SMS) support\r\n\r\n### Updated dependencies\r\n- deps: base64-url@2.3.3\r\n\r\n## 8.6.1 - 2020-11-25\r\n\r\n### Fixed\r\n- Wrong application URL protocol returned by onSubscription callback additional fix\r\n\r\n## 8.6.0 - 2020-11-19\r\n\r\n### Fixed\r\n- Wrong application URL protocol returned by onSubscription callback\r\n\r\n## 8.5.5 - 2020-10-21\r\n\r\n### Fixed\r\n- Destination middleware improvement\r\n\r\n## 8.5.4 - 2020-10-14\r\n\r\n### Fixed\r\n- Fix invalid backend response handling\r\n\r\n## 8.5.3 - 2020-10-06\r\n\r\n### Fixed\r\n- Do not forward SAP-Connectivity-Authentication header in onPremise flows if destination authentication type is NoAuthentication\r\n\r\n## 8.5.2 - 2020-09-21\r\n\r\n### Fixed\r\n- Handle SameSite:None value in client side cookies (signature, locationAfterLogin and fragmentAfterLogin)\r\n\r\n## 8.5.1 - 2020-08-25\r\n\r\n### Updated dependencies\r\n- deps: lodash@4.17.20\r\n- deps: sap/logging@5.3.1\r\n- deps: cf-nodejs-logging-support@6.4.3\r\n\r\n### Fixed\r\n- Avoid crash if user provided service without credentials\r\n- Don't forward auth token to connectivity in service2approuter flow if destination.forwardToken = false\r\n\r\n## 8.5.0 - 2020-08-10\r\n\r\n### Updated dependencies\r\n- deps: @sap/audit-logging@3.1.1\r\n- deps: request@2.88.2\r\n- deps: @sap/xssec@3.0.9\r\n- deps: lodash@4.17.19\r\n- deps: ws@7.3.1\r\n\r\n### Fixed\r\n- Pass tenant id in service to approuter audit log message\r\n\r\n## 8.4.1 - 2020-08-02\r\n\r\n### Fixed\r\n- Fix token exchange for Business Service access\r\n\r\n## 8.4.0 - 2020-08-02\r\n\r\n### Added\r\n- Support merge of approuter and backend content-security-policy headers\r\n- Support cookie merge in service2Approuter flow\r\n\r\n### Fixed\r\n- Handle undefined user in refresh token flow\r\n\r\n## 8.3.1 - 2020-07-26\r\n\r\n### Fixed\r\n- Upgrade xssec version to 3.0.7 - fix big tokens exchange error\r\n\r\n## 8.3.0 - 2020-07-23\r\n\r\n### Fixed\r\n- Fix missing subdomain in exchange token\r\n\r\n## 8.2.2 - 2020-07-15\r\n\r\n### Fixed\r\n- Adapt to changes in @sap/xssec-3.0.6 - replace secContext private subdomain property by getSubdomain method\r\n- Fix websocket pong behavior when status is not open\r\n\r\n## 8.2.1 - 2020-07-09\r\n\r\n### Fixed\r\n- SAP Passport header handling fixed in service 2 approuter flow\r\n\r\n## 8.2.0 - 2020-07-02\r\n\r\n### Fixed\r\n- Passport handling fix in service 2 approuter flow â€“ increment counter\r\n\r\n### Updated dependencies\r\n- deps: sap/xssec@3.0.6\r\n\r\n## 8.1.1 - 2020-06-24\r\n\r\n### Announcement\r\n- The Preserve URL fragment (PRESERVE_FRAGMENT) will not be deprecated as previously announced.\r\n\r\n### Fixed\r\n- Bug correction in forwardAuthToken in business service flow\r\n\r\n## 8.1.0 - 2020-06-14\r\n\r\n### Added\r\n- Added fallback mechanism for html5 repo client_credentials token refresh\r\n- Security improvement for signature verifying during login\r\n\r\n### Fixed\r\n- Bug fix when calling connectivity in a non-authenticated flow (no login in approuter)\r\n\r\n## 8.0.0 - 2020-05-26\r\n\r\n### Updated dependencies\r\n - deps: @sap/xssec@3.0.3\r\n\r\n### Removed\r\n- Remove of SAP_JWT_TRUST_ACL environment variable support (functionality now comes with audience validation)\r\n\r\n## 7.1.3 - 2020-05-17\r\n\r\n### Added\r\n- Enhances of the x-approuter-authorization token security check in the service2Approuter flow.\r\n\r\n## 7.1.2 - 2020-05-08\r\n\r\n### Fixed\r\n- Fix appurl usage of x-subscriber-tenant\r\n\r\n## 7.1.1 - 2020-05-05\r\n\r\n### Added\r\n- Cache improvements\r\n- Usage of x-subscriber-tenant header when provided.\r\n- handle html5 repo and xsuaa destinations separately\r\n\r\n### Fixed\r\n- Fix connectivity token handling for Kubernetes\r\n\r\n## 7.1.0 - 2020-04-16\r\n\r\n### Added\r\n- Enable service logout configuration in central xs-app.json.\r\n### Fixed\r\n- Destination token cached in session is never refreshed.\r\n\r\n## 7.0.0 - 2020-04-06\r\n\r\n### Added\r\n- Support node version 10 and node version 12 instead of node version 8 and node version 10\r\n\r\n## 6.8.2 - 2020-03-04\r\n\r\n### Fixed\r\n- Fix extension of resolveUaaConfig\r\n\r\n## 6.8.1 - 2020-02-20\r\n\r\n### Fixed\r\n- Fix default route\r\n\r\n## 6.8.0 - 2020-02-10\r\n\r\n### Added\r\n- Enable external session manager extensibility when using HTML5 Repository\r\n\r\n## 6.7.2 - 2020-01-30\r\n\r\n### Added\r\n- Support SameSite cookie attribute\r\n\r\n### Updated dependencies\r\n - deps: express-session@1.17.0\r\n - deps: @sap/logging@5.2.0\r\n\r\n## 6.7.1 - 2019-12-24\r\n\r\n### Added\r\n- Backend cookies secret variable (BACKEND_COOKIES_SECRET) Secret that is used to encrypt backend session cookies in service to Application Router flow. Should be set in case multiple instances of Application Router are used. By default a random sequence of characters is used.\r\n\r\n\r\n## 6.7.0 - 2019-11-24\r\n\r\n### Added\r\n- Enhance the use of the xsenv@2.1.0 library to access bound destination service credentials, which support reading destination service credentials in Kubernetes.\r\n\r\n### Fixed\r\n- Anonymous login on destination flow\r\n\r\n## 6.6.0 - 2019-11-12\r\n\r\n### Announcement\r\n- The Preserve URL fragment (PRESERVE_FRAGMENT) is being deprecated and will be removed in the near future\r\n\r\n### Updated dependencies\r\n- deps: sap/xsenv@2.1.0 Application Router uses xsenv library to access bound services credentials. We have upgraded the library to xsenv version 2.1.0 which supports reading credentials in Kubernetes.\r\n- deps: https-proxy-agent@2.2.4\r\n## 6.5.1 - 2019-10-10\r\n\r\n### Fixed\r\n- Adding sec-websocket-protocol header as the protocol of websockets\r\n\r\n## 6.5.0 - 2019-10-03\r\n\r\n### Added\r\n- Timeout for Business Service\r\n\r\n### Fixed\r\n- Adding destination token middleware for websockets\r\n\r\n## 6.4.1 - 2019-09-23\r\n\r\n### Fixed\r\n- CSP header fix return frame-ancestors in login\r\n\r\n## 6.4.0 - 2019-09-16\r\n\r\n### Added\r\n- Allowed dynamic destinations \r\n- Return CSP header with no cache\r\n- Added setXForwardedHeaders option\r\n\r\n## 6.3.0 - 2019-09-10\r\n\r\n### Added\r\n- Support Cache-Control for static content from html5-repo\r\n\r\n## 6.2.0 - 2019-09-03\r\n\r\n### Added\r\n- Support Subscription url from vcap.\r\n- Adding validation - Session created for one tenant must not be used by other tenants\r\n\r\n### Updated dependencies\r\n - deps: @sap/xssec@2.2.2\r\n\r\n## 6.1.2 - 2019-08-28\r\n- Support Xsuaa credentials in request body\r\n\r\n## 6.1.1 - 2019-08-27\r\n- Fix in destination middleware - session.update\r\n \r\n## 6.1.0 - 2019-07-31\r\n\r\n### Added\r\n- Support for redirection to logout page with query parameters after central logout\r\n- Connectivity is now returned in subscription getDependencies callback\r\n\r\n### Fixed\r\n- Error when processing unknown authentication types\r\n\r\n## 6.0.2 - 2019-07-14\r\n\r\n### Fixed\r\n- Validation of destination with OnPremise proxyType\r\n- CSRF protection in Service to Approuter flow\r\n### Updated dependencies\r\n- deps: lodash@4.17.13\r\n\r\n## 6.0.1 - 2019-05-30\r\n\r\n### Fixed\r\n- Fixed TypeError bug when Approuter saves a cookie from backend and should logout when session timeout exceeded. \r\n- Fixed calculation of location after login.\r\n\r\n## 6.0.0 - 2019-05-06\r\n\r\n### Added\r\n- Support node version 8 and node version 10 instead of node version 4.5 and node version 6\r\n\r\n## 5.15.0 - 2019-04-29\r\n\r\n### Added\r\n- Support for Service to Application Router functionality (Beta version).\r\n- Added destination in host support.\r\n\r\n## 5.14.1 - 2019-04-17\r\n\r\n### Added\r\n- Enhanced Approuter application logs when serving of static content (from HTML5 App Repo) was failed.\r\n\r\n### Fixed\r\n- Fixed subscription callbacks url.\r\n\r\n## 5.14.0 - 2019-04-04\r\n\r\n### Added\r\n- Websockets support for HTML5 Application Repository.\r\n\r\n### Fixed\r\n- onSubscription callback.\r\n\r\n## 5.13.1 - 2019-03-27\r\n\r\n### Added\r\n- Added automatic recovery of Approuter after recovery of UAA.\r\n\r\n### Fixed\r\n- Fixed subscription callbacks url.\r\n- Fixed avoid central appConfig routes overrides.\r\n\r\n### Updated dependencies\r\n - deps: @sap/xssec@2.1.16\r\n\r\n## 5.13.0 - 2019-02-14\r\n\r\n### Added\r\n- Ability to define identity provider for authentication in the route.\r\n\r\n## 5.12.0 - 2019-02-05\r\n\r\n### Added\r\n- Dynamic destination support.\r\n\r\n## 5.11.0 - 2019-01-22\r\n\r\n### Added\r\n- Client credentials token support.\r\n\r\n## 5.10.2 - 2019-01-08\r\n\r\n### Fixed\r\n- Fix proxy issue in Connectivity flow.\r\n\r\n## 5.10.1 - 2019-01-03\r\n\r\n### Fixed\r\n- Fixed flow of access destination via desination service.\r\n\r\n## 5.10.0 - 2018-12-30\r\n\r\n### Added\r\n- Propagation of approuter host during logout.\r\n\r\n## 5.9.0 - 2018-12-18\r\n\r\n### Added\r\n- Ability to change destination without restarting application on CF\r\n- Access destination that is exposed on destination service instance level.\r\n- Enabled all authentication types defined in the destination service.\r\n\r\n## 5.8.0 - 2018-10-27\r\n\r\n### Fixed\r\n- Fix login flow for URLs with empty query (URL that ends with '?').\r\n\r\n### Added\r\n- Documentation of integration with HTML5 Apps Repo.\r\n\r\n### Updated dependencies\r\n - deps: ws@1.1.5\r\n - deps: lodash@4.17.11\r\n - deps: @sap/logging@4.0.2\r\n    - deps: lodash@4.17.11\r\n\r\n## 5.7.0 - 2018-10-08\r\n\r\n### Added\r\n - Propagate client id to UAA during Logout\r\n \r\n## 5.6.4 - 2018-08-27\r\n\r\n### Updated dependencies\r\n- deps: @sap/audit-logging@2.2.4\r\n- deps: sync-request@5.0.0\r\n     \r\n### Fixed\r\n- Duplicate destination names in xs-app.json bug\r\n\r\n## 5.6.3 - 2018-08-15\r\n\r\n### Updated dependencies\r\n - deps: e2e-trace@1.3.0\r\n - deps: xssec@2.1.15\r\n    - deps: request@2.88.0\r\n\r\n### Fixed\r\n - Fix bug of post/put requests with content/type=application/json\r\n\r\n## 5.6.2 - 2018-08-09\r\n\r\n### Updated dependencies\r\n - deps: serve-static@1.13.2\r\n    - deps: send@0.16.1\r\n\t     - deps: mime@1.4.1\r\n\t     - \tdeps: debug@2.6.9\r\n\r\n### Fixed\r\n - Fix error in case of local destination and UAA with tenant mode shared\r\n \r\n## 5.6.1 - 2018-08-07\r\n\r\n### Updated dependencies\r\n - deps: body-parser@1.18.3\r\n - deps: uid-safe@2.1.5\r\n - deps: @sap/xssec@2.1.9\r\n - deps: send@0.16.2\r\n - deps: compression@1.7.3\r\n - deps: express-session@1.15.6\r\n - deps: connect@3.6.5\r\n\r\n## 5.6.0 - 2018-08-05\r\n\r\n### Added\r\n - Added SaaS application registration support (subscription)\r\n - Enhanced usage of PreserveHostHeader additional property\r\n\r\n### Fixed\r\n - Fix error handling in case of bad signature\r\n\r\n## 5.5.0 - 2018-07-19\r\n\r\n### Added\r\n - Added optional additional properties 'PreserveHostHeader' to Destination service\r\n - Added optional additional properties 'sap-client' to Destination service\r\n\r\n## 5.4.2 - 2018-07-04\r\n\r\n### Fixed\r\n - Fix refresh page location after timeout bug\r\n - Fix fragment cookie name bug\r\n - Fix vulnerabilities issues\r\n \r\n## 5.4.1 - 2018-06-25\r\n \r\n### Fixed\r\n - Fix logout bug\r\n\r\n## 5.4.0 - 2018-06-10\r\n\r\n### Added\r\n - Support extensibility of logout end-point \r\n \r\n### Fixed\r\n - Fix vulnerabilities issues\r\n\r\n## 5.3.0 - 2018-05-13\r\n\r\n### Added\r\n - Enable extended session management\r\n - Enable Correlation ID propagation\r\n\r\n## 5.2.1 - 2018-05-02\r\n\r\n### Added\r\n - Support audit log service\r\n\r\n## 5.2.0 - 2018-04-16\r\n\r\n### Added\r\n - Support routing to destination with authentication type OAuth2SAMLBearerAssertion\r\n\r\n### Fixed\r\n - Fix bug in forward undefine token\r\n\r\n\r\n## 5.1.0 - 2018-03-14\r\n\r\n### Added\r\n - Support destination configuration from destination service\r\n\r\n### Fixed\r\n - Fix bug in trace functionality\r\n - Fix bug in fragment functionality\r\n\r\n## 5.0.0 - 2018-01-29\r\n\r\n### Fixed\r\n - Minor fix in destinations handling in Extension flow.\r\n - Fix fragment handling in URL during Login flow.\r\n \r\n## 4.0.1 - 2018-01-01\r\n\r\n### Fixed\r\n - Minor fixes in CORs.\r\n\r\n## 4.0.0 - 2017-12-18\r\n\r\n### Added\r\n - Application router can consume content from the HTML5 application repository.\r\n\r\n### Fixed\r\n - Fix in headers handling when using CF destination and onPremise destination in same xs-app.json.\r\n - Minor fix in CORs.\r\n\r\n## 3.0.1 - 2017-10-08\r\n\r\n### Removed\r\n - Node 0.12 support.\r\n \r\n## 2.10.0 - 2017-07-30\r\n\r\n### Added\r\n - Enabled connectivity to on premise backend.\r\n - Added external reverse proxy support.\r\n\r\n### Fixed\r\n - Fix CSRF token generation to use a Secure Random number generator.\r\n\r\n## 2.9.1 - 2017-06-29\r\n\r\n### Fixed\r\n - Minor fixes in CORs.\r\n - Introduce CORs feature in README.md.\r\n \r\n## 2.9.0 - 2017-06-27\r\n\r\n### Added\r\n - Support for CORs functionality.\r\n\r\n## 2.8.2 - 2017-06-13\r\n\r\n### Fixed\r\n - Fix cancel request.\r\n - Fix logout in dynamic routing.\r\n\r\n## 2.8.1 - 2017-06-01\r\n\r\n### Fixed\r\n - Fixes in documentation of dynamic routing and troubleshooting section.\r\n - Fix logout when using websocket.\r\n\r\n## 2.8.0 - 2017-04-26\r\n\r\n### Added\r\n - Introduce table of contents in README.md.\r\n - Added JWT refresh in websocket connections.\r\n - Significant performance improvements via adopting @sap/logging version 3\r\n\r\n## 2.7.1 - 2017-03-20\r\n\r\n### Fixed\r\n - Add username to logs.\r\n - Minor fixes in websockets and session handling.\r\n\r\n## 2.7.0 - 2017-02-13\r\n\r\n### Added\r\n- Replacements from services.\r\n- Start approuter on https\r\n- Show warning when a route is explicitly both public and csrf protected.\r\n\r\n### Fixed\r\n- Should not escape client cookies.\r\n- Redirect to welcome page if not CSRF token fetch request.\r\n- Wrong basic authentication status codes.\r\n\r\n## 2.6.1 - 2017-01-25\r\n\r\n### Changed\r\n- Rename package to use @sap scope\r\n\r\n## 2.6.0 - 2017-01-25\r\n\r\n### Added\r\n- `REQUEST_TRACE` environment variable for enhanced request tracing.\r\n- Support for PATCH in router configuration.\r\n- New extensions - see extending.md.\r\n\r\n### Removed\r\n- Customizable UAA config resolution.\r\n\r\n### Fixed\r\n- Fixes in documentation.\r\n- Handling of request protocol.\r\n- Removed npm 2 restriction.\r\n\r\n## 2.5.0 - 2016-12-13\r\n\r\n### Added\r\n- Enable customizable UAA config resolution\r\n- Support for custom error pages (errorPage in xs-app.json)\r\n- Extend sizing guide\r\n\r\n### Fixed\r\n- Crash in error handler due to missing logger.\r\n- Does not cache login responses.\r\n- Does not log UAA missing when not needed.\r\n- In case of parallel logins Approuter may use wrong user.\r\n- Does not send basic credentials to backend, unless route is public.\r\n\r\n## 2.4.0 - 2016-11-16\r\n\r\n### Added\r\n- Introduce SECURE_SESSION_COOKIE environment variable - enforces the secure flag of application router's session cookie.\r\n- Additional checks for regular expressions during startup.\r\n\r\n### Changed\r\n- Previous component name in sap passport has been changed to 'XSA Approuter'.\r\n\r\n### Fixed\r\n - Missing logging context in error handler when using extensions.\r\n\r\n## 2.3.4 - 2016-11-04\r\n\r\n### Fixed\r\n- The _x-csrf-token_ header is no longer forwarded to backend in case a path requires authentication and CSRF token protection.\r\n- Set the _Secure_ flag of the session cookie depending on the environment application router runs in.\r\n- Some of the links in README.md were broken.\r\n\r\n## 2.3.3 - 2016-11-02\r\n\r\n### Added\r\n-\tAdd COMPRESSION env var to be able to configure compression.\r\n\r\n### Fixed\r\n- Do not cache wsAllowedOrigins across requests.\r\n- Favor UAA config from default-env.json over default-services.json.\r\n-\tExtend error message for proxy settings problem.\r\n-\tEnable compression by default when custom setting is provided.\r\n-\tPropagate errors to handler.\r\n- Avoid session resave at the end of request. Fix session overwrite.\r\n\r\n## 2.3.2 - 2016-09-30\r\n\r\n### Fixed\r\n- Cookie locationAfterLogin clash in port based routing.\r\n\r\n## 2.3.1 - 2016-09-28\r\n\r\n### Fixed\r\n- Unverified redirect via locationAfterLogin cookie.\r\n- Fallback to default UAA if no tenant captured.\r\n- Fix X-Frame-Options header overwriting.\r\n- Session cookie name - use application_id instead of instance_id.\r\n- Fix port validation for approuter.start().\r\n\r\n## 2.3.0 - 2016-09-02\r\n\r\n### Added\r\n- Multitenancy support.\r\n- Matching route by both URL path and HTTP method.\r\n\r\n### Fixed\r\n- Fixed race condition while CSRF token generation.\r\n\r\n## 2.2.0 - 2016-08-17\r\n\r\n### Added\r\n- Start approuter with xs-app.json passed as an object.\r\n- Follow symlinks in localDir config.\r\n- Document the Content-Security-Policy header as a best practice.\r\n\r\n## 2.1.3 - 2016-08-13\r\n\r\n### Added\r\n- Genarate CSRF token once per session.\r\n\r\n## 2.1.2 - 2016-08-06\r\n\r\n### Fixed\r\n- Remove instance cookies from client request.\r\n- Fix locatioinAfterLogin cookie path.\r\n\r\n## 2.1.1 - 2016-07-24\r\n\r\n### Fixed\r\n- Support to host welcome page externally.\r\n- Fix logout path matching.\r\n- Fix 500 sent in case locationAfterLogin cookie is missing.\r\n\r\n\r\n## 2.1.0 - 2016-07-17\r\n\r\n### Added\r\n- Allow source of route to be matched in case-insensitive way.\r\n- New configuration for maximum client connection timeout.\r\n- Add support for approuter extensions (custom middleware).\r\n- Allow fetching CSRF token with HEAD request.\r\n\r\n## 2.0.0 - 2016-05-12\r\n\r\n### Added\r\n- Configuration for the Cache-Control header in xs-app.json. The header is used when serving static resources.\r\n\r\n### Removed\r\n- local-* files (e.g. local-destinations, local-plugins) can no longer be used in the approuter during local development. Instead of these the approuter reads a single file located in the working directory (default-env.json), which contains the corresponding environment variables (e.g. destinations, plugins) and their values.\r\n"},{"name":"doc","nodes":[{"name":"doc","nodes":[{"name":"extending.md","content":"Extending Application Router\r\n============================\r\n\r\n<!-- toc -->\r\n\r\n- [Basics](#basics)\r\n- [Inject Custom Middleware](#inject-custom-middleware)\r\n- [Application Router Extensions](#application-router-extensions)\r\n- [Customize Command Line](#customize-command-line)\r\n- [Dynamic Routing](#dynamic-routing)\r\n- [State synchronization](#state-synchronization)\r\n- [API Reference](#api-reference)\r\n  * [approuter](#approuter)\r\n    + [`approuter()`](#approuter)\r\n    + [Event: 'login'](#event-login)\r\n    + [Event: 'logout'](#event-logout)\r\n    + [`first`](#first)\r\n    + [`beforeRequestHandler`](#beforerequesthandler)\r\n    + [`afterRequestHandler`](#afterrequesthandler)\r\n      [`backendTimeout`](#backendtimeout)\r\n    + [`beforeErrorHandler`](#beforeerrorhandler)\r\n    + [`start(options, callback)`](#startoptions-callback)\r\n    + [`close(callback)`](#closecallback)\r\n    + [`createRouterConfig(options, callback)`](#createrouterconfigoptions-callback)\r\n    + [`resolveUaaConfig(request, uaaOptions, callback)`](#resolveuaaconfigrequest-uaaoptions-callback)\r\n  * [Middleware Slot](#middleware-slot)\r\n    + [`use(path, handler)`](#usepath-handler)\r\n\r\n<!-- tocstop -->\r\n\r\n## Basics\r\nInsead of starting the application router directly, your application can have its own start script.\r\nYou can use the application router as a regular Node.js package.\r\n```js\r\nvar approuter = require('@sap/approuter');\r\n\r\nvar ar = approuter();\r\nar.start();\r\n```\r\n\r\n## Inject Custom Middleware\r\n\r\nThe application router uses the [connect](https://github.com/senchalabs/connect)\r\nframework.\r\nYou can reuse all _connect_ middlewares within the application router directly.\r\nYou can do this directly in your start script:\r\n```js\r\nvar approuter = require('@sap/approuter');\r\n\r\nvar ar = approuter();\r\n\r\nar.beforeRequestHandler.use('/my-ext', function myMiddleware(req, res, next) {\r\n  res.end('Request handled by my extension!');\r\n});\r\nar.start();\r\n```\r\n__Tip:__ Name your middleware to improve troubleshooting.\r\n\r\nThe path argument is optional. You can also chain `use` calls.\r\n```js\r\nvar approuter = require('@sap/approuter');\r\nvar morgan = require('morgan');\r\n\r\nvar ar = approuter();\r\n\r\nar.beforeRequestHandler\r\n  .use(morgan('combined'))\r\n  .use('/my-ext', function myMiddleware(req, res, next) {\r\n    res.end('Request handled by my extension!');\r\n  });\r\nar.start();\r\n```\r\n\r\nThe application router defines the following slots where you can insert custom middleware:\r\n* `first` - right after the _connect_ application is created, and before any\r\napplication router middleware.\r\nAt this point security checks are not performed yet.\r\n__Tip:__ This is a good place for infrastructure logic like logging and monitoring.\r\n* `beforeRequestHandler` - before standard application router request handling,\r\nthat is static resource serving or forwarding to destinations.\r\n__Tip:__ This is a good place for custom REST API handling.\r\n* `beforeErrorHandler` - before standard application router error handling.\r\n__Tip:__ This is a good place to capture or customize error handling.\r\n\r\nIf your middleware does not complete the request processing, call `next`\r\nto return control to the application router middleware:\r\n```js\r\nar.beforeRequestHandler.use('/my-ext', function myMiddleware(req, res, next) {\r\n  res.setHeader('x-my-ext', 'passed');\r\n  next();\r\n});\r\n```\r\n\r\n## Application Router Extensions\r\n\r\nYou can use application router extensions.\r\n\r\nAn extension is defined by an object with the following properties:\r\n* `insertMiddleware` - describes the middleware provided by this extension\r\n  * `first`, `beforeRequestHandler`, `beforeErrorHandler` - an array of middleware, where each one is either\r\n    * a middleware function (invoked on all requests), or\r\n    * an object with properties:\r\n      * `path` - handle requests only for this path\r\n      * `handler` - middleware function to invoke\r\n\r\nHere is an example (my-ext.js):\r\n```js\r\nmodule.exports = {\r\n  insertMiddleware: {\r\n    first: [\r\n      function logRequest(req, res, next) {\r\n        console.log('Got request %s %s', req.method, req.url);\r\n      }\r\n    ],\r\n    beforeRequestHandler: [\r\n      {\r\n        path: '/my-ext',\r\n        handler: function myMiddleware(req, res, next) {\r\n          res.end('Request handled by my extension!');\r\n        }\r\n      }\r\n    ]\r\n  }\r\n};\r\n```\r\nYou can use it in your start script like this:\r\n```js\r\nvar approuter = require('@sap/approuter');\r\n\r\nvar ar = approuter();\r\nar.start({\r\n  extensions: [\r\n    require('./my-ext.js')\r\n  ]\r\n});\r\n```\r\n\r\n## Customize Command Line\r\n\r\nBy default the application router handles its command line parameters, but you can\r\ncustomize that too.\r\n\r\nAn _approuter_ instance provides the property `cmdParser` that is a\r\n[commander](https://github.com/tj/commander.js/) instance.\r\nIt is configured with the standard application router command line options.\r\nThere you can add custom options like this:\r\n```js\r\nvar approuter = require('@sap/approuter');\r\n\r\nvar ar = approuter();\r\n\r\nvar params = ar.cmdParser\r\n  // add here custom command line options if needed\r\n  .option('-d, --dummy', 'A dummy option')\r\n  .parse(process.argv);\r\n\r\nconsole.log('Dummy option:', params.dummy);\r\n```\r\nTo completely disable the command line option handling in the application router,\r\nreset the following property:\r\n```js\r\nar.cmdParser = false;\r\n```\r\n\r\n## Dynamic Routing\r\n\r\nThe application router can use a custom routing configuration for each request.\r\n\r\nHere is an example:\r\n```js\r\nvar approuter = require('@sap/approuter');\r\n\r\nvar ar = approuter();\r\nar.start({\r\n  getRouterConfig: getRouterConfig\r\n});\r\n\r\nvar customRouterConfig;\r\nvar options = {\r\n  xsappConfig: {\r\n    routes: [\r\n      {\r\n        source: '/service',\r\n        destination: 'backend',\r\n        scope: '$XSAPPNAME.viewer',\r\n      }\r\n    ]\r\n  },\r\n  destinations: [\r\n    {\r\n      name: 'backend',\r\n      url: 'https://my.app.com',\r\n      forwardAuthToken: true\r\n    }\r\n  ],\r\n  xsappname: 'MYAPP'\r\n};\r\nar.createRouterConfig(options, function(err, routerConfig) {\r\n  if (err) {\r\n    console.error(err);\r\n  } else {\r\n    customRouterConfig = routerConfig;\r\n  }\r\n});\r\n\r\nfunction getRouterConfig(request, callback) {\r\n  if (/\\?custom-query/.test(request.url)) {\r\n    callback(null, customRouterConfig);\r\n  } else {\r\n    callback(null, null); // use default router config\r\n  }\r\n}\r\n```\r\n\r\n## State synchronization\r\n\r\nThe application router can be scaled to run with multiple instances like any other application on Cloud Foundry.\r\nStill application router instances are not aware of each other and there is no communication among them.\r\nSo if extensions introduce some state, they should take care to synchronize it across application router instances.\r\n\r\n## API Reference\r\n\r\n### approuter\r\n\r\n#### `approuter()`\r\n\r\nCreates a new instance of the application router.\r\n\r\n#### Event: 'login'\r\nParameters:\r\n* `session`\r\n  * `id` - session id as a string\r\n\r\nEmitted when a new user session is created.\r\n\r\n#### Event: 'logout'\r\nParameters:\r\n* `session`\r\n  * `id` - session id as a string\r\n\r\nEmitted when a user session has expired or a user has requested to log out.\r\n\r\n#### `first`\r\nA [Middleware Slot](#middleware-slot) before the first application router middleware\r\n\r\n#### `beforeRequestHandler`\r\nA [Middleware Slot](#middleware-slot) before the standard application router request handling\r\n\r\n#### `afterRequestHandler`\r\nA function that can be added to the request object - for example in a \"first\" or \"beforeRequestHandler\" extension.\r\nIf exists, this function will be called by the standard application router after the standard backend response handling is completed.\r\nInput: \r\n* `ctx` context object containing the following properties\r\n  * `incomingRequest` the request sent from client to application router\r\n  * `incomingResponse` the response that will be sent from application router to client\r\n  * `outgoingRequest` the request sent from application router to backend application\r\n  * `outgoingResponse` the response that was received in application router from backend application\r\n* `done` a callback function that receives (optionally) and error and the modified incomingResponse\r\n    \r\nNote that this function is called after standard application router headers processing. Data piping is not modified. \r\nIf an error is passed to done callback it will be just logged, piping process will not be stopped. Note that also in case of error the incomingResponse object should be returned.\r\n\r\nExample:\r\n```js\r\nvar approuter = require('@sap/approuter');\r\nvar ar = approuter();\r\nar.first.use('/backend', function (req, res, next) {\r\n    req.afterRequestHandler = function(ctx, done){\r\n        if (ctx.outgoingResponse.statusCode === 200) {\r\n          let incomingResponse = ctx.incomingResponse;\r\n          incomingResponse.setHeader('header1', 'abc');\r\n          done(null, incomingResponse);\r\n        } else {\r\n          done('An error occurred in backend, returned status ' + ctx.outgoingResponse.statusCode, ctx.incomingResponse);\r\n        }\r\n    };\r\n    next();\r\n});\r\nar.start();\r\n```\r\n#### `backendTimeout`\r\nA function that can be added to the request object - for example in a \"first\" or \"beforeRequestHandler\" extension.\r\nIf exists, this function will be called by the standard application router when a backend connection timeout occurs.\r\nInput:\r\n* `req` the request object\r\n* `done` a callback function that doesn't return any parameter\r\n\r\n#### `beforeErrorHandler`\r\nA [Middleware Slot](#middleware-slot) before the standard application router error handling\r\n\r\n#### `start(options, callback)`\r\n\r\nStarts the application router with the given options.\r\n\r\n* `options` this argument is optional. If provided, it should be an object which can have any of the following properties:\r\n  * `port` - a TCP port the application router will listen to (string, optional)\r\n  * `workingDir` - the working directory for the application router,\r\n  should contain the _xs-app.json_ file (string, optional)\r\n  * `extensions` - an array of extensions, each one is an object as defined in\r\n  [Application Router Extensions](#application-router-extensions) (optional)\r\n  * `xsappConfig` - An object representing the content which is usually put in xs-app.json file.\r\n  If this property is present it will take precedence over the content of xs-app.json. (optional)\r\n  * `httpsOptions` - Options similar to [`https.createServer`](https://nodejs.org/api/https.html#https_https_createserver_options_requestlistener).\r\n  If this property is present, application router will be started as an https server. (optional)\r\n  * `getToken` - `function(request, callback)` Provide custom access token (optional)\r\n    * `request` - Node request object\r\n    * `callback` - `function(error, token)`\r\n      * `error` - Error object in case of error\r\n      * `token` - Access token to use in request to backend\r\n  * `getRouterConfig` - `function(request, callback)` Provide custom routing configuration (optional)\r\n    * `request` - Node request object\r\n    * `callback` - `function(error, routerConfig)`\r\n      * `error` - Error object in case of error\r\n      * `routerConfig` - Custom routing configuration to use for given request.\r\n      This object should be created via `createRouterConfig`.\r\n      If `null` or `undefined`, default configuration will be used.\r\n      \r\n    **Note:** When approuter is bound to html5 repository, you cannot provide getRouterConfig function.\r\n    \r\n* `callback` - optional function with signature `callback(err)`.\r\nIt is invoked when the application router has started or an error has occurred.\r\nIf not provided and an error occurs (e.g. the port is busy), the application will abort.\r\n\r\n#### `close(callback)`\r\nStops the application router.\r\n\r\n* `callback` - optional function with signature `callback(err)`.\r\nIt is invoked when the application router has stopped or an error has occurred.\r\n\r\n#### `createRouterConfig(options, callback)`\r\nPrepares the routing configuration to be used by the application router.\r\nAs part of this, the application router validates the given options.\r\nThis function can be used at any point in runtime to create additional routing configurations.\r\n\r\n**Note:** This function can be called only after `start` function.\r\n\r\n* `options`\r\n  * `xsappname` - Value to replace $XSAPPNAME placeholder in scope names.\r\n  If not provided, it will be taken from UAA service binding. (optional)\r\n  * `xsappConfig` - An object representing the content which is usually put in xs-app.json file.\r\n**Note:** Only the following configurations are taken into account from this property (the rest are taken from the xs-app.json file):\r\n`welcomeFile`, `logout.logoutEndpoint`, `logout.logoutPage`, `routes`, `websockets`, `errorPage`.\r\n  * `destinations` - An array containing the configuration of the backend destinations.\r\n  If not provided, it will be taken from `destinations` environment variable. (optional)\r\n* `callback` - `function(error, routerConfig)`\r\n  * `error` - Error object in case of error\r\n  * `routerConfig` - Routing configuration to be passed to the callback of `getRouterConfig`.\r\n  Approuter extensions should not access the content of this object.\r\n\r\n#### `resolveUaaConfig(request, uaaOptions, callback)`\r\n\r\nCalculates tenant-specific UAA configuration.\r\n\r\n* `request` - node request object used to identify the tenant\r\n* `uaaOptions` - UAA options as provided in service binding\r\n* `callback` - `function(error, tenantUaaOptions)`\r\n  * `error` - Error object in case of error\r\n  * `tenantUaaOptions` - new UAA configuration with tenant-specific properties\r\n\r\n### Middleware Slot\r\n\r\n#### `use(path, handler)`\r\nInserts a request handling middleware in the current slot.\r\n\r\n* `path` - handle only requests starting with this path (string, optional)\r\n* `handler` - a middleware function to invoke (function, mandatory)\r\n\r\nReturns `this` for chaining.\r\n"},{"name":"sessionManagement.md","content":"Extended Session Management\r\n===========================\r\n\r\n<!-- toc -->\r\n\r\n- [Abstract](#abstract)\r\n- [Session Lifecycle](#session-lifecycle)\r\n- [Security](#security)\r\n- [Data Privacy](#data-privacy)\r\n- [API Reference](#api-reference)\r\n- [Example](#example)\r\n- [Performance](#performance)\r\n- [Custom Storage Driver](#custom-storage-driver)\r\n- [Credentials Structure](#credentials-structure)\r\n\r\n<!-- tocstop -->\r\n\r\n## Abstract\r\n\r\nThe application router uses a memory store as a session repository to provide\r\nthe best runtime performance. However, it is not persisted and it is not shared\r\nacross multiple instances of the application router. \r\n\r\n*__Note:__ The Limitations above do not prevent the application router from\r\nbeing scaled out, since session stickiness is in place by default.* \r\n\r\nWhile it is good enough for most of the cases, it may be required to\r\nprovide a highly-available solution, which may be achieved by storing\r\nthe state (session) of the application router outside - in durable shared\r\nstorage.\r\nTo allow implementing these qualities, the application router exposes the\r\n*extended session management* API described below.\r\n\r\n## Session Lifecycle\r\n\r\nThe application router stores user agent sessions as JavaScript objects \r\nserialized to strings. It also stores the session timeout associated with\r\neach session, which indicates the amount of time left until session\r\ninvalidation. \r\n\r\n### Initial Data\r\n\r\nDuring the start of the application router, the internal session store is initiated.\r\nIt contains an empty list of sessions and their timeouts. The internal session\r\nstore is not available right after the application router instance is\r\ncreated, but is available in the callback of `approuter.start` and all\r\nthe time afterwards until the application router is stopped.\r\n\r\nIn case an external session storage is used, the application router extension\r\nshould perform the following actions to synchronize the internal session\r\nstore with the external one:\r\n\r\n- Load existing sessions from external storage \r\n- Start the application router\r\n- Populate the application router's internal session store\r\n\r\n### Read\r\n\r\nA session identifier may be obtained from the request object `req.sessionID`.\r\n\r\nOn each request, the application router executes registered middlewares\r\nin a certain order and the session is not available to all of them.\r\n\r\n- First it passes the request to `approuter.first` middleware. \r\n  At this point, there is no session associated with\r\n  the incoming request. \r\n- Afterwards, the application router checks if the user is authenticated, reads\r\n  the relevant session from the internal session store and puts it into the request \r\n  context.\r\n- Next, the application router passes a request to \r\n  `approuter.broforeRequestHandler`. At this point, the session object is\r\n  available and associated with the incoming request.\r\n- `approuter.beforeErrorHandler` also has access to session.  \r\n\r\n### Login\r\n\r\nWhen a user agent requests a resource, served via a route that requires\r\nauthentication, the application router will request the user agent to\r\npass authentication first (usually via redirect to XSUAA). At this point,\r\nthe application router does not create any session. Only after\r\nthe authentication process is finished, the application router creates a session,\r\nstores it in the internal session storage and emits a `login` event.\r\n\r\n### Update Session\r\n\r\nAny changes made to the session are not stored in the internal session store \r\nimmediately, but are accumulated to make a bulk update after the end of the response.\r\nWhile the request is passed through the chain of middlewares, the session object\r\nmay be modified. Also, when the backend access token is close to expire,\r\nthe application router may trigger the refresh backend token flow. In both cases,\r\nthe actual update of the internal session store is done later on, outside of\r\nthe request context.\r\n\r\n### Timeout\r\n\r\nThere is a time-based job in the application router that basis outside \r\nthe request context and destroys sessions with an elapsed timeout.\r\n\r\nEach time the application router reads a session from the session store,\r\nthe timeout of this session is reset to the initial value that may be retrieved\r\nusing the [`getDefaultSessionTimeout()`](#sessionstoregetdefaultsessiontimeout)\r\nAPI.\r\n\r\n### Logout\r\n\r\nWhen a user agent requests a URL defined as the `logoutEndpoint` in the \r\n`xs-app.json` file, a central logout process takes place. As part of this\r\nprocess, the application router emits a `logout` event. More detailed\r\ninformation about the central logout may be found in \r\n[README.md](../README.md) \r\n\r\n## Security\r\n\r\nThe application router uses session secret to sign session cookies and\r\nprevent tampering. The session secret, by default, is generated using\r\na random sequence of bytes at the startup of the application router. It is\r\ndifferent for each instance and changed on each restart of the same\r\ninstance.\r\n\r\nUsing the default session secret generation mechanism for highly available\r\napplication routers may cause issues in the following scenarios:\r\n\r\n- The user agent is authenticated and the session is stored in a session store.\r\n  The application router is restarted (due to internal error or triggered\r\n  by platform) and a new session secret is generated. The authenticated user\r\n  agent makes a request, which contains the session cookies. However, the cookies are \r\n  signed using another secret and the application router ignores them.\r\n- The user agent is authenticated and the session is stored in the session store.\r\n  The application router instance is unavailable. The authenticated user agent \r\n  makes a request to the application router and the request contains the session\r\n  cookies. The load balancer forwards the request to another instance of \r\n  the application router. However, cookies are signed using another secret and\r\n  the application router ignores them.\r\n\r\nIn both scenarios, the session in the store is no longer accessible, the cookies\r\nsent by the user agent are redundant, and the user agent will be requested to\r\npass authentication once again.\r\n\r\nTo avoid the issues described above, the extension that implements the extended session\r\nmanagement mechanism, should make sure to implement the `getSessionSecret` hook.\r\n\r\n```js\r\nvar ar = AppRouter();\r\n\r\nar.start({\r\n  getSessionSecret: function () {\r\n    return 'CUSTOM_PERSISTED_SESSION_SECRET';\r\n  },\r\n  ...\r\n});\r\n```\r\n\r\nIt is recommended to have at least 128 characters in the string that replaces \r\n`CUSTOM_PERSISTED_SESSION_SECRET`.\r\n\r\n## Data Privacy\r\n\r\nThe user agent session potentially contains personal data. By implementing\r\nthe custom session management behaviour, you take the responsibility to be\r\ncompliant with all personal data protection laws and regulations\r\n(e.g. [GDPR](https://en.wikipedia.org/wiki/General_Data_Protection_Regulation))\r\nthat may be applied in the regions, where the application will be used.\r\n\r\n## API Reference\r\n\r\n### Methods\r\n\r\n#### approuter.start(options)\r\n\r\n* `options`\r\n  * `getSessionSecret` - returns the session secret to be used\r\n    by the application router for the signing of the session cookies. \r\n\r\n#### approuter.getSessionStore()\r\n\r\nreturns `SessionStore` instance.\r\n\r\n#### sessionStore.getDefaultSessionTimeout()\r\n\r\nreturns the default session timeout in minutes.\r\n\r\n#### sessionStore.getSessionTimeout(sessionId, callback)\r\n\r\n* `sessionId` - an unsigned session identifier\r\n* `callback` - `function(error, session)` a function that is called \r\n   when the session object is retrieved from the internal session \r\n   storage of the application router.\r\n  * `error` - an error object in case of an error, otherwise `null`\r\n  * `timeout` - time, in minutes, until the session times out\r\n\r\n#### sessionStore.get(sessionId, callback)\r\n\r\n* `sessionId` - an unsigned session identifier\r\n* `callback` - `function(error, session)` a function that is called \r\n   when the session object is retrieved from the internal session \r\n   storage of the application router.\r\n  * `error` - an error object in case of an error, otherwise `null`\r\n  * `session` - the session object\r\n    * `id` - session identifier, immutable\r\n\r\n#### sessionStore.set(sessionId, sessionString, timeout, callback)\r\n\r\n* `sessionId` - an unsigned session identifier\r\n* `sessionString` - a session object serialized to string\r\n* `timeout` - a timestamp in milliseconds, after which the session should be \r\n   automatically invalidated\r\n* `callback` - a function that is called after the session is saved in the\r\n   internal session storage of the application router \r\n\r\n#### sessionStore.update(sessionId, callback, resetTimeout)\r\n\r\n* `sessionId` - an unsigned session identifier\r\n* `callback` - `function(currentSession)` function, which returns \r\n  session object. Callback function may modify and return current \r\n  session object or create and return brand new session object\r\n  * `currentSession` - current session object\r\n* `resetTimeout` - a boolean that indicates whether to reset the session timeout\r\n\r\n\r\n#### sessionStore.destroy(sessionId, callback)\r\n\r\n* `sessionId` - an unsigned session identifier\r\n* `callback` - a function that is called after the session is destroyed in\r\n  the internal session storage of the application router \r\n\r\n### Events\r\n\r\nExtension may subscribe to application router events using the standard\r\n[`EventEmitter`](https://nodejs.org/api/events.html) API.\r\n\r\n```js\r\nvar ar = AppRouter();\r\n\r\nar.on('someEvent', function handler() {\r\n  // Handle event\r\n});\r\n```\r\n\r\n#### `login`\r\n\r\nEmitted when user agent is authenticated.\r\n\r\nParameters:\r\n* `session` - session object\r\n  * `id` - session identifier, immutable\r\n\r\n#### `logout`\r\n\r\nEmitted when a user agent session is going to be terminated in\r\nthe internal session store of the application router. Emitted either when\r\nthe user agent session is timed-out or when `logoutEndpoint` was requested. \r\n\r\n*__Note:__ Central logout is an asynchronous process. The order in which\r\nthe backend and the application router sessions are invalidated, is not\r\nguaranteed.*\r\n\r\nParameters:\r\n* `session` - session object\r\n  * `id` - session identifier, immutable\r\n\r\n## Example                \r\nThere may be many various options, how the application router extension\r\ndecides to store sessions exposed via the session management API. The example\r\nbelow assumes a `SessionDataAccessObject` to be implemented by the extension\r\ndeveloper and to have the following API:\r\n\r\n### Methods:\r\n\r\n* `sessionDataAccessObject.create` - `function(session, timeout)`\r\n* `sessionDataAccessObject.update` - `function(sessionId, timeout)`\r\n* `sessionDataAccessObject.delete` - `function(sessionId)`\r\n* `sessionDataAccessObject.load` - `function()`\r\n\r\n### Events:\r\n\r\n#### `create`\r\n\r\nParameters: \r\n\r\n  * `sessionId` - session identifier\r\n  * `session` - session object serialized to string\r\n  * `timeout` - timestamp, when session should expire\r\n  * `callback` - function to be called after session is stored in\r\n  internal session storage\r\n\r\n#### `update`\r\n\r\nParameters:\r\n\r\n  * `sessionId` - session identifier\r\n  * `session` - session object serialized to string\r\n  * `timeout` - timestamp, when session should be expired\r\n  * `callback` - function to be called after session is stored in\r\n  internal session storage\r\n\r\n#### `delete`\r\n\r\nParameters:\r\n\r\n  * `sessionId` - session identifier\r\n\r\n#### `load`\r\n\r\nParameters:\r\n\r\n  * `sessions[]` - array of objects\r\n    * `id` - session identifier\r\n    * `session` - session object serialized to string\r\n    * `timeout` - timestamp, when session should expire\r\n\r\n```js\r\nvar ar = new require('@sap/approuter')();\r\nvar dao = new SessionDataAccessObject();\r\n\r\ndao.on('load', function (data) {\r\n\r\n    ar.start({\r\n        getSessionSecret: function getSessionSecret() {\r\n            return process.env.SESSION_SECRET;\r\n        }\r\n    }, function() {\r\n        var store = ar.getSessionStore();\r\n        var defaultTimeout = store.getDefaultSessionTimeout();\r\n\r\n        // AppRouter -> Persistence\r\n        ar.on('login', function(session) {\r\n            dao.create(session, defaultTimeout);\r\n        });\r\n        ar.on('update', function(sessionId, timeout) {\r\n            dao.update(sessionId, timeout);\r\n        });\r\n        ar.on('logout', function(sessionId) {\r\n            dao.delete(sessionId);\r\n        });\r\n\r\n        // Load Initial Data\r\n        data.forEach(function(item) {\r\n            store.set(item.id, item.session, item.timeout);\r\n        });\r\n\r\n        // Persistence -> AppRouter\r\n        dao.on('create', store.set);\r\n        dao.on('update', store.set);\r\n        dao.on('delete', store.destroy);\r\n    });\r\n\r\n});\r\n\r\ndao.load();\r\n```\r\n\r\n## Performance\r\n\r\n*__Note:__ The `update` event of the application router may be potentially\r\ntriggered thousands of times a second. It is recommended to throttle or\r\ndebounce calls to the external storage to reduce network and CPU\r\nconsumption.*\r\n\r\nHere is an example of a throttled `dao.update()`, where the latest change\r\nwill be persisted in the external storage no more than once in `500ms` for\r\nthe same session.\r\n\r\n```js\r\n// Throttled update\r\nupdate(sessionId, timeout) {\r\n    var dao = this;\r\n    var sessionStore = this._sessionStore;\r\n    if(typeof timeout === 'undefined') {\r\n        if (!this.updateTimers[sessionId]) {\r\n            this.updateTimers[sessionId] = setTimeout(function() {\r\n                dao.updateTimers[sessionId] = null;\r\n            }, 500);\r\n            sessionStore.get(sessionId, function(err, session) {\r\n                dao._saveSession(sessionId, session)\r\n            });\r\n        }\r\n    } else {\r\n        if (!this.timeoutTimers[sessionId]) {\r\n            this.timeoutTimers[sessionId] = setTimeout(function() {\r\n                dao.timeoutTimers[sessionId] = null;\r\n            }, 500);\r\n            sessionStore.getSessionTimeout(sessionId, function(err, timeout) {\r\n                dao._saveTimeout(sessionId, timeout)\r\n            });\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nAnd here is an example of a debounced `dao.update()`, where the latest \r\nchange will be persisted in the external storage only if there were no other\r\nchanges during the last `500ms` for the same session.\r\n\r\n```js\r\n// Debounced update\r\nupdate(sessionId, timeout) {\r\n    var dao = this;\r\n    var sessionStore = this._sessionStore;\r\n    if(typeof timeout === 'undefined') {\r\n        if (this.updateTimers[sessionId]) {\r\n            clearTimeout(this.updateTimers[sessionId]);\r\n        }\r\n        this.updateTimers[sessionId] = setTimeout(function() {\r\n            sessionStore.get(sessionId, function(err, session) {\r\n                dao._saveSession(sessionId, session)\r\n            });\r\n        }, 500);\r\n    } else {\r\n        if (this.timeoutTimers[sessionId]) {\r\n            clearTimeout(this.timeoutTimers[sessionId]);\r\n        }\r\n        this.timeoutTimers[sessionId] = setTimeout(function() {\r\n            sessionStore.getSessionTimeout(sessionId, function(err, timeout) {\r\n                dao._saveTimeout(sessionId, timeout)\r\n            });\r\n        }, 500);\r\n    }\r\n}\r\n```\r\n\r\nTo understand the difference between throttling and debouncing, let's\r\nconsider an example, where requests for the same session come every \r\n`100ms` for `1sec`. In case of `500ms` debouncing, changes will be \r\npersisted one time. In case of `500ms` throttling, changes will be\r\npersisted two times. Without any optimisation, changes will be\r\npersisted ten times.\r\n\r\n## Custom Storage Driver\r\n\r\nIt is possible to use your own driver. In order to do that, user shall inject its own implementation of a store. \r\n\r\nThe class shall implement the following interface:\r\n```typescript\r\n\r\ninterface UserCustomStore {\r\n\r\n  // delete all sessions\r\n  clear(): Promise<void>;\r\n\r\n  // remove <sessionId> session\r\n  destroy(sessionId : string): Promise<void>; \r\n\r\n  // retrieve <sessionId> session\r\n  get(sessionId : string): Promise<object | null>;\r\n\r\n  // number of sessions\r\n  length(): Promise<number>;\r\n\r\n  // get <sessionId> expiration\r\n  ttl(sessionId : string): Promise<number>;\r\n\r\n  // set <sessionId> data to <session> with <timeout> expiration\r\n  set(sessionId: string, session: object, timeout: number): Promise<void>;\r\n\r\n  // check if session <sessionId> exists\r\n  exists(sessionId: string): boolean; \r\n\r\n  // update existing session <sessionId> expiration to <timeout>\r\n  resetTimer(sessionId: string, timeout: number); \r\n}  \r\n```\r\n\r\nIn addition, the file should include a method to get an instance of the store, for example:\r\n```typescript\r\nlet store;\r\nmodule.exports.getStore = () => {\r\n  if (!store) {\r\n    store = new UserCustomStore();\r\n  }\r\n  return store;\r\n};\r\n```\r\n\r\nsee [Redis store](../lib/utils/redis-store.js) for example\r\n\r\nIn order for app router to use it, user shall set ```externalStoreFilePath``` property in the ```EXT_SESSION_MGT``` env variable with the path to the storage.  \r\nThe application router will use this path to require your storage.\r\n\r\nThe application router uses the defaultRetryTimeout and the backOffMultiplier properties in the EXT_SESSION_MGT environment variable to determine the Redis pattern for automatic retries of failed operations.\r\n\r\nFor example: \r\n```json\r\n{\r\n    \"instanceName\": \"approuter-redis\",\r\n    \"storageType\": \"redis\",\r\n    \"sessionSecret\": \"someuniquesessionsecret\",\r\n    \"externalStoreFilePath\": \"./src/storage/my-special-storage\",\r\n    \"defaultRetryTimeout\": 10000,\r\n    \"backOffMultiplier\":  10\r\n}\r\n``` \r\n\r\n## Credentials Structure when using Redis\r\n\r\nRedis store can be used on both CF and Kyma, however the external session managment expects to receive the credentials in a certain structure,\r\nsimilar to the structure of the CF redis service instance.\r\nIf you're using Kyma, create a [K8s secret](https://kubernetes.io/docs/tasks/configmap-secret/managing-secret-using-config-file/#create-the-config-file) that includes the credentials in the following structure:\r\n```json\r\n{\r\n    \"cluster_mode\": \"(Mandatory) boolean\",\r\n    \"tls\": \"(Mandatory) boolean\",\r\n    \"ca_base64\": \"(Optional) string\",\r\n    \"sentinel_nodes\": \"(Optional) Array of objects of hostname and port, e.g '[{hostname: 127.0.0.1, port: 26543}]'\",\r\n    \"uri\": \"(Mandatory if using sentinel_nodes) string\",\r\n    \"password\": \"(Mandatory) string\",\r\n    \"hostname\": \"(Mandatory) string\",\r\n    \"port\": \"string\"\r\n}\r\n```\r\n"},{"name":"sizingGuide.md","content":"Sizing Guide for Application Router\r\n===================================\r\n\r\n<!-- toc -->\r\n\r\n- [Idle](#idle)\r\n- [Test Setup](#test-setup)\r\n- [HTTP Traffic](#http-traffic)\r\n- [Web Socket Traffic](#web-socket-traffic)\r\n- [Memory Configuration](#memory-configuration)\r\n\r\n<!-- tocstop -->\r\n\r\nIn this guide we provide measurements done in different application router scenarios. You can use them to approximately calculate the amount of memory that would be required by the application router. The tables contain the exact results from the measurements with Node.js v6.9.1. It is a good idea to provide higher numbers for productive usage.\r\n\r\nAll measurements are with authentication. If you have additional session content and want to count the session memory consumption please take a look at what is stored in the session - described in README's [Session Contents](../README.md#session-contents) section. You will need to add the calculated session size taking into account the number of different users and the session timeout. In our tests only the JWT token took ~4KB.\r\n\r\n## Idle\r\nThe memory consumption for an idle application router is around 50 MB.\r\n\r\n## Test Setup\r\n\r\nThe application router runs in a container with limited amount of memory. Swap is turned off.\r\nThe test client creates new sessions on the server with a step of 100.\r\nNo more than 100 users request the application router at a given time\r\n(e.g. 100 sessions are initialized and become idle, then 100 more session are created and become idle ...).\r\nThe test ends when an *Out of Memory* event occurs, causing the container to be stopped.\r\nThe number of created sessions before the process ends is taken.\r\n\r\n## HTTP Traffic\r\n\r\nThere are 2 separate test scenarios depending on what is done after a session is created:\r\n- Scenario (1)\r\n  - A 'Hello World' static resource is being served.\r\n- Scenario (2)\r\n  - A 'Hello World' static resource is being served.\r\n  - A static resource of 84.78kb (compressed by application router to 28.36kb) is being served.\r\n  - A backend which returns a payload of 80kb (compressed by application router to 58kb) is being called.\r\n  - Another backend which returns a payload of 160kb (compressed by application router to 116kb) is being called.\r\n\r\nMemory Limit | Max Sessions - Scenario (1) | Max Sessions - Scenario (2)\r\n------------ | --------------------------- | ---------------------------\r\n256MB        | 5 300                       | 800\r\n512MB        | 13 300                      | 2 300\r\n1GB          | 30 100                      | 8 400\r\n2GB          | 65 500                      | 19 500\r\n4GB          | 134 900                     | 46 400\r\n8GB          | 275 500                     | 102 300\r\n\r\n## Web Socket Traffic\r\n\r\nThere are 2 separate test scenarios depending on what is done after a session is created:\r\n- Scenario (1)\r\n  - A 'Hello World' static resource is being served.\r\n  - A single 'Hello' message is sent and then received through a web socket connection.\r\n- Scenario (2)\r\n  - A 'Hello World' static resource is being served.\r\n  - A backend which returns a payload of 80kb over a web socket is being called.\r\n  - Another backend which returns a payload of 160kb over a web socket is being called.\r\n\r\n**Note**: Web sockets require a certain amount of file handles to be available to the process - it is approximately two times the number of the sessions.\r\nIn Cloud Foundry the default value is 16384.\r\n\r\nMemory Limit | Max Sessions - Scenario (1) | Max Sessions - Scenario (2)\r\n------------ | --------------------------- | ---------------------------\r\n256MB        | 600                         | 300\r\n512MB        | 1 100                       | 500\r\n1GB          | 3 100                       | 800\r\n2GB          | 6 500                       | 1 400\r\n4GB          | 13 300                      | 2 900\r\n8GB          | 20 700                      | 6 100\r\n\r\n**Note**: `--max-old-space-size` restricts the amount of memory used in the JavaScript heap.\r\nIts default value is below 2GB. So in order to use the full resources that has been provided to the application,\r\nthe value of this restriction should be set to a number equal to the memory limit of the whole application.\r\n\r\nFor example, if the application memory is limited to 2GB, set the V8 heap limit like this in the `package.json`:\r\n```\r\n    \"scripts\": {\r\n        \"start\": \"node --max-old-space-size=2048 node_modules/@sap/approuter/approuter.js\"\r\n    }\r\n```\r\n\r\n## Memory Configuration\r\n\r\nApplication router process should run with at least 256MB memory. It may require more memory depending on the application.\r\nThese aspects influence memory usage:\r\n- concurrent connections\r\n- active sessions\r\n- JWT token size\r\n- backend session cookies\r\n"}]},{"name":"extending.md","content":"Extending Application Router\r\n============================\r\n\r\n<!-- toc -->\r\n\r\n- [Basics](#basics)\r\n- [Inject Custom Middleware](#inject-custom-middleware)\r\n- [Application Router Extensions](#application-router-extensions)\r\n- [Customize Command Line](#customize-command-line)\r\n- [Dynamic Routing](#dynamic-routing)\r\n- [State synchronization](#state-synchronization)\r\n- [API Reference](#api-reference)\r\n  * [approuter](#approuter)\r\n    + [`approuter()`](#approuter)\r\n    + [Event: 'login'](#event-login)\r\n    + [Event: 'logout'](#event-logout)\r\n    + [`first`](#first)\r\n    + [`beforeRequestHandler`](#beforerequesthandler)\r\n    + [`afterRequestHandler`](#afterrequesthandler)\r\n      [`backendTimeout`](#backendtimeout)\r\n    + [`beforeErrorHandler`](#beforeerrorhandler)\r\n    + [`start(options, callback)`](#startoptions-callback)\r\n    + [`close(callback)`](#closecallback)\r\n    + [`createRouterConfig(options, callback)`](#createrouterconfigoptions-callback)\r\n    + [`resolveUaaConfig(request, uaaOptions, callback)`](#resolveuaaconfigrequest-uaaoptions-callback)\r\n  * [Middleware Slot](#middleware-slot)\r\n    + [`use(path, handler)`](#usepath-handler)\r\n\r\n<!-- tocstop -->\r\n\r\n## Basics\r\nInsead of starting the application router directly, your application can have its own start script.\r\nYou can use the application router as a regular Node.js package.\r\n```js\r\nvar approuter = require('@sap/approuter');\r\n\r\nvar ar = approuter();\r\nar.start();\r\n```\r\n\r\n## Inject Custom Middleware\r\n\r\nThe application router uses the [connect](https://github.com/senchalabs/connect)\r\nframework.\r\nYou can reuse all _connect_ middlewares within the application router directly.\r\nYou can do this directly in your start script:\r\n```js\r\nvar approuter = require('@sap/approuter');\r\n\r\nvar ar = approuter();\r\n\r\nar.beforeRequestHandler.use('/my-ext', function myMiddleware(req, res, next) {\r\n  res.end('Request handled by my extension!');\r\n});\r\nar.start();\r\n```\r\n__Tip:__ Name your middleware to improve troubleshooting.\r\n\r\nThe path argument is optional. You can also chain `use` calls.\r\n```js\r\nvar approuter = require('@sap/approuter');\r\nvar morgan = require('morgan');\r\n\r\nvar ar = approuter();\r\n\r\nar.beforeRequestHandler\r\n  .use(morgan('combined'))\r\n  .use('/my-ext', function myMiddleware(req, res, next) {\r\n    res.end('Request handled by my extension!');\r\n  });\r\nar.start();\r\n```\r\n\r\nThe application router defines the following slots where you can insert custom middleware:\r\n* `first` - right after the _connect_ application is created, and before any\r\napplication router middleware.\r\nAt this point security checks are not performed yet.\r\n__Tip:__ This is a good place for infrastructure logic like logging and monitoring.\r\n* `beforeRequestHandler` - before standard application router request handling,\r\nthat is static resource serving or forwarding to destinations.\r\n__Tip:__ This is a good place for custom REST API handling.\r\n* `beforeErrorHandler` - before standard application router error handling.\r\n__Tip:__ This is a good place to capture or customize error handling.\r\n\r\nIf your middleware does not complete the request processing, call `next`\r\nto return control to the application router middleware:\r\n```js\r\nar.beforeRequestHandler.use('/my-ext', function myMiddleware(req, res, next) {\r\n  res.setHeader('x-my-ext', 'passed');\r\n  next();\r\n});\r\n```\r\n\r\n## Application Router Extensions\r\n\r\nYou can use application router extensions.\r\n\r\nAn extension is defined by an object with the following properties:\r\n* `insertMiddleware` - describes the middleware provided by this extension\r\n  * `first`, `beforeRequestHandler`, `beforeErrorHandler` - an array of middleware, where each one is either\r\n    * a middleware function (invoked on all requests), or\r\n    * an object with properties:\r\n      * `path` - handle requests only for this path\r\n      * `handler` - middleware function to invoke\r\n\r\nHere is an example (my-ext.js):\r\n```js\r\nmodule.exports = {\r\n  insertMiddleware: {\r\n    first: [\r\n      function logRequest(req, res, next) {\r\n        console.log('Got request %s %s', req.method, req.url);\r\n      }\r\n    ],\r\n    beforeRequestHandler: [\r\n      {\r\n        path: '/my-ext',\r\n        handler: function myMiddleware(req, res, next) {\r\n          res.end('Request handled by my extension!');\r\n        }\r\n      }\r\n    ]\r\n  }\r\n};\r\n```\r\nYou can use it in your start script like this:\r\n```js\r\nvar approuter = require('@sap/approuter');\r\n\r\nvar ar = approuter();\r\nar.start({\r\n  extensions: [\r\n    require('./my-ext.js')\r\n  ]\r\n});\r\n```\r\n\r\n## Customize Command Line\r\n\r\nBy default the application router handles its command line parameters, but you can\r\ncustomize that too.\r\n\r\nAn _approuter_ instance provides the property `cmdParser` that is a\r\n[commander](https://github.com/tj/commander.js/) instance.\r\nIt is configured with the standard application router command line options.\r\nThere you can add custom options like this:\r\n```js\r\nvar approuter = require('@sap/approuter');\r\n\r\nvar ar = approuter();\r\n\r\nvar params = ar.cmdParser\r\n  // add here custom command line options if needed\r\n  .option('-d, --dummy', 'A dummy option')\r\n  .parse(process.argv);\r\n\r\nconsole.log('Dummy option:', params.dummy);\r\n```\r\nTo completely disable the command line option handling in the application router,\r\nreset the following property:\r\n```js\r\nar.cmdParser = false;\r\n```\r\n\r\n## Dynamic Routing\r\n\r\nThe application router can use a custom routing configuration for each request.\r\n\r\nHere is an example:\r\n```js\r\nvar approuter = require('@sap/approuter');\r\n\r\nvar ar = approuter();\r\nar.start({\r\n  getRouterConfig: getRouterConfig\r\n});\r\n\r\nvar customRouterConfig;\r\nvar options = {\r\n  xsappConfig: {\r\n    routes: [\r\n      {\r\n        source: '/service',\r\n        destination: 'backend',\r\n        scope: '$XSAPPNAME.viewer',\r\n      }\r\n    ]\r\n  },\r\n  destinations: [\r\n    {\r\n      name: 'backend',\r\n      url: 'https://my.app.com',\r\n      forwardAuthToken: true\r\n    }\r\n  ],\r\n  xsappname: 'MYAPP'\r\n};\r\nar.createRouterConfig(options, function(err, routerConfig) {\r\n  if (err) {\r\n    console.error(err);\r\n  } else {\r\n    customRouterConfig = routerConfig;\r\n  }\r\n});\r\n\r\nfunction getRouterConfig(request, callback) {\r\n  if (/\\?custom-query/.test(request.url)) {\r\n    callback(null, customRouterConfig);\r\n  } else {\r\n    callback(null, null); // use default router config\r\n  }\r\n}\r\n```\r\n\r\n## State synchronization\r\n\r\nThe application router can be scaled to run with multiple instances like any other application on Cloud Foundry.\r\nStill application router instances are not aware of each other and there is no communication among them.\r\nSo if extensions introduce some state, they should take care to synchronize it across application router instances.\r\n\r\n## API Reference\r\n\r\n### approuter\r\n\r\n#### `approuter()`\r\n\r\nCreates a new instance of the application router.\r\n\r\n#### Event: 'login'\r\nParameters:\r\n* `session`\r\n  * `id` - session id as a string\r\n\r\nEmitted when a new user session is created.\r\n\r\n#### Event: 'logout'\r\nParameters:\r\n* `session`\r\n  * `id` - session id as a string\r\n\r\nEmitted when a user session has expired or a user has requested to log out.\r\n\r\n#### `first`\r\nA [Middleware Slot](#middleware-slot) before the first application router middleware\r\n\r\n#### `beforeRequestHandler`\r\nA [Middleware Slot](#middleware-slot) before the standard application router request handling\r\n\r\n#### `afterRequestHandler`\r\nA function that can be added to the request object - for example in a \"first\" or \"beforeRequestHandler\" extension.\r\nIf exists, this function will be called by the standard application router after the standard backend response handling is completed.\r\nInput: \r\n* `ctx` context object containing the following properties\r\n  * `incomingRequest` the request sent from client to application router\r\n  * `incomingResponse` the response that will be sent from application router to client\r\n  * `outgoingRequest` the request sent from application router to backend application\r\n  * `outgoingResponse` the response that was received in application router from backend application\r\n* `done` a callback function that receives (optionally) and error and the modified incomingResponse\r\n    \r\nNote that this function is called after standard application router headers processing. Data piping is not modified. \r\nIf an error is passed to done callback it will be just logged, piping process will not be stopped. Note that also in case of error the incomingResponse object should be returned.\r\n\r\nExample:\r\n```js\r\nvar approuter = require('@sap/approuter');\r\nvar ar = approuter();\r\nar.first.use('/backend', function (req, res, next) {\r\n    req.afterRequestHandler = function(ctx, done){\r\n        if (ctx.outgoingResponse.statusCode === 200) {\r\n          let incomingResponse = ctx.incomingResponse;\r\n          incomingResponse.setHeader('header1', 'abc');\r\n          done(null, incomingResponse);\r\n        } else {\r\n          done('An error occurred in backend, returned status ' + ctx.outgoingResponse.statusCode, ctx.incomingResponse);\r\n        }\r\n    };\r\n    next();\r\n});\r\nar.start();\r\n```\r\n#### `backendTimeout`\r\nA function that can be added to the request object - for example in a \"first\" or \"beforeRequestHandler\" extension.\r\nIf exists, this function will be called by the standard application router when a backend connection timeout occurs.\r\nInput:\r\n* `req` the request object\r\n* `done` a callback function that doesn't return any parameter\r\n\r\n#### `beforeErrorHandler`\r\nA [Middleware Slot](#middleware-slot) before the standard application router error handling\r\n\r\n#### `start(options, callback)`\r\n\r\nStarts the application router with the given options.\r\n\r\n* `options` this argument is optional. If provided, it should be an object which can have any of the following properties:\r\n  * `port` - a TCP port the application router will listen to (string, optional)\r\n  * `workingDir` - the working directory for the application router,\r\n  should contain the _xs-app.json_ file (string, optional)\r\n  * `extensions` - an array of extensions, each one is an object as defined in\r\n  [Application Router Extensions](#application-router-extensions) (optional)\r\n  * `xsappConfig` - An object representing the content which is usually put in xs-app.json file.\r\n  If this property is present it will take precedence over the content of xs-app.json. (optional)\r\n  * `httpsOptions` - Options similar to [`https.createServer`](https://nodejs.org/api/https.html#https_https_createserver_options_requestlistener).\r\n  If this property is present, application router will be started as an https server. (optional)\r\n  * `getToken` - `function(request, callback)` Provide custom access token (optional)\r\n    * `request` - Node request object\r\n    * `callback` - `function(error, token)`\r\n      * `error` - Error object in case of error\r\n      * `token` - Access token to use in request to backend\r\n  * `getRouterConfig` - `function(request, callback)` Provide custom routing configuration (optional)\r\n    * `request` - Node request object\r\n    * `callback` - `function(error, routerConfig)`\r\n      * `error` - Error object in case of error\r\n      * `routerConfig` - Custom routing configuration to use for given request.\r\n      This object should be created via `createRouterConfig`.\r\n      If `null` or `undefined`, default configuration will be used.\r\n      \r\n    **Note:** When approuter is bound to html5 repository, you cannot provide getRouterConfig function.\r\n    \r\n* `callback` - optional function with signature `callback(err)`.\r\nIt is invoked when the application router has started or an error has occurred.\r\nIf not provided and an error occurs (e.g. the port is busy), the application will abort.\r\n\r\n#### `close(callback)`\r\nStops the application router.\r\n\r\n* `callback` - optional function with signature `callback(err)`.\r\nIt is invoked when the application router has stopped or an error has occurred.\r\n\r\n#### `createRouterConfig(options, callback)`\r\nPrepares the routing configuration to be used by the application router.\r\nAs part of this, the application router validates the given options.\r\nThis function can be used at any point in runtime to create additional routing configurations.\r\n\r\n**Note:** This function can be called only after `start` function.\r\n\r\n* `options`\r\n  * `xsappname` - Value to replace $XSAPPNAME placeholder in scope names.\r\n  If not provided, it will be taken from UAA service binding. (optional)\r\n  * `xsappConfig` - An object representing the content which is usually put in xs-app.json file.\r\n**Note:** Only the following configurations are taken into account from this property (the rest are taken from the xs-app.json file):\r\n`welcomeFile`, `logout.logoutEndpoint`, `logout.logoutPage`, `routes`, `websockets`, `errorPage`.\r\n  * `destinations` - An array containing the configuration of the backend destinations.\r\n  If not provided, it will be taken from `destinations` environment variable. (optional)\r\n* `callback` - `function(error, routerConfig)`\r\n  * `error` - Error object in case of error\r\n  * `routerConfig` - Routing configuration to be passed to the callback of `getRouterConfig`.\r\n  Approuter extensions should not access the content of this object.\r\n\r\n#### `resolveUaaConfig(request, uaaOptions, callback)`\r\n\r\nCalculates tenant-specific UAA configuration.\r\n\r\n* `request` - node request object used to identify the tenant\r\n* `uaaOptions` - UAA options as provided in service binding\r\n* `callback` - `function(error, tenantUaaOptions)`\r\n  * `error` - Error object in case of error\r\n  * `tenantUaaOptions` - new UAA configuration with tenant-specific properties\r\n\r\n### Middleware Slot\r\n\r\n#### `use(path, handler)`\r\nInserts a request handling middleware in the current slot.\r\n\r\n* `path` - handle only requests starting with this path (string, optional)\r\n* `handler` - a middleware function to invoke (function, mandatory)\r\n\r\nReturns `this` for chaining.\r\n"},{"name":"sessionManagement.md","content":"Extended Session Management\r\n===========================\r\n\r\n<!-- toc -->\r\n\r\n- [Abstract](#abstract)\r\n- [Session Lifecycle](#session-lifecycle)\r\n- [Security](#security)\r\n- [Data Privacy](#data-privacy)\r\n- [API Reference](#api-reference)\r\n- [Example](#example)\r\n- [Performance](#performance)\r\n- [Custom Storage Driver](#custom-storage-driver)\r\n- [Credentials Structure](#credentials-structure)\r\n\r\n<!-- tocstop -->\r\n\r\n## Abstract\r\n\r\nThe application router uses a memory store as a session repository to provide\r\nthe best runtime performance. However, it is not persisted and it is not shared\r\nacross multiple instances of the application router. \r\n\r\n*__Note:__ The Limitations above do not prevent the application router from\r\nbeing scaled out, since session stickiness is in place by default.* \r\n\r\nWhile it is good enough for most of the cases, it may be required to\r\nprovide a highly-available solution, which may be achieved by storing\r\nthe state (session) of the application router outside - in durable shared\r\nstorage.\r\nTo allow implementing these qualities, the application router exposes the\r\n*extended session management* API described below.\r\n\r\n## Session Lifecycle\r\n\r\nThe application router stores user agent sessions as JavaScript objects \r\nserialized to strings. It also stores the session timeout associated with\r\neach session, which indicates the amount of time left until session\r\ninvalidation. \r\n\r\n### Initial Data\r\n\r\nDuring the start of the application router, the internal session store is initiated.\r\nIt contains an empty list of sessions and their timeouts. The internal session\r\nstore is not available right after the application router instance is\r\ncreated, but is available in the callback of `approuter.start` and all\r\nthe time afterwards until the application router is stopped.\r\n\r\nIn case an external session storage is used, the application router extension\r\nshould perform the following actions to synchronize the internal session\r\nstore with the external one:\r\n\r\n- Load existing sessions from external storage \r\n- Start the application router\r\n- Populate the application router's internal session store\r\n\r\n### Read\r\n\r\nA session identifier may be obtained from the request object `req.sessionID`.\r\n\r\nOn each request, the application router executes registered middlewares\r\nin a certain order and the session is not available to all of them.\r\n\r\n- First it passes the request to `approuter.first` middleware. \r\n  At this point, there is no session associated with\r\n  the incoming request. \r\n- Afterwards, the application router checks if the user is authenticated, reads\r\n  the relevant session from the internal session store and puts it into the request \r\n  context.\r\n- Next, the application router passes a request to \r\n  `approuter.broforeRequestHandler`. At this point, the session object is\r\n  available and associated with the incoming request.\r\n- `approuter.beforeErrorHandler` also has access to session.  \r\n\r\n### Login\r\n\r\nWhen a user agent requests a resource, served via a route that requires\r\nauthentication, the application router will request the user agent to\r\npass authentication first (usually via redirect to XSUAA). At this point,\r\nthe application router does not create any session. Only after\r\nthe authentication process is finished, the application router creates a session,\r\nstores it in the internal session storage and emits a `login` event.\r\n\r\n### Update Session\r\n\r\nAny changes made to the session are not stored in the internal session store \r\nimmediately, but are accumulated to make a bulk update after the end of the response.\r\nWhile the request is passed through the chain of middlewares, the session object\r\nmay be modified. Also, when the backend access token is close to expire,\r\nthe application router may trigger the refresh backend token flow. In both cases,\r\nthe actual update of the internal session store is done later on, outside of\r\nthe request context.\r\n\r\n### Timeout\r\n\r\nThere is a time-based job in the application router that basis outside \r\nthe request context and destroys sessions with an elapsed timeout.\r\n\r\nEach time the application router reads a session from the session store,\r\nthe timeout of this session is reset to the initial value that may be retrieved\r\nusing the [`getDefaultSessionTimeout()`](#sessionstoregetdefaultsessiontimeout)\r\nAPI.\r\n\r\n### Logout\r\n\r\nWhen a user agent requests a URL defined as the `logoutEndpoint` in the \r\n`xs-app.json` file, a central logout process takes place. As part of this\r\nprocess, the application router emits a `logout` event. More detailed\r\ninformation about the central logout may be found in \r\n[README.md](../README.md) \r\n\r\n## Security\r\n\r\nThe application router uses session secret to sign session cookies and\r\nprevent tampering. The session secret, by default, is generated using\r\na random sequence of bytes at the startup of the application router. It is\r\ndifferent for each instance and changed on each restart of the same\r\ninstance.\r\n\r\nUsing the default session secret generation mechanism for highly available\r\napplication routers may cause issues in the following scenarios:\r\n\r\n- The user agent is authenticated and the session is stored in a session store.\r\n  The application router is restarted (due to internal error or triggered\r\n  by platform) and a new session secret is generated. The authenticated user\r\n  agent makes a request, which contains the session cookies. However, the cookies are \r\n  signed using another secret and the application router ignores them.\r\n- The user agent is authenticated and the session is stored in the session store.\r\n  The application router instance is unavailable. The authenticated user agent \r\n  makes a request to the application router and the request contains the session\r\n  cookies. The load balancer forwards the request to another instance of \r\n  the application router. However, cookies are signed using another secret and\r\n  the application router ignores them.\r\n\r\nIn both scenarios, the session in the store is no longer accessible, the cookies\r\nsent by the user agent are redundant, and the user agent will be requested to\r\npass authentication once again.\r\n\r\nTo avoid the issues described above, the extension that implements the extended session\r\nmanagement mechanism, should make sure to implement the `getSessionSecret` hook.\r\n\r\n```js\r\nvar ar = AppRouter();\r\n\r\nar.start({\r\n  getSessionSecret: function () {\r\n    return 'CUSTOM_PERSISTED_SESSION_SECRET';\r\n  },\r\n  ...\r\n});\r\n```\r\n\r\nIt is recommended to have at least 128 characters in the string that replaces \r\n`CUSTOM_PERSISTED_SESSION_SECRET`.\r\n\r\n## Data Privacy\r\n\r\nThe user agent session potentially contains personal data. By implementing\r\nthe custom session management behaviour, you take the responsibility to be\r\ncompliant with all personal data protection laws and regulations\r\n(e.g. [GDPR](https://en.wikipedia.org/wiki/General_Data_Protection_Regulation))\r\nthat may be applied in the regions, where the application will be used.\r\n\r\n## API Reference\r\n\r\n### Methods\r\n\r\n#### approuter.start(options)\r\n\r\n* `options`\r\n  * `getSessionSecret` - returns the session secret to be used\r\n    by the application router for the signing of the session cookies. \r\n\r\n#### approuter.getSessionStore()\r\n\r\nreturns `SessionStore` instance.\r\n\r\n#### sessionStore.getDefaultSessionTimeout()\r\n\r\nreturns the default session timeout in minutes.\r\n\r\n#### sessionStore.getSessionTimeout(sessionId, callback)\r\n\r\n* `sessionId` - an unsigned session identifier\r\n* `callback` - `function(error, session)` a function that is called \r\n   when the session object is retrieved from the internal session \r\n   storage of the application router.\r\n  * `error` - an error object in case of an error, otherwise `null`\r\n  * `timeout` - time, in minutes, until the session times out\r\n\r\n#### sessionStore.get(sessionId, callback)\r\n\r\n* `sessionId` - an unsigned session identifier\r\n* `callback` - `function(error, session)` a function that is called \r\n   when the session object is retrieved from the internal session \r\n   storage of the application router.\r\n  * `error` - an error object in case of an error, otherwise `null`\r\n  * `session` - the session object\r\n    * `id` - session identifier, immutable\r\n\r\n#### sessionStore.set(sessionId, sessionString, timeout, callback)\r\n\r\n* `sessionId` - an unsigned session identifier\r\n* `sessionString` - a session object serialized to string\r\n* `timeout` - a timestamp in milliseconds, after which the session should be \r\n   automatically invalidated\r\n* `callback` - a function that is called after the session is saved in the\r\n   internal session storage of the application router \r\n\r\n#### sessionStore.update(sessionId, callback, resetTimeout)\r\n\r\n* `sessionId` - an unsigned session identifier\r\n* `callback` - `function(currentSession)` function, which returns \r\n  session object. Callback function may modify and return current \r\n  session object or create and return brand new session object\r\n  * `currentSession` - current session object\r\n* `resetTimeout` - a boolean that indicates whether to reset the session timeout\r\n\r\n\r\n#### sessionStore.destroy(sessionId, callback)\r\n\r\n* `sessionId` - an unsigned session identifier\r\n* `callback` - a function that is called after the session is destroyed in\r\n  the internal session storage of the application router \r\n\r\n### Events\r\n\r\nExtension may subscribe to application router events using the standard\r\n[`EventEmitter`](https://nodejs.org/api/events.html) API.\r\n\r\n```js\r\nvar ar = AppRouter();\r\n\r\nar.on('someEvent', function handler() {\r\n  // Handle event\r\n});\r\n```\r\n\r\n#### `login`\r\n\r\nEmitted when user agent is authenticated.\r\n\r\nParameters:\r\n* `session` - session object\r\n  * `id` - session identifier, immutable\r\n\r\n#### `logout`\r\n\r\nEmitted when a user agent session is going to be terminated in\r\nthe internal session store of the application router. Emitted either when\r\nthe user agent session is timed-out or when `logoutEndpoint` was requested. \r\n\r\n*__Note:__ Central logout is an asynchronous process. The order in which\r\nthe backend and the application router sessions are invalidated, is not\r\nguaranteed.*\r\n\r\nParameters:\r\n* `session` - session object\r\n  * `id` - session identifier, immutable\r\n\r\n## Example                \r\nThere may be many various options, how the application router extension\r\ndecides to store sessions exposed via the session management API. The example\r\nbelow assumes a `SessionDataAccessObject` to be implemented by the extension\r\ndeveloper and to have the following API:\r\n\r\n### Methods:\r\n\r\n* `sessionDataAccessObject.create` - `function(session, timeout)`\r\n* `sessionDataAccessObject.update` - `function(sessionId, timeout)`\r\n* `sessionDataAccessObject.delete` - `function(sessionId)`\r\n* `sessionDataAccessObject.load` - `function()`\r\n\r\n### Events:\r\n\r\n#### `create`\r\n\r\nParameters: \r\n\r\n  * `sessionId` - session identifier\r\n  * `session` - session object serialized to string\r\n  * `timeout` - timestamp, when session should expire\r\n  * `callback` - function to be called after session is stored in\r\n  internal session storage\r\n\r\n#### `update`\r\n\r\nParameters:\r\n\r\n  * `sessionId` - session identifier\r\n  * `session` - session object serialized to string\r\n  * `timeout` - timestamp, when session should be expired\r\n  * `callback` - function to be called after session is stored in\r\n  internal session storage\r\n\r\n#### `delete`\r\n\r\nParameters:\r\n\r\n  * `sessionId` - session identifier\r\n\r\n#### `load`\r\n\r\nParameters:\r\n\r\n  * `sessions[]` - array of objects\r\n    * `id` - session identifier\r\n    * `session` - session object serialized to string\r\n    * `timeout` - timestamp, when session should expire\r\n\r\n```js\r\nvar ar = new require('@sap/approuter')();\r\nvar dao = new SessionDataAccessObject();\r\n\r\ndao.on('load', function (data) {\r\n\r\n    ar.start({\r\n        getSessionSecret: function getSessionSecret() {\r\n            return process.env.SESSION_SECRET;\r\n        }\r\n    }, function() {\r\n        var store = ar.getSessionStore();\r\n        var defaultTimeout = store.getDefaultSessionTimeout();\r\n\r\n        // AppRouter -> Persistence\r\n        ar.on('login', function(session) {\r\n            dao.create(session, defaultTimeout);\r\n        });\r\n        ar.on('update', function(sessionId, timeout) {\r\n            dao.update(sessionId, timeout);\r\n        });\r\n        ar.on('logout', function(sessionId) {\r\n            dao.delete(sessionId);\r\n        });\r\n\r\n        // Load Initial Data\r\n        data.forEach(function(item) {\r\n            store.set(item.id, item.session, item.timeout);\r\n        });\r\n\r\n        // Persistence -> AppRouter\r\n        dao.on('create', store.set);\r\n        dao.on('update', store.set);\r\n        dao.on('delete', store.destroy);\r\n    });\r\n\r\n});\r\n\r\ndao.load();\r\n```\r\n\r\n## Performance\r\n\r\n*__Note:__ The `update` event of the application router may be potentially\r\ntriggered thousands of times a second. It is recommended to throttle or\r\ndebounce calls to the external storage to reduce network and CPU\r\nconsumption.*\r\n\r\nHere is an example of a throttled `dao.update()`, where the latest change\r\nwill be persisted in the external storage no more than once in `500ms` for\r\nthe same session.\r\n\r\n```js\r\n// Throttled update\r\nupdate(sessionId, timeout) {\r\n    var dao = this;\r\n    var sessionStore = this._sessionStore;\r\n    if(typeof timeout === 'undefined') {\r\n        if (!this.updateTimers[sessionId]) {\r\n            this.updateTimers[sessionId] = setTimeout(function() {\r\n                dao.updateTimers[sessionId] = null;\r\n            }, 500);\r\n            sessionStore.get(sessionId, function(err, session) {\r\n                dao._saveSession(sessionId, session)\r\n            });\r\n        }\r\n    } else {\r\n        if (!this.timeoutTimers[sessionId]) {\r\n            this.timeoutTimers[sessionId] = setTimeout(function() {\r\n                dao.timeoutTimers[sessionId] = null;\r\n            }, 500);\r\n            sessionStore.getSessionTimeout(sessionId, function(err, timeout) {\r\n                dao._saveTimeout(sessionId, timeout)\r\n            });\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nAnd here is an example of a debounced `dao.update()`, where the latest \r\nchange will be persisted in the external storage only if there were no other\r\nchanges during the last `500ms` for the same session.\r\n\r\n```js\r\n// Debounced update\r\nupdate(sessionId, timeout) {\r\n    var dao = this;\r\n    var sessionStore = this._sessionStore;\r\n    if(typeof timeout === 'undefined') {\r\n        if (this.updateTimers[sessionId]) {\r\n            clearTimeout(this.updateTimers[sessionId]);\r\n        }\r\n        this.updateTimers[sessionId] = setTimeout(function() {\r\n            sessionStore.get(sessionId, function(err, session) {\r\n                dao._saveSession(sessionId, session)\r\n            });\r\n        }, 500);\r\n    } else {\r\n        if (this.timeoutTimers[sessionId]) {\r\n            clearTimeout(this.timeoutTimers[sessionId]);\r\n        }\r\n        this.timeoutTimers[sessionId] = setTimeout(function() {\r\n            sessionStore.getSessionTimeout(sessionId, function(err, timeout) {\r\n                dao._saveTimeout(sessionId, timeout)\r\n            });\r\n        }, 500);\r\n    }\r\n}\r\n```\r\n\r\nTo understand the difference between throttling and debouncing, let's\r\nconsider an example, where requests for the same session come every \r\n`100ms` for `1sec`. In case of `500ms` debouncing, changes will be \r\npersisted one time. In case of `500ms` throttling, changes will be\r\npersisted two times. Without any optimisation, changes will be\r\npersisted ten times.\r\n\r\n## Custom Storage Driver\r\n\r\nIt is possible to use your own driver. In order to do that, user shall inject its own implementation of a store. \r\n\r\nThe class shall implement the following interface:\r\n```typescript\r\n\r\ninterface UserCustomStore {\r\n\r\n  // delete all sessions\r\n  clear(): Promise<void>;\r\n\r\n  // remove <sessionId> session\r\n  destroy(sessionId : string): Promise<void>; \r\n\r\n  // retrieve <sessionId> session\r\n  get(sessionId : string): Promise<object | null>;\r\n\r\n  // number of sessions\r\n  length(): Promise<number>;\r\n\r\n  // get <sessionId> expiration\r\n  ttl(sessionId : string): Promise<number>;\r\n\r\n  // set <sessionId> data to <session> with <timeout> expiration\r\n  set(sessionId: string, session: object, timeout: number): Promise<void>;\r\n\r\n  // check if session <sessionId> exists\r\n  exists(sessionId: string): boolean; \r\n\r\n  // update existing session <sessionId> expiration to <timeout>\r\n  resetTimer(sessionId: string, timeout: number); \r\n}  \r\n```\r\n\r\nIn addition, the file should include a method to get an instance of the store, for example:\r\n```typescript\r\nlet store;\r\nmodule.exports.getStore = () => {\r\n  if (!store) {\r\n    store = new UserCustomStore();\r\n  }\r\n  return store;\r\n};\r\n```\r\n\r\nsee [Redis store](../lib/utils/redis-store.js) for example\r\n\r\nIn order for app router to use it, user shall set ```externalStoreFilePath``` property in the ```EXT_SESSION_MGT``` env variable with the path to the storage.  \r\nThe application router will use this path to require your storage.\r\n\r\nThe application router uses the defaultRetryTimeout and the backOffMultiplier properties in the EXT_SESSION_MGT environment variable to determine the Redis pattern for automatic retries of failed operations.\r\n\r\nFor example: \r\n```json\r\n{\r\n    \"instanceName\": \"approuter-redis\",\r\n    \"storageType\": \"redis\",\r\n    \"sessionSecret\": \"someuniquesessionsecret\",\r\n    \"externalStoreFilePath\": \"./src/storage/my-special-storage\",\r\n    \"defaultRetryTimeout\": 10000,\r\n    \"backOffMultiplier\":  10\r\n}\r\n``` \r\n\r\n## Credentials Structure when using Redis\r\n\r\nRedis store can be used on both CF and Kyma, however the external session managment expects to receive the credentials in a certain structure,\r\nsimilar to the structure of the CF redis service instance.\r\nIf you're using Kyma, create a [K8s secret](https://kubernetes.io/docs/tasks/configmap-secret/managing-secret-using-config-file/#create-the-config-file) that includes the credentials in the following structure:\r\n```json\r\n{\r\n    \"cluster_mode\": \"(Mandatory) boolean\",\r\n    \"tls\": \"(Mandatory) boolean\",\r\n    \"ca_base64\": \"(Optional) string\",\r\n    \"sentinel_nodes\": \"(Optional) Array of objects of hostname and port, e.g '[{hostname: 127.0.0.1, port: 26543}]'\",\r\n    \"uri\": \"(Mandatory if using sentinel_nodes) string\",\r\n    \"password\": \"(Mandatory) string\",\r\n    \"hostname\": \"(Mandatory) string\",\r\n    \"port\": \"string\"\r\n}\r\n```\r\n"},{"name":"sizingGuide.md","content":"Sizing Guide for Application Router\r\n===================================\r\n\r\n<!-- toc -->\r\n\r\n- [Idle](#idle)\r\n- [Test Setup](#test-setup)\r\n- [HTTP Traffic](#http-traffic)\r\n- [Web Socket Traffic](#web-socket-traffic)\r\n- [Memory Configuration](#memory-configuration)\r\n\r\n<!-- tocstop -->\r\n\r\nIn this guide we provide measurements done in different application router scenarios. You can use them to approximately calculate the amount of memory that would be required by the application router. The tables contain the exact results from the measurements with Node.js v6.9.1. It is a good idea to provide higher numbers for productive usage.\r\n\r\nAll measurements are with authentication. If you have additional session content and want to count the session memory consumption please take a look at what is stored in the session - described in README's [Session Contents](../README.md#session-contents) section. You will need to add the calculated session size taking into account the number of different users and the session timeout. In our tests only the JWT token took ~4KB.\r\n\r\n## Idle\r\nThe memory consumption for an idle application router is around 50 MB.\r\n\r\n## Test Setup\r\n\r\nThe application router runs in a container with limited amount of memory. Swap is turned off.\r\nThe test client creates new sessions on the server with a step of 100.\r\nNo more than 100 users request the application router at a given time\r\n(e.g. 100 sessions are initialized and become idle, then 100 more session are created and become idle ...).\r\nThe test ends when an *Out of Memory* event occurs, causing the container to be stopped.\r\nThe number of created sessions before the process ends is taken.\r\n\r\n## HTTP Traffic\r\n\r\nThere are 2 separate test scenarios depending on what is done after a session is created:\r\n- Scenario (1)\r\n  - A 'Hello World' static resource is being served.\r\n- Scenario (2)\r\n  - A 'Hello World' static resource is being served.\r\n  - A static resource of 84.78kb (compressed by application router to 28.36kb) is being served.\r\n  - A backend which returns a payload of 80kb (compressed by application router to 58kb) is being called.\r\n  - Another backend which returns a payload of 160kb (compressed by application router to 116kb) is being called.\r\n\r\nMemory Limit | Max Sessions - Scenario (1) | Max Sessions - Scenario (2)\r\n------------ | --------------------------- | ---------------------------\r\n256MB        | 5 300                       | 800\r\n512MB        | 13 300                      | 2 300\r\n1GB          | 30 100                      | 8 400\r\n2GB          | 65 500                      | 19 500\r\n4GB          | 134 900                     | 46 400\r\n8GB          | 275 500                     | 102 300\r\n\r\n## Web Socket Traffic\r\n\r\nThere are 2 separate test scenarios depending on what is done after a session is created:\r\n- Scenario (1)\r\n  - A 'Hello World' static resource is being served.\r\n  - A single 'Hello' message is sent and then received through a web socket connection.\r\n- Scenario (2)\r\n  - A 'Hello World' static resource is being served.\r\n  - A backend which returns a payload of 80kb over a web socket is being called.\r\n  - Another backend which returns a payload of 160kb over a web socket is being called.\r\n\r\n**Note**: Web sockets require a certain amount of file handles to be available to the process - it is approximately two times the number of the sessions.\r\nIn Cloud Foundry the default value is 16384.\r\n\r\nMemory Limit | Max Sessions - Scenario (1) | Max Sessions - Scenario (2)\r\n------------ | --------------------------- | ---------------------------\r\n256MB        | 600                         | 300\r\n512MB        | 1 100                       | 500\r\n1GB          | 3 100                       | 800\r\n2GB          | 6 500                       | 1 400\r\n4GB          | 13 300                      | 2 900\r\n8GB          | 20 700                      | 6 100\r\n\r\n**Note**: `--max-old-space-size` restricts the amount of memory used in the JavaScript heap.\r\nIts default value is below 2GB. So in order to use the full resources that has been provided to the application,\r\nthe value of this restriction should be set to a number equal to the memory limit of the whole application.\r\n\r\nFor example, if the application memory is limited to 2GB, set the V8 heap limit like this in the `package.json`:\r\n```\r\n    \"scripts\": {\r\n        \"start\": \"node --max-old-space-size=2048 node_modules/@sap/approuter/approuter.js\"\r\n    }\r\n```\r\n\r\n## Memory Configuration\r\n\r\nApplication router process should run with at least 256MB memory. It may require more memory depending on the application.\r\nThese aspects influence memory usage:\r\n- concurrent connections\r\n- active sessions\r\n- JWT token size\r\n- backend session cookies\r\n"}]},{"name":"README.md","content":"@sap/approuter\r\n==============\r\n\r\n<!-- toc -->\r\n\r\n- [Overview](#overview)\r\n- [Deploying a business application with microservices](#deploying-a-business-application-with-microservices)\r\n- [Working directory](#working-directory)\r\n- [Configurations](#configurations)\r\n  * [Destinations](#destinations)\r\n    + [Environment-destinations](#environment-destinations)\r\n    + [Destination-service](#destination-service)\r\n  * [UAA configuration](#uaa-configuration)\r\n  * [Additional headers configuration](#additional-headers-configuration)\r\n  * [Additional cookies configuration](#additional-cookies-configuration)\r\n  * [Plugins configuration](#plugins-configuration)\r\n  * [Session timeout configuration](#session-timeout-configuration)\r\n  * [X-Frame-Options configuration](#x-frame-options-configuration)\r\n  * [Cross-Origin Resource Sharing configuration](#cross-origin-resource-sharing-configuration)\r\n  * [Direct Routing URI Patterns configuration](#direct-routing-uri-patterns-configuration)\r\n  * [NodeJS Minimal Logging Level configuration](#nodejs-minimal-logging-level-configuration)\r\n- [Routes](#routes)\r\n  * [Example routes](#example-routes)\r\n- [Replacements](#replacements)\r\n- [*xs-app.json* configuration file](#xs-appjson-configuration-file)\r\n  * [*welcomeFile* property](#welcomefile-property)\r\n  * [*authenticationMethod* property](#authenticationmethod-property)\r\n  * [*routes* property](#routes-property)\r\n  * [*login* property](#login-property)\r\n  * [*logout* property](#logout-property)\r\n  * [*destinations* property](#destinations-property)\r\n  * [*services* property](#services-property)\r\n  * [*responseHeaders* property](#responseHeaders-property)\r\n  * [*compression* property](#compression-property)\r\n  * [*pluginMetadataEndpoint* property](#pluginmetadataendpoint-property)\r\n  * [*whitelistService* property](#whitelistservice-property)\r\n  * [*websockets* property](#websockets-property)\r\n  * [*errorPage* property](#errorpage-property)\r\n  * [*cors* property](#cors-property)\r\n  * [Complete example of an *xs-app.json* configuration file](#complete-example-of-an-xs-appjson-configuration-file)\r\n- [Headers](#headers)\r\n  * [Forwarding Headers](#forwarding-headers)\r\n  * [Hop-by-hop Headers](#hop-by-hop-headers)\r\n  * [Custom Headers](#custom-headers)\r\n  * [Authorization Header](#authorization-header)\r\n- [CSRF Protection](#csrf-protection)\r\n- [Support of SAP Statistics](#support-of-sap-statistics)\r\n- [Connectivity](#connectivity)\r\n- [SaaS Application Registration in CF](#saas-application-registration-in-cloud-foundry)\r\n  * [How To Expose Approuter for SaaS Subscription](#how-to-expose-approuter-for-saas-subscription)\r\n- [Authentication with Identity Service (IAS)](#authentication-with-identity-service-ias)\r\n- [Mutual TLS Authentication (mTLS) and Certificates Handling](#mutual-tls-authentication-mtls-and-certificates-handling)\r\n- [Integration with HTML5 Application Repository](#integration-with-html5-application-repository)\r\n- [Integration with Business Services](#integration-with-business-services)\r\n- [Web Sockets](#web-sockets)\r\n- [Session Handling](#session-handling)\r\n  * [Session Contents](#session-contents)\r\n- [External Session Management](#external-session-management)\r\n- [Service to Application Router](#service-to-application-router)\r\n- [Central Logout](#central-logout)\r\n- [User API Service](#user-api-service)\r\n- [Allowlist Service](#whitelist-service)\r\n  * [Enable the service](#enable-the-service)\r\n  * [Configuring allowed hostnames / domains](#configuring-allowed-hostnames--domains)\r\n  * [Return value](#return-value)\r\n- [Scaling](#scaling)\r\n- [Sizing Guide for Application Router](#sizing-guide-for-application-router)\r\n- [Configure server-side HTTPS](#configure-server-side-https)\r\n- [Audit-Log Service](#audit-log-service)\r\n- [Troubleshooting](#troubleshooting)\r\n- [Getting Support](#getting-support)\r\n- [Extending Application Router](#extending-application-router)\r\n- [Best practices](#best-practices)\r\n  * [Security best practices](#security-best-practices)\r\n    + [Content-Security-Policy](#content-security-policy)\r\n\r\n<!-- tocstop -->\r\n\r\n## Overview\r\n\r\nWhen a business application consists of several different apps  (microservices),\r\nthe application router is used to provide a single entry point to that business application.\r\nIt has the responsibility to:\r\n\r\n* Dispatch requests to backend microservices (reverse proxy)\r\n* Authenticate users\r\n* Serve static content\r\n\r\n\r\n![Application router overview diagram](doc/app-router-diagram.png \"Overview diagram\")\r\n\r\n\r\nLet's think of the different apps (microservices) as _destinations_ to which the incoming request will be forwarded.\r\nThe rules that determine which request should be forwarded to which destination are called _routes_.\r\nFor every destination there can be more than one route. You may read more on the concept of [routes](#routes) later in this document.\r\nIf the backend microservices require authentication, the application router can be configured to authenticate the users and propagate the user information.\r\nAgain by using routes, the application router can serve static content.\r\n\r\nThe application router is designed to work in XS Advanced - Cloud Foundry and XS OnPremise Runtime.\r\n\r\nA calling component accesses a target service by means of the application router only if there is no JWT token available, for example, \r\nif a user invokes the application from a Web browser.\r\nIf a JWT token is already available, for example, because the user has already been authenticated, or the calling component uses a JWT token for its own OAuth client,\r\nthe calling component calls the target service directly; it does not need to use the application router.\r\n\r\n**Note** that the application router does not hide the backend microservices in any way. They are still directly accessible bypassing the application router. So the backend microservices _must_ protect all their endpoints by validating the JWT token and implementing proper scope checks. Network isolation is not provided currently by the platform.\r\n\r\n## Deploying a business application with microservices\r\n\r\nFor example we can have a business application that has the following structure:\r\n\r\n<pre>\r\n+-- manifest.yml\r\n+-- manifest-op.yml\r\n|  +-- microservice-1\r\n|  | +-- ...\r\n|  | +-- ...\r\n|  +-- microservice-2\r\n|  | +-- ...\r\n|  | +-- ...\r\n|  +-- web\r\n|  | +-- ...\r\n|  | +-- ...\r\n</pre>\r\n\r\nThe *manifest.yml* file is used to deploy the business application on Cloud Foundry and the *manifest-op.yml* - on the XS OnPremise Runtime.\r\nThese files should describe all the microservices for that business application.\r\n\r\nFolders are used to isolate the different microservices. Let's assume that the application router is the microservice in the *web* folder (every business application has its own application router).\r\nHere is how we can include the application router:\r\n\r\n* Manually create the *node_modules* folder in the *web* folder.\r\n* Copy and paste the folder that contains the self-contained application router into *node_modules*. In this example the name of that folder is *@sap/approuter*, see the *start* script in the *package.json* below.\r\n* Check the version of the application router you just copied.\r\n* Create a *package.json* file in *web* with content similar to the following and replace the version's value with the version of your application router:\r\n\r\n```json\r\n{\r\n    \"name\": \"hello-world-approuter\",\r\n    \"dependencies\": {\r\n       \"@sap/approuter\": \"2.6.1\"\r\n    },\r\n    \"scripts\": {\r\n        \"start\": \"node node_modules/@sap/approuter/approuter.js\"\r\n    }\r\n}\r\n```\r\n\r\nIn order to use the application router you don't have to write any JavaScript code.\r\nOnly some configurations have to be provided in the *web* folder. Here is a complete example:\r\n\r\n<pre>\r\n+-- web\r\n| +-- package.json\r\n| +-- xs-app.json\r\n| +-- resources\r\n| | +-- hello-world.html\r\n| | +-- my-page.html\r\n| +-- node_modules\r\n| |   +-- ...\r\n| +-- default-env.json\r\n| +-- default-services.json\r\n</pre>\r\n\r\nThe *web* folder contains the *package.json*, *node_modules*, some configuration files used by the application router, and static resources to be served.\r\nYou can read more about the [configurations](#configurations) later in this document.\r\n\r\nBy default, the application router runs on port 5000 (if started locally) or it takes the port from the `PORT` environment variable.\r\n\r\n## Working directory\r\n\r\nThe working directory contains configuration files that the application router needs and static resources that can be served at runtime.\r\nIn the [previous example](#deploying-a-business-application-with-microservices), the *web* folder is the working directory.\r\nBy default the current directory is the working directory.\r\nIt is possible to configure it during start up of the application router with the following command line argument:\r\n\r\n```bash\r\nnode approuter.js -w <working-dir>\r\n```\r\n\r\nApplication router will abort if the working directory does not contain *xs-app.json* file.\r\n\r\n## Configurations\r\n\r\nThe application router makes use of the following configurations:\r\n\r\n- [Main configuration](#xs-appjson-configuration-file) - this is the *xs-app.json* file. This file is mandatory and contains the main configurations of the application router.\r\n\r\n- [UAA configuration](#uaa-configuration) - the application router reads this configuration either from the `VCAP_SERVICES` environment variable (when deployed on Cloud Foundry or XS Advanced OnPremise Runtime)\r\nor from the *default-services.json* file (when running locally). Refer to the documentation of the `@sap/xsenv` package for more details.\r\n\r\n- Configurations from the environment - these configurations are either read from the application router's environment (when deployed on Cloud Foundry or XS Advanced OnPremise Runtime)\r\nor from the *default-env.json* file (when running locally). Refer to the documentation of the `@sap/xsenv` package for more details.\r\nThe environment variables that the application router takes into account are:\r\n\r\n\r\nConfiguration | Environment variable | Description\r\n------------- | -------------------- | ------------\r\n[UAA service name](#uaa-configuration) | `UAA_SERVICE_NAME` | Contains the name of the UAA service to be used.\r\n[Destinations](#destinations) | `destinations` | Provides information about the available destinations.\r\n[Additional headers](#additional-headers-configuration) | `httpHeaders` | Provides headers that the application router will return to the client in its responses.\r\n[Additional cookies](#additional-cookies-configuration) | `COOKIES` | Provides cookies that the application router will return to the client in its responses. Currently only SameSite cookie is supported.\r\n[Plugins](#plugins-configuration) | `plugins` | A plugin is just like a [*route*](#routes) except that you can't configure some inner properties.\r\n[Session timeout](#session-timeout-configuration) | `SESSION_TIMEOUT` | Positive integer representing the session timeout in minutes. The default timeout is 15 minutes.\r\n[X-Frame-Options](#x-frame-options-configuration) | `SEND_XFRAMEOPTIONS`, `httpHeaders` | Configuration for the X-Frame-Options header value.\r\n[Allowlist service](#whitelist-service) | `CJ_PROTECT_WHITELIST` | Configuration for the allowlist that is preventing clickjack attacks.\r\n[Web Sockets origins allowlist](#web-sockets) | `WS_ALLOWED_ORIGINS` | An allowlist configuration that is used for verifying the `Origin` header of the initial upgrade request when establishing a web socket connection.\r\nJWT Token refresh | `JWT_REFRESH` | The time in minutes before a JWT token expires and the application router should trigger a token refresh routine.\r\nIncoming connection timeout | `INCOMING_CONNECTION_TIMEOUT` | Maximum time in milliseconds for a client connection. After that time the connection is closed. If set to 0, the timeout is disabled. Default: 120000 (2 min)\r\nTenant host pattern | `TENANT_HOST_PATTERN` | String containing a regular expression with a capturing group. The request host is matched against this regular expression. The value of the first capturing group is used as tenant id.\r\nDestination host pattern | `DESTINATION_HOST_PATTERN` | String containing a regular expression with a capturing group. The request host is matched against this regular expression. The value of the capturing group is used as destination name.\r\n[Compression](#compression-property) | `COMPRESSION` | Configuration regarding compressing resources before responding to the client.\r\n_Secure_ flag of session cookie | `SECURE_SESSION_COOKIE` | Can be set to `true` or `false`. By default, the _Secure_ flag of the session cookie is set depending on the environment the application router runs in. For example, when application router is behind a router (Cloud Foundry's router or SAP Web Dispatcher) that is configured to serve HTTPS traffic, then this flag will be present. During local development the flag is not set. This environment variable can be used to enforce setting or omitting the _Secure_ flag. **Note**: If the Secure flag is enforced, the application router will reject requests sent over unencrypted connection (http).\r\nTrusted CA certificates | `XS_CACERT_PATH` | List of files paths with trusted CA certificates used for outbound https connections (UAA, destinations, etc.). File paths are separated by [path.delimiter](https://nodejs.org/api/path.html#path_path_delimiter). If this is omitted, several well known \"root\" CAs (like VeriSign) will be used. This variable is set automatically by XSA On-premise runtime.\r\nReject untrusted certificates | `NODE_TLS_REJECT_UNAUTHORIZED` | By default an outbound https connection is terminated if the remote end does not provide a trusted certificate. This check can be disabled by setting `NODE_TLS_REJECT_UNAUTHORIZED` to `0`. This is a built-in feature of Node.js. **Note:** Do not use this in production as it compromises security!\r\nExternal reverse proxy flag | `EXTERNAL_REVERSE_PROXY` | Boolean value that indicates the use of application router behind an external reverse proxy (outside of Cloud Foundry domain)\r\nSkip client credentials tokens load on start | `SKIP_CLIENT_CREDENTIALS_TOKENS_LOAD` | Boolean value that indicates that no client credentials tokens should be created during the application router start phase \r\n[Cross-Origin Resource Sharing](#cross-origin-resource-sharing-configuration) | `CORS` | Configuration regarding CORS enablement.\r\nPreserve URL fragment | `PRESERVE_FRAGMENT` | When set to `true` or not set, fragment part of the URL provided during first request of not logged-in user to protected route will be preserved, and after login flow user is redirected to original URL including fragment part. However, this may break programmatic access to Approuter (e.g. e2e tests), since it introduces change in login flow, which is incompatible with Approuter version 4.0.1 and earlier. Setting value to `false` makes login flow backward compatible, however will not take fragment part of the URL into account.\r\n[Direct Routing URI Patterns](#direct-routing-uri-patterns-configuration) | `DIRECT_ROUTING_URI_PATTERNS` | Configuration for direct routing URI patterns. \r\n[NodeJS Minimal Logging Level](#nodejs-minimal-logging-level-configuration) | `CF_NODEJS_LOGGING_LEVEL` | Configuration for NodeJS minimal logging level. \r\nBackend Cookies Secret | `BACKEND_COOKIES_SECRET` | Secret that is used to encrypt backend session cookies in service to Application Router flow. Should be set in case multiple instances of Application Router are used. By default a random sequence of characters is used.\r\nService to Application Router | `SERVICE_2_APPROUTER` | If `true`, when the SAP Passport header is received from the application router, it will be transferred without modification to the backend application.\r\nClient certificate header name | `CLIENT_CERTIFICATE_HEADER_NAME` | When set application router will use this header name to get the client certificate from the request header in subscription callback. If not provided the default header name `x-forwarded-client-cert` is used.\r\nServer Keep Alive | `SERVER_KEEP_ALIVE` | server keep alive timeout (positive integer in milliseconds).\r\nMinimum Token Validity | `MINIMUM_TOKEN_VALIDITY` | positive integer in seconds. When set, approuter will check that the token returned from the authorization service has an expiration time higher than the minimum token validity value.\r\n\r\n\r\n**Note:** all those environment variables are optional.\r\n\r\n\r\n### Destinations\r\n\r\nThe destinations configuration can be provided by the `destinations` environment variable or by destination  service. There has to be a destination for every single app (microservice) that is a part of the business application.\r\n\r\n#### Environment destinations\r\n\r\nThe destinations configuration is an array of objects. Here are the properties that a destination can have:\r\n\r\nProperty | Type | Optional | Description\r\n-------- | ---- |:--------:| -----------\r\nname | String | | A unique alphanumeric identifier of the destination.\r\nurl | String | | URL of the app (microservice).\r\nproxyHost | String | x | The host of the proxy server used in case the request should go through a proxy to reach the destination.\r\nproxyPort | String | x | The port of the proxy server used in case the request should go through a proxy to reach the destination.\r\nforwardAuthToken | Boolean | x | If `true`, the OAuth token is sent to the destination. The default value is `false`. This token contains user identity, scopes and other attributes. It is signed by the UAA or IAS service, so it can be used for user authentication and authorization with backend services.\r\nstrictSSL | Boolean | x | Configures whether the application router should reject untrusted certificates. The default value is `true`.<br />**Note:** Do not use this in production as it compromises security!\r\ntimeout | Number | x | Positive integer representing the maximum wait time for a response (in milliseconds) from the destination. Default is 30000ms.\r\nsetXForwardedHeaders | Boolean | x | If `true` , the application router adds X-Forwarded-(Host, Path, Proto) headers to the backend request.Default value is true.\r\nproxyType | String | x | Configures whether the destination is used to access applications in on-premise networks or on public Internet. Possible value: `OnPremise`. if the property is not provided, it is assumed that it is a public Internet access. <br />**Note:** if `OnPremise` value is set,  binding to SAP Cloud Platform connectivity service is required, and `forwardAuthToken` property should not be set.\r\n\r\n\r\n**Note:** The timeout specified will also apply to the [destination's logout path](#destinations-property) or  [service's logout path](#services-property) (if you have set one). <br />\r\n**Note:** `proxyHost` and `proxyPort` are optional, but if one of them is defined, then the other one becomes mandatory.\r\n\r\nSample content of the destinations environment variable:\r\n\r\n```json\r\n[\r\n  {\r\n    \"name\" : \"ui5\",\r\n    \"url\" : \"https://ui5.sap.com\",\r\n    \"proxyHost\" : \"proxy\",\r\n    \"proxyPort\" : \"8080\",\r\n    \"forwardAuthToken\" : false,\r\n    \"timeout\" : 1200\r\n  }\r\n]\r\n```\r\n\r\nIt is also possible to include the destinations in the *manifest.yml* and *manifest-op.yml* files:\r\n\r\n```yml\r\n- name: node-hello-world\r\n  memory: 100M\r\n  path: web\r\n  env:\r\n    destinations: >\r\n                  [\r\n                    {\"name\":\"ui5\", \"url\":\"https://ui5.sap.com\"}\r\n                  ]\r\n```\r\n\r\n#### Destination service\r\n\r\nDestination configuration can also be read from `destination service` .<br>\r\nHere are the Approuter limitations to destination properties configuration from destination service :\r\n\r\nProperty  | Additional Property | Description\r\n-------- |:--------:| -----------\r\nType | |only `HTTP` supported.\r\nAuthentication |  | All authentication types are supported. <br>**Note:** `User` and `Password` are mandatory if the authentication type is `basic authentication`.<br>**Note:** if the authentication type set to `principal propagation` the ProxyType have to be `on-premise`.<br>**Note:** if the authentication type set to `OAuth2SAMLBearerAssertion`, `uaa.user` scope in xs-security.json is required.\r\nProxyType |   | Supported proxy type : `on-premise`, `internet`, `private-link`.<br> **Note:** if ProxyType set to `on-premise`, binding to SAP Cloud Platform connectivity service is required.<br> **Note:** The `private-link` proxy type is a beta feature and is not meant for productive use. It is only available in Azure landscapes.\r\n\r\n\r\n##### Optional additional properties:\r\n\r\nProperty  | Additional Property | Description\r\n-------- |:--------:| -----------\r\nHTML5.ForwardAuthToken | x | If `true` the OAuth token will be sent to the destination. The default value is `false`. This token contains user identity, scopes and other attributes. It is signed by the UAA so it can be used for user authentication and authorization with backend services.<br> **Note:** if ProxyType set to `on-premise`, ForwardAuthToken property should not be set.<br> **Note:** if Authentication type is other than NoAuthentication, ForwardAuthToken property should not be set.\r\nHTML5.Timeout |  x | Positive integer representing the maximum wait time for a response (in milliseconds) from the destination. Default is 30000ms.**Note:** The timeout specified will also apply to the [destination's logout path](#destinations-property) or [service's logout path](#services-property) (if you have set one). \r\nHTML5.PreserveHostHeader | x | If `true` , the application router preserves the host header in the backend request.<br />This is expected by some back-end systems like AS ABAP, which do not process x-forwarded-* headers.\r\nHTML5.DynamicDestination | x | If `true` , the application router allows to use this destination dynamically on host or path level.\r\nHTML5.SetXForwardedHeaders | x | If `true` , the application router adds X-Forwarded-(Host, Path, Proto) headers to the backend request.Default value is true.\r\nsap-client | x | If provided, the application router propagates the sap-client and its value as a header in the backend request.<br />This is expected by ABAP back-end systems.\r\nURL.headers.`<header-name>` | x | If provided, the application router propagates this special attribute in the destination as the header. The application router can get the headers list from the destination API. Existing request headers are not overwritten.\r\n\r\n<br />**Note:** \r\n* In case destination with the same name is defined both in environment destination and destination service, the destination configuration will load from the environment.\r\n* Destinations on destination service instance level are supported.\r\n* Only destination client certificates of type p12 are supported.\r\n* Only destination trust certificates of the type privacy-enhanced mail (PEM) are supported.\r\n\r\n### UAA configuration\r\n\r\nThe User Account and Authentication (UAA) server is responsible for user authentication.\r\nIn Cloud Foundry and XS OnPremise Runtime a service is created for this configuration and by using the standard service binding mechanism\r\nthe content of this configuration is available in the `VCAP_SERVICES` environment variable.</br>\r\n**Note:** The service should have `xsuaa` in its tags or the environment variable `UAA_SERVICE_NAME` should be specified (stating the exact name of the UAA service).</br>\r\nDuring local development the UAA configuration is provided in the *default-services.json* file.\r\nWhen the UAA is used for authentication the user is redirected to the UAA's login page to enter their credentials.\r\n\r\nSample content for a *default-services.json* file:\r\n\r\n```json\r\n{\r\n    \"uaa\": {\r\n        \"url\" : \"http://my.uaa.server/\",\r\n        \"clientid\" : \"client-id\",\r\n        \"clientsecret\" : \"client-secret\",\r\n        \"xsappname\" : \"my-business-application\"\r\n    }\r\n}\r\n```\r\n\r\nThe application router supports the `$XSAPPNAME` placeholder (upper case letters). You may use it in your [route](#routes) configurations in the scope property.\r\nThe value of `$XSAPPNAME` is taken from the UAA configuration (the `xsappname` property).\r\n\r\n### Additional headers configuration\r\n\r\nIf configured, the application router can send additional http headers in its responses to the client.\r\nAdditional headers can be set in the `httpHeaders` environment variable.\r\n\r\nSample configuration for additional headers:\r\n\r\n```json\r\n[\r\n  {\r\n    \"X-Frame-Options\": \"ALLOW-FROM http://localhost\"\r\n  },\r\n  {\r\n    \"Test-Additional-Header\": \"1\"\r\n  }\r\n]\r\n```\r\nIn this case, the application router sends two additional headers in the responses to the client.<br>\r\nCustom response headers, configured in the application router configuration file (xs-app.json) are added to the list of additional http headers.\r\nIf the response header name already exists in the additional http headers list, the value of the response header name overrides the value of the http header.  \r\n\r\n**Caution:** For security reasons, the following headers must not be configured: authorization', 'cookie', and 'set-cookie'.\r\n\r\n### Additional cookies configuration\r\n\r\nIf configured, the application router will send additional cookie values in its responses to the client.\r\nAdditional cookie values can be set in the `COOKIES` environment variable.\r\n\r\nExample of configuration for cookies in the manifest.yml :\r\n\r\n```json\r\n  env:\r\n   COOKIES: >\r\n        { \"SameSite\":\"None\" }\r\n```\r\nIn this example, the application router sets the SameSite cookie attribute to None for the JSESSIONID cookie in the responses to the client.\r\n\r\nNote: Currently, only the SameSite cookie value is supported. SameSite = \"Strict\" is not supported.\r\n\r\n### Plugins configuration\r\n\r\nA plugin serves almost the same purpose as [*routes*](#routes). The difference is that plugins can be configured through the environment and that way you can add new routes to the application router without changing the design-time artefact *xs-app.json*. The plugin configuration properties are the same as those of a [*route*](#routes) except that you can't configure `localDir`, `replace` and `cacheControl`.\r\n\r\nProperty | Type | Optional | Description\r\n-------- | ---- |:--------:| -----------\r\nname | String | | The name of this plugin\r\nsource | String/Object | | Describes a regular expression that matches the incoming [request URL](https://nodejs.org/api/http.html#http_message_url).</br> **Note:** A request matches a particular route if its path __contains__  the given pattern. To ensure the RegExp matches the complete path, use the following form: ^<path>$`. </br> **Note:** Be aware that the RegExp is applied to on the full URL including query parameters.\r\ntarget | String | x | Defines how the incoming request path will be rewritten for the corresponding destination.\r\ndestination | String | | An alphanumeric name of the destination to which the incoming request should be forwarded.\r\nauthenticationType | String | x | The value can be ias, xsuaa, basic, or none. The default authenticationType depends on the authentication service binding: If the application router is bound to the Identity Authentication service, the default authenticationType is ias. Otherwise, the default value is xsuaa. If xsuaa or ias are used, the specified authentication server (Identity Authentication or User Account and Authentication) handles the authentication (the user is redirected to the login form of Identity Authentication or User Account and Authentication). The basic authenticationType works with SAP S/4HANA users, SAP ID service, and Identity Authentication service. For more information, see the SAP Note 3015211 - BASIC authentication options for SAP BTP Cloud Foundry applications. If the value none is used, no authentication is required for this route.\r\n</br>.\r\ncsrfProtection | Boolean | x | Enable [CSRF protection](#csrf-protection) for this route. The default value is `true`.\r\nscope | Array/String/Object | x | Scopes are related to the permissions a user needs to access a resource. This property holds the required scopes to access the target path. Access is granted if the user has at least one of the listed scopes. **Note:** Scopes are defined as part of the xsuaa service instance configuration. You can use `ias` as authenticationType and xsuaa scopes for authorization if the application router is bound to both (`ias` and `xsuaa`).\"\r\n\r\nSample content of the `plugins` environment variable:\r\n```json\r\n[\r\n  {\r\n    \"name\": \"insecurePlugin\",\r\n    \"source\": \"/plugin\",\r\n    \"destination\": \"plugin\",\r\n    \"target\": \"/\",\r\n    \"csrfProtection\": false,\r\n    \"scope\": [\"viewer\", \"reader\"]\r\n  },\r\n  {\r\n    \"name\": \"publicPlugin\",\r\n    \"source\": \"/public-plugin\",\r\n    \"destination\": \"publicPlugin\",\r\n    \"authenticationType\": \"none\"\r\n  }\r\n]\r\n```\r\n\r\n### Session timeout configuration\r\n\r\nFor example, if you have the following line in your *manifest.yml* or *manifest-op.yml* file:\r\n\r\n```yml\r\n- name: node-hello-world\r\n  memory: 100M\r\n  path: web\r\n  env:\r\n    SESSION_TIMEOUT: 40\r\n```\r\n\r\nAfter 40 minutes of user inactivity (no requests have been sent to the application router), a Central Logout will be triggered due to session timeout.\r\n\r\n**Note:** The application router depends on the UAA server for user authentication, if the `authenticationType` for a route is `xsuaa`. The UAA server may have a different session timeout configured.\r\nIt is recommended that the configurations of the application router and the UAA are identical.<br />\r\n\r\n### X-Frame-Options configuration\r\n\r\nApplication router sends `X-Frame-Options` header by default with value `SAMEORIGIN`. This behaviour can be changed in 2 ways:\r\n\r\n- Disable sending the default header value by setting `SEND_XFRAMEOPTIONS` environment variable to `false`\r\n- Override the value to be sent via [additional headers configuration](#additional-headers-configuration)\r\n\r\n## Cross-Origin Resource Sharing configuration\r\n\r\nThe CORS keyword enables you to provide support for cross-origin requests, for example, by allowing the modification of the request header. Cross-origin resource sharing (CORS) permits Web pages from other domains to make HTTP requests to your application domain, where normally such requests would automatically be refused by the Web browser's security policy.\r\nCross-origin resource sharing(CORS) is a mechanism that allows restricted resources on a webpage to be requested from another domain (/protocol/port) outside the domain (/protocol/port) from which the first resource was served. \r\nCORS configuration enables you to define details to control access to your application resource from other Web browsers. For example, you can specify where requests can originate from or what is allowed in the request and response headers. \r\n\r\nThe CORS configuration can be provided in the CORS environment variable or in the CORS property of the application router configuration file (xs-app.json).\r\nIf a cross-origin resource sharing (CORS) configuration exists in both the environment variables and the application router configuration file (xs-app.json), the application router gives priority to the CORS configuration in the application router configuration file.\r\n\r\nThe CORS configuration is an array of objects. Here are the properties that a CORS object can have:\r\n\r\nProperty | Type | Optional | Description\r\n-------- | ---- |:--------:| -----------\r\nuriPattern| String | | A regular expression representing for which source routes CORS configuration is applicable. To ensure the RegExp matches the complete path, surround it with ^ and $. **Defaults:** none.\r\nallowedOrigin| Array | | A comma-separated list of objects that each one of them containing host name, port and protocol that are allowed by the server.for example: [{?host?: \"www.sap.com\"}] or [{?host?: ?*.sap.com?}]. **Note:** matching is case-sensitive. In addition, if port or protocol are not specified the default is ?_*_?.  **Defaults:** none.\r\nallowedMethods| Array of upper-case HTTP methods| x | Comma-separated list of HTTP methods that are allowed by the server. **Defaults:** [?GET?, ?POST?, ?HEAD?, ?OPTIONS?] (all) applies. **Note:** matching is case-sensitive.\r\nmaxAge| Number| x | A single value specifying how long, in seconds, a preflight response should be cached. A negative value will prevent CORS Filter from adding this response header to pre-flight response.  **Defaults:** 1800. \r\nallowedHeaders| Array of headers| x | Comma-separated list of request headers that are allowed by the serve. **Defaults:** [?Origin?, ?Accept?, ?X-Requested-With?, ?Content-Type?, ?Access-Control-Request-Method?, ?Access-Control-Request-Headers?].\r\nexposeHeaders| Array of headers| x | Comma-separated list of response headers (other than simple headers) that can be exposed. **Defaults:** none.\r\nallowedCredentials| Boolean| x | A flag that indicates whether the resource supports user credentials. **Defaults:** true.\r\n\r\nSample content of the CORS environment variable:\r\n\r\n```json\r\n[\r\n  {\r\n      \"uriPattern\": \"^\\route1$\",\r\n      \"allowedMethods\": [\r\n        \"GET\"\r\n      ],\r\n      \"allowedOrigin\": [\r\n        {\r\n          \"host\": \"my_example.my_domain\",\r\n          \"protocol\": \"https\",\r\n          \"port\": 345\r\n        }\r\n      ],\r\n      \"maxAge\": 3600,\r\n      \"allowedHeaders\": [\r\n        \"Authorization\",\r\n        \"Content-Type\"\r\n      ],\r\n      \"exposeHeaders\": [\r\n        \"customHeader1\",\r\n        \"customHeader2\"\r\n      ],\r\n      \"allowedCredentials\": true\r\n    }\r\n]\r\n```\r\n\r\nIt is also possible to include the CORS in the *manifest.yml* and *manifest-op.yml* files:\r\n\r\n```yml\r\n- name: node-hello-world\r\n  memory: 100M\r\n  path: web\r\n  env:\r\n    CORS: >\r\n      [\r\n        {\r\n          \"allowedOrigin\":[\r\n                            {\r\n                                \"host\":\"my_host\",\r\n                                \"protocol\":\"https\"\r\n                            }\r\n                          ],\r\n          \"uriPattern\":\"^/route1$\"\r\n        }\r\n      ]\r\n```\r\nFor route with source that match the REGEX ?^\\route1$?, the CORS configuration is enabled.\r\n\r\n## Direct Routing URI Patterns configuration\r\n\r\nWith the direct routing URI patterns configuration, you can define a list of URIs that are directed to the routing configuration file (xs-app.json file) of the application router instead of to a specific application's xs-app.json file that is stored in the HTML5 Application Repository. This configuration improves the application loading time and monitoring options because it prevents unnecessary calls to the HTML5 Application Repository.\r\n\r\nThe configuration is an array of strings or regular expressions. \r\nNote that the following regular expressions are preconfigured in the configuration array: \"^favicon.ico$\", \"^login$\".\r\nTherefore, do not name your HTML5 applications \"favicon.ico\" or \"login\"!\r\n\r\nYou have to provide only the first segment in the URL, after the approuter host. For example, for the URL https://approuter-host/route1/index.html, you enter \"route1\" in the direct routing URI patterns array.\r\n\r\nSample content of the Direct Routing URI Patterns environment variable:\r\n\r\n```json\r\n  env:\r\n    DIRECT_ROUTING_URI_PATTERNS: >\r\n      [\"route1\", \"^route2$\", \"route3\"]\r\n```\r\n\r\n## NodeJS Minimal Logging Level configuration\r\n\r\nWith this configuration, you can set the minimal logging level of the *cf-nodejs-logging-support* library of the application router. The following levels are available:\r\n\r\n* *off*\r\n\r\n* *error*\r\n\r\n* *warn*\r\n\r\n* *info*\r\n\r\n* *verbose*\r\n\r\n* *debug*\r\n\r\n* *silly*\r\n\r\nThe default value is \"error\".\r\n\r\nHere is a sample content for the NodeJS minimal logging level environment variable:\r\n\r\n```json\r\n  env:\r\n    CF_NODEJS_LOGGING_LEVEL: \"debug\"\r\n```\r\n\r\n**Note** The application router also uses the *@sap/logging* library. To configure the log level for this library, you use the *XS_APP_LOG_LEVEL* environment variable.\r\n\r\n## Routes\r\n\r\nA route is a configuration that instructs the application router how to process an incoming request with a specific path.\r\n\r\nProperty | Type | Optional | Description\r\n-------- | ---- |:--------:| -----------\r\nsource | String/Object | | Describes a regular expression that matches the incoming [request URL](https://nodejs.org/api/http.html#http_message_url).</br> **Note:** A request matches a particular route if its path __contains__  the given pattern. To ensure the RegExp matches the complete path, use the following form: ^<path>$`. </br> **Note:** Be aware that the RegExp is applied to on the full URL including query parameters.\r\nhttpMethods | Array of upper-case HTTP methods | x | Which HTTP methods will be served by this route; the methods supported are: `DELETE`, `GET`, `HEAD`, `OPTIONS`, `POST`, `PUT`, `TRACE`, `PATCH` (no extension methods are supported). If this option is not specified, the route will serve any HTTP method.\r\ntarget | String | x | Defines how the incoming request path will be rewritten for the corresponding destination or static resource.\r\ndestination | String | x | The name of the destination to which the incoming request should be forwarded.  The destination name can be a static string or a regular expression that defines how to dynamically fetch the destination name from the source property or from the host.\r\nservice | String | x | The name of the service to which the incoming request should be forwarded.\r\nendpoint | String | x | The name of the endpoint within the service to which the incoming request should be forwarded. Can only be used in a route containing a service attribute.\r\nlocalDir | String | x | Folder in the [working directory](#working-directory) from which the application router will serve static content **Note:** localDir routes support only HEAD and GET requests; requests with any other method receive a 405 Method Not Allowed.\r\npreferLocal | Boolean | x | Defines from which subaccount the destination is retrieved. If preferLocal is true, the destination is retrieved from the provider subaccount. If preferLocal is false or undefined, the destination is retrieved from the subscriber subaccount.\r\nreplace | Object | x | An object that contains the configuration for replacing placeholders with values from the environment. *It is only relevant for static resources*. Its structure is described in [Replacements](#replacements).\r\nauthenticationType | String | x | The value can be `xsuaa`,`ias`, `basic` or `none`. The default one is `ias`, if subaccount trusts an ias tenant, else `xsuaa`. When `xsuaa` or `ias` are used the specified authentication server will handle the authentication (the user is redirected to the authentication service login form). The `basic` mechanism works with SAP HANA users, SAP ID Service and SAP Identity Authentication service. Find more details in SAP Note 3015211 - BASIC authentication options for SAP BTP Cloud Foundry applications. If `none` is used then no authentication is needed for this route.\r\ncsrfProtection | Boolean | x | Enable [CSRF protection](#csrf-protection) for this route. The default value is `true`.\r\nscope | Array/String/Object | x | Scopes are related to the permissions a user needs to access a resource. This property holds the required scopes to access the target path.\r\ncacheControl | String | x | String representing the value of the `Cache-Control` header, which is set on the response when serving static resources. By default the `Cache-Control` header is not set. *It is only relevant for static resources.*\r\nidentityProvider | String | x | The name of the identity provider to use if provided in routeâ€™s definition. If not provided, the route will be authenticated with the default identity provider. **Note:** If the authenticationType is set to Basic Authentication or None, do not define the identityProvider property.\r\n\r\n\r\n**Note:** The properties `destination`, `localDir` and `service` are optional, but exactly one of them must be defined. <br />\r\n**Note:** When using the property `replace` it is mandatory to define the `localDir` property. <br />\r\n**Note:** The cacheControl property is effective only when one of the following settings is performed:\r\n*\tThe localDir property was set\r\n*\tA service pointing to HTML5 Application Repository (\"service\": \"html5-apps-repo-rt\") was set\r\n \r\n### Example routes\r\n\r\nFor example, if you have a configuration with the following destination:\r\n\r\n```json\r\n[\r\n  {\r\n    \"name\" : \"app-1\",\r\n    \"url\" : \"http://localhost:3001\"\r\n  }\r\n]\r\n```\r\n\r\nHere are some sample route configurations:\r\n\r\n* Route with a `destination` and no `target`\r\n\r\n```json\r\n{\r\n    \"source\": \"^/app1/(.*)$\",\r\n    \"destination\": \"app-1\"\r\n}\r\n```\r\n\r\nSince there is no `target` property for that route, no path rewriting will take place.\r\nIf we receive */app1/a/b* as a path, then a request to *http://localhost:3001/app1/a/b* is sent.\r\nThe source path is appended to the destination URL.\r\n\r\n* Route with case-insensitive matching\r\n\r\n```json\r\n{\r\n    \"source\": {\r\n      \"path\": \"^/app1/(.*)$\",\r\n      \"matchCase\": false\r\n    },\r\n    \"destination\": \"app-1\"\r\n}\r\n```\r\n\r\nThis example is much like the previous one,\r\nbut instead of accepting only paths starting with */app1/*, we accept any variation of _app1_'s case. </br>\r\nThat means if we receive */ApP1/a/B*, then a request to *http://localhost:3001/ApP1/a/B* is sent. </br>\r\n**Note:** The property `matchCase` has to be of type boolean. It is optional and has a default value `true`.\r\n\r\n* Route with a `destination` and a `target`\r\n\r\n```json\r\n{\r\n    \"source\": \"^/app1/(.*)$\",\r\n    \"target\": \"/before/$1/after\",\r\n    \"destination\": \"app-1\"\r\n}\r\n```\r\n* Route with a `service`, a `target` and an `endpoint`\r\n\r\n```json\r\n{\r\n     \"source\": \"^/odata/v2/(.*)$\",\r\n     \"target\": \"$1\",\r\n     \"service\": \"com.sap.appbasic.country\",\r\n     \"endpoint\": \"countryservice\"\r\n}\r\n```\r\n\r\nWhen a request with path */app1/a/b* is received, the path rewriting is done according to the rules in the `target` property.\r\nThe request will be forwarded to http://localhost:3001/before/a/b/after.\r\n\r\n**Note:** In regular expressions there is the term _capturing group_. If a part of a regular expression is surrounded with parenthesis, then what has been matched can be accessed using _$_ + the number of the group (starting from 1).\r\nIn the last example _$1_ is mapped to the _(.*)_ part of the regular expression in the `source` property.\r\n\r\n* Route with dynamic `destination` and `target`\r\n\r\n```json\r\n{\r\n      \"source\": \"^/destination/([^/]+)/(.*)$\",\r\n      \"target\": \"$2\",\r\n      \"destination\": \"$1\",\r\n      \"authenticationType\": \"xsuaa\"\r\n    }\r\n```\r\nIf you have a another destination configured:\r\n```json\r\n[\r\n\t{\r\n\t\"name\" : \"myDestination\",\r\n\t\"url\" : \"http://localhost:3002\"\r\n\t}\r\n]\r\n```\r\nwhen a request with the path /destination/myDestination/myTarget is received, the destination will be replaced with the url from \"myDestination\", the target will get \"myTarget\" and the request will be redirected to http://localhost:3002/myTarget\r\n\r\n**Note:** You can use a dynamic value (regex) or a static string for both destination and target values\r\n\r\n**Note:** The approuter first looks for the destination name in the mainfest.yaml file, and if not found, looks for it in the destination service.\r\n\r\n* Destination In Host\r\n\r\nFor legacy applications that do not support relative URL paths, you need to define your URL in the following way to enable the destination to be extracted from the host\r\nthe url should be defined in the following way:\r\n\r\n```https://<tenant>-<destination>.<customdomain>/<pathtofile>```\r\n\r\nTo enable the application router to determine the destination of the URL host, a DESTINATION_HOST_PATTERN attribute must be provided as an environment variable.\r\n\r\nExample:\r\nWhen a request with the path https://myDestination.some-approuter.someDomain.com/app1/myTarget is received, the following route is used:\r\n```json\r\n {\r\n      \"source\": \"^/app1/([^/]+)/\",\r\n      \"target\": \"$1\",\r\n      \"destination\": \"*\",\r\n      \"authenticationType\": \"xsuaa\"\r\n }\r\n```\r\n \r\n In this example, the target will be extracted from the source and the â€˜$1â€™ value is replaced with â€˜myTargetâ€™. The destination value is extracted from the host and the â€˜*â€™ value is replaced with â€˜myDestinationâ€™.\r\n\r\n* Route with a `localDir` and no `target`\r\n\r\n```json\r\n{\r\n    \"source\": \"^/web-pages/(.*)$\",\r\n    \"localDir\": \"my-static-resources\"\r\n}\r\n```\r\n\r\nSince there is no `target` property for that route, no path rewriting will take place.\r\nIf we receive a request with a path */web-pages/welcome-page.html*, the local file at *my-static-resources/web-pages/welcome-page.html*\r\nunder the working directory will be served.\r\n\r\n* Route with a `localDir` and a `target`\r\n\r\n```json\r\n{\r\n    \"source\": \"^/web-pages/(.*)$\",\r\n    \"target\": \"$1\",\r\n    \"localDir\": \"my-static-resources\"\r\n}\r\n```\r\nIf we receive a request with a path '/web-pages/welcome-page.html', the local file at 'my-static-resources/welcome-page.html'\r\nunder the working directory will be served.</br> **Note:** The capturing group used in the `target` property.\r\n\r\n* Route with `localDir` and `cacheControl`\r\n\r\n```json\r\n{\r\n  \"source\": \"^/web-pages/\",\r\n  \"localDir\": \"my-static-resources\",\r\n  \"cacheControl\": \"public, max-age=1000,must-revalidate\"\r\n}\r\n```\r\n\r\n* Route with `service` \"html5-apps-repo-rt\" and `cacheControl`\r\n\r\n```json\r\n{\r\n  \"source\": \"^/index.html$\",\r\n  \"service\": \"html5-apps-repo-rt\",\r\n  \"authenticationType\": \"xsuaa\",\r\n  \"cacheControl\":\"public,max-age=1000,must-revalidate\"\r\n}\r\n```\r\n\r\n* Route with `httpMethods` restrictions\r\n\r\nThe `httpMethods` option allows you to split the same path across different targets depending on the HTTP method. For example:\r\n\r\n```json\r\n{\r\n  \"source\": \"^/app1/(.*)$\",\r\n  \"target\": \"/before/$1/after\",\r\n  \"httpMethods\": [\"GET\", \"POST\"]\r\n}\r\n```\r\n\r\nThis route will be able to serve only GET and POST requests. Any other method (including extension ones) will get a 405 Method Not Allowed response. The same endpoint can be split across multiple *destinations* depending on the HTTP method of the requests:\r\n\r\n```json\r\n{\r\n  \"source\": \"^/app1/(.*)$\",\r\n  \"destination\" : \"dest-1\",\r\n  \"httpMethods\": [\"GET\"]\r\n},\r\n{\r\n  \"source\": \"^/app1/(.*)$\",\r\n  \"destination\" : \"dest-2\",\r\n  \"httpMethods\": [\"DELETE\", \"POST\", \"PUT\"]\r\n}\r\n```\r\n\r\nThe setup above will route GET requests to the target *dest-1*, DELETE, POST and PUT to *dest-2*, and any other method receives a 405. It is also possible to specify \"catchAll\" routes, namely those that do not specify `httpMethods` restrictions:\r\n\r\n```json\r\n{\r\n  \"source\": \"^/app1/(.*)$\",\r\n  \"destination\" : \"dest-1\",\r\n  \"httpMethods\": [\"GET\"]\r\n},\r\n{\r\n  \"source\": \"^/app1/(.*)$\",\r\n  \"destination\" : \"dest-2\"\r\n}\r\n```\r\n\r\nIn the setup above, GET requests will be routed to *dest-1*, and all the rest to *dest-2*.\r\n\r\nWhy using `httpMethods`? It is often useful to split the implementation of microservices across multiple, highly specialized applications. For example, a Java application written to serve high amounts of GET requests that return large payloads is implemented, sized, scaled and load-tested differently than applications that offer APIs to upload limited amounts of data. `httpMethods` allows you to split your REST APIs, e.g., */Things* to different applications depending on the HTTP methods of the requests, without having to make the difference visible in the URL of the endpoints.\r\n\r\nAnother usecase for `httpMethods` is to \"disable\" parts of the REST API. For example, it may be necessary to disable some endpoints that accept DELETE for external usage. By allowing only certain methods in the route, you can hide functionalities of your microservice that should not be consumable without having to modify the code or configurations of your service.\r\n\r\n**Note:** `localDir` and `httpMethods` are incompatible. The following route is invalid:\r\n\r\n```json\r\n{\r\n  \"source\": \"^/app1/(.*)$\",\r\n  \"target\": \"/before/$1/after\",\r\n  \"localDir\": \"resources\",\r\n  \"httpMethods\": [\"GET\", \"POST\"]\r\n}\r\n```\r\n\r\nHowever, since `localDir` supports only GET and HEAD requests, returning 405 to requests with any other method, any `localDir` route is \"implicitly\" restricted in terms of supported HTTP methods.\r\n\r\n* Route with a `scope`\r\n\r\nAn application specific scope has the following format:\r\n\r\n```\r\n<application-name>.<scope-name>\r\n```\r\n\r\nIt is possible to configure what scope the user needs to possess in order to access a specific resource. Those configurations are per [route](#routes).\r\n\r\nIn this example, the user should have **at least** one of the scopes in order to access the corresponding resource.\r\n\r\n```json\r\n{\r\n    \"source\": \"^/web-pages/(.*)$\",\r\n    \"target\": \"$1\",\r\n    \"scope\": [\"$XSAPPNAME.viewer\", \"$XSAPPNAME.reader\", \"$XSAPPNAME.writer\"]\r\n}\r\n```\r\n\r\nFor convenience if our route requires only one scope the `scope` property can be a string instead of an array. The following configuration is valid as well:\r\n\r\n```json\r\n{\r\n    \"source\": \"^/web-pages/(.*)$\",\r\n    \"target\": \"$1\",\r\n    \"scope\": \"$XSAPPNAME.viewer\"\r\n}\r\n```\r\n\r\nYou can configure scopes for the different HTTP methods (GET, POST, PUT, HEAD, DELETE, CONNECT, TRACE, PATCH and OPTIONS). If some of the HTTP methods are not explicitly set, the behaviour for them is defined by the `default` property. In case there is no `default` property specified and the HTTP method is also not specified, the request is rejected by default.\r\n\r\n```json\r\n{\r\n    \"source\": \"^/web-pages/(.*)$\",\r\n    \"target\": \"$1\",\r\n    \"scope\": {\r\n      \"GET\": \"$XSAPPNAME.viewer\",\r\n      \"POST\": [\"$XSAPPNAME.reader\", \"$XSAPPNAME.writer\"],\r\n      \"default\": \"$XSAPPNAME.guest\"\r\n    }\r\n}\r\n```\r\n\r\nThe application router supports the `$XSAPPNAME` placeholder. Its value is taken (and then substituted in the routes) from the UAA configuration.\r\nYou may read more about it [here](#uaa-configuration). </br>**Note:** The substitution is case sensitive.\r\n\r\nYou can use the name of the business application directly instead of using the `$XSAPPNAME` placeholder:\r\n\r\n```json\r\n{\r\n    \"source\": \"^/backend/(.*)$\",\r\n    \"scope\": \"my-business-application.viewer\"\r\n}\r\n```\r\n\r\n* Examples for Routes With `identityProvider`\r\n\r\nFor example, we can define several identity providers for different types of users. In this example, there are 2 categories: hospital patients and hospital personnel: \r\n1. patientsIDP â€“ use for authenticating patients.\r\n2. hospitalIDP â€“ use for authenticating all hospital personnel (doctors, nurses etc..).\r\n    \r\nWe can configure 2 routes with the following identityProvider properties:\r\n\r\n```json\r\n[\r\n    { \r\n\t\"source\": \"^/patients/sap/opu/odata/(.*)\",\r\n\t\"target\": \"/sap/opu/odata$1\",\r\n\t\"destination\": \"backend\",\r\n\t\"authenticationType\": \"xsuaa\",\r\n\t\"identityProvider\": \"patientsIDP\"\r\n    },\r\n    {\r\n        \"source\": \"^/hospital/sap/opu/odata/(.*)\",\r\n\t\"target\": \"/sap/opu/odata$1\",\r\n\t\"destination\": \"backend\", \"authenticationType\": \"xsuaa\",\r\n\t\"identityProvider\": \"hospitalIDP\"\r\n    }\r\n]\r\n```\r\nSo, a patient who tries to log into the system will be authenticated by patientIDP, and a doctor who tries to log in will be authenticated by hospitalIDP.\r\n\r\n**Note:** After logging in using one of the identity providers, to switch to the other one it is necessary to logout and perform a new log in.\r\n\r\n**Note:** Currently, dynamic provisioning of the subscriber account identity provider is not supported.\r\n\r\n**Note:** Identity provider configuration is only supported in the client side login redirect flow.\r\n\r\n\r\n## Replacements\r\n\r\nThis object configures the placeholder replacement in static text resources.\r\n\r\nProperty | Type | Description\r\n-------- | ---- | -----------\r\npathSuffixes | Array | An array containing the path suffixes that are relative to `localDir`. Only files with a path ending with any of these suffixes will be processed.\r\nvars | Array | A list with the environment variables that will be replaced in the files matching the suffix.\r\nservices | Object | An object describing bound services that will provide replacement values. Each property of this object is used to lookup a separate service. The property names are arbitrary. Service lookup format is described in _Service Query_ section in _@sap/xsenv_ documentation.\r\n\r\nThe supported tags for replacing environment variables are: `{{ENV_VAR}}` and `{{{ENV_VAR}}}`.\r\nIf there is such an environment variable it will be replaced, otherwise it will be just an empty string.\r\n\r\nFor services you can specify a property from the `credentials` section of the service binding which will be replaced.\r\nFor example `{{{my_service.property}}}` and `{{my_service.property}}`\r\n\r\nEvery variable that is replaced using two-brackets syntax will be HTML-escaped.\r\n\r\nFor example if the value of the environment variable is `ab\"cd` the result will be `ab&amp;quot;cd`.</br>\r\nThe triple brackets syntax is used when the replaced values don't need to be escaped and all values will be unchanged.\r\n\r\nFor example, if somewhere in your *xs-app.json* you have a route:\r\n\r\n```json\r\n{\r\n  \"source\": \"^/get/home(.*)\",\r\n  \"target\": \"$1\",\r\n  \"localDir\": \"resources\",\r\n  \"replace\": {\r\n    \"pathSuffixes\": [\"index.html\"],\r\n    \"vars\": [\"escaped_text\", \"NOT_ESCAPED\"],\r\n    \"services\": {\r\n      \"my-sapui5-service\": {\r\n        \"tag\": \"ui5\"\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nand you have the following `index.html`:\r\n\r\n```html\r\n<html>\r\n  <head>\r\n    <title>{{escaped_text}}</title>\r\n    <script src=\"{{{NOT_ESCAPED}}}/index.js\"/>\r\n    <script src=\"{{{my-sapui5-service.url}}}\"/>\r\n  </head>\r\n</html>\r\n```\r\nthen in `index.html`, `{{escaped_text}}` and `{{{NOT_ESCAPED}}}` will be replaced with the values of the environment variables `escaped_text` and `NOT_ESCAPED`.\r\n\r\nIf you have a service in VCAP_SERVICES like:\r\n\r\n```json\r\n{\r\n  \"sapui5_service\": [{\r\n    \"name\": \"sapui5\",\r\n    \"tags\": [\"ui5\"],\r\n    \"credentials\": {\r\n      \"url\": \"http://sapui5url\"\r\n    }\r\n  }]\r\n}\r\n```\r\nthen `{{{my-sapui5-service.url}}}` will be replaced with the `url` property from `sapui5` service - in this case `http://sapui5url`.\r\n\r\n**Note:** _All_ index.html files will be processed.\r\nIf you want to replace only specific files, you have to set the path of the file relative to `localDir`.\r\n\r\n**Note:** All files should be **UTF-8** encoded.\r\n\r\n**Note:** If a service is not found an error is thrown on startup.\r\n\r\n**Note:** If a service and an environment variable from `vars` have the same name, an error is thrown on startup.\r\n\r\nThe returned content type is based on the file extension. Currently the supported file extensions are:\r\n* .json - application/json\r\n* .txt - text/plain\r\n* .html - text/html\r\n* .js - application/javascript\r\n* .css - test/css\r\n\r\nIf the file extension is different, the default content type is `text/html`.\r\n\r\nExample for `pathSuffixes`:\r\n```json\r\n{\r\n  \"pathSuffixes\": [\".html\"]\r\n}\r\n```\r\nThe suffix `.html` means that all files with the extension *.html* under `localDir` and it's subfolders will be processed.\r\n```json\r\n{\r\n  \"pathSuffixes\": [\"/abc/main.html\", \"some.html\"]\r\n}\r\n```\r\nThe suffix `/abc/main.html` means that all files named *main.html* which are inside a folder named *abc* will be processed.\r\n\r\nThe suffix `some.html` means that all files which have a name that ends with *some.html* will be processed. For example: `some.html`, `awesome.html`.\r\n\r\n```json\r\n{\r\n  \"pathSuffixes\": [\"/some.html\"]\r\n}\r\n```\r\n\r\nThe suffix `/some.html` means that all files which have the **exact** name *some.html* will be processed. For example: `some.html`, `/abc/some.html`.\r\n\r\n**Note:** URL path parameters are not supported for replacements.\r\nFor example, replacements will not work if the path looks like '/test;color=red/index.html'. For more information regarding path parameters refer to [http://tools.ietf.org/html/rfc3986#section-3.3](http://tools.ietf.org/html/rfc3986#section-3.3).\r\n\r\n## *xs-app.json* configuration file\r\n\r\nThis is the main configuration file of the application router.\r\nIt contains a JSON object with the following properties:\r\n\r\nProperty | Type | Optional | Description\r\n-------- | ---- |:--------:| -----------\r\n[welcomeFile](#welcomefile-property) | String | x | The client is redirected to this page by default, if the request does not have a path. For more information, see [welcomeFile](#welcomefile-property).\r\n[authenticationMethod](#authenticationmethod-property) | String | x | If set to `none` the UAA login roundtrip is disabled. If the property is not set and authentication is defined per [route](#routes), the value is set to `route` by default.\r\nsessionTimeout | Number | x | Used to set session timeout. The default is 15 minutes. If the [SESSION_TIMEOUT](#session-timeout) environment variable is set this property will be overwritten.\r\n[routes](#routes-property) | Array | x | Contains all route configurations. The position of a configuration in this array is of significance for the application router in case a path matches more than one *source*. The first route whose *source* matches the path of the incoming request gets activated.\r\n[login](#login-property) | Object | x | Contains the configuration for the endpoint of the application router which will be used by the UAA during the OAuth2 authentication routine. By default this endpoint is `/login/callback`.\r\n[logout](#logout-property) | Object | x | Provides options for a [Central Logout](#central-logout) endpoint and a page to which the client to be redirected by the UAA after logout.\r\n[destinations](#destinations-property) | Object | x | Additional options for your destinations (besides the ones in the `destinations` environment variable).\r\n[services](#services-property) | Object | x | Additional options for your business services.\r\n[responseHeaders](#responseHeaders-property) | Array | x | Contains the optional response headers configuration.\r\n[compression](#compression-property) | Object | x | Configuration regarding compressing resources before responding to the client. If the [COMPRESSION](#compression-property) environment variable is set it will overwrite existing values.\r\n[pluginMetadataEndpoint](#pluginmetadataendpoint-property) | String | x | Adds an endpoint that will serve a JSON representing all configured plugins.\r\n[whitelistService](#whitelistservice-property) | Object | x | Options for the allowlist service preventing clickjack attacks.\r\n[websockets](#websockets-property) | Object | x | Options for the [web socket communication](#web-sockets).\r\n[errorPage](#errorpage-property) | Array | x | Optional configuration to set-up a custom error pages whenever the approuter encouters an error.\r\n[cors](#cors-property) | Array | x | Contains the configuration for cross-origin resource sharing.\r\n\r\n### *welcomeFile* property\r\n\r\nApprouter will redirect to this URL when `/`(root path) is requested.\r\nThis could be a file located inside the static resources folder or a resource hosted at a different location.\r\n\r\n**Note:** Approuter will serve the content of the resource instead of returning a redirect if the request contains a `x-csrf-token: fetch` header.\r\nSee [CSRF Protection](#csrf-protection).\r\n\r\n\r\nExample:\r\n```json\r\n\"welcomeFile\": \"/web-pages/hello-world.html\"\r\n```\r\n\r\n`web-pages` has to be a part of a local resource or an external destination\r\n```json\r\n{\r\n    \"source\": \"^/web-pages/(.*)$\",\r\n    \"localDir\": \"my-static-resources\"\r\n}\r\n```\r\nor\r\n```json\r\n{\r\n    \"source\": \"^/web-pages/(.*)$\",\r\n    \"target\": \"$1\",\r\n    \"destination\": \"mydest\"\r\n}\r\n```\r\n\r\n\r\nNote: If there isn't a route with a localDir property, the folloing default is added to the list of routes:\r\n\r\n```json\r\n{\r\n  \"source\": \"^/(.*)$\",\r\n  \"localDir\": \"resources\"\r\n}\r\n```\r\n\r\n\r\n### *authenticationMethod* property\r\n\r\nIt may have the following values:\r\n\r\n* `none` - disables authentication for all routes\r\n* `route` - authentication type is defined in the [route](#routes) configurations\r\n\r\nThe default value is `route`.\r\n\r\n### *routes* property\r\n\r\nIt holds an array of route configuration objects. The order of the configurations is important for the application router.\r\nThe first route whose `source` pattern gets matched with the path of the incoming request will be activated.\r\nSee [Routes](#routes) for more info.\r\n\r\n### *login* property\r\n\r\nA redirect to the application router at a specific endpoint takes place during OAuth2 authentication with UAA.\r\nThis endpoint can be configured in order to avoid possible collisions. For example:\r\n\r\n```json\r\n\"login\": {\r\n  \"callbackEndpoint\": \"/custom/login/callback\"\r\n}\r\n```\r\n\r\nThe default endpoint is `/login/callback`.\r\n\r\n### *logout* property\r\n\r\nIn this object you can define your business application's central logout endpoint through the `logoutEndpoint` property.\r\nThe value of logout property should be an object with the following properties:\r\n\r\nProperty | Type | Optional | Description\r\n-------- | ---- |:--------:| -----------\r\nlogoutPath | String |  | The path to be used when logging out from application router.\r\nlogoutPage | String | x | The logout page url path.\r\nlogoutMethod | String | x | Could be POST or GET. The default value is GET.\r\ncsrfProtection | Boolean | x | Can only be defined if logoutMethod is POST. If logoutMethod is POST and this property is not defined, default is true. It can be set to false â€“ for example if csrfProtection is implemented in backend application.\r\n\r\nFor example, if somewhere in your *xs-app.json* you have:\r\n\r\n```json\r\n\"logout\": {\r\n  \"logoutEndpoint\": \"/my/logout\"\r\n}\r\n```\r\n\r\nThis will open an endpoint on application router which, when requested, will trigger the [central logout](#central-logout) routine.\r\nChanging the browser location from the client-side JavaScript code:\r\n\r\n```javascript\r\nwindow.location.replace('/my/logout');\r\n```\r\n\r\nwill trigger client initiated central Logout.\r\n\r\nIn addition, a page to which the user will be redirected by the UAA after logout can be configured using the `logoutPage` property.\r\nIt may hold:\r\n\r\n- URL path - the UAA will redirect the user back to the application router and the path will be interpreted according the configured [routes](#routes).\r\n\r\nThe `logoutEndpoint` can be called with query parameters. For example:\r\n```javascript\r\nwindow.location.replace('/my/logout?siteId=3');\r\n```\r\nThese parameters will be appended as is to the redirect url set by the `logoutPage` property.\r\nFor example, if the logout section is the following:\r\n```\r\n\"logout\": {\r\n    \"logoutEndpoint\": \"/logout\",\r\n    \"logoutPage\": \"/logoff.html\"\r\n  },\r\n```\r\nThe redirect url will end with:\r\n```\r\n/logoff.html?siteId=3\r\n```\r\n\r\n**Note**: The resource that matches the path should not require authentication. The property `authenticationType` should be set to `none` for that particular route.\r\n\r\nExample:\r\n\r\n```json\r\n{\r\n  \"authenticationMethod\": \"route\",\r\n  \"logout\": {\r\n    \"logoutEndpoint\": \"/my/logout\",\r\n    \"logoutPage\": \"/logout-page.html\"\r\n  },\r\n  \"routes\": [\r\n    {\r\n      \"source\": \"^/logout-page.html$\",\r\n      \"localDir\": \"my-static-resources\",\r\n      \"authenticationType\": \"none\"\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\nIn this case *my-static-resources* (contains *logout-page.html*) is a folder with static resources in the working directory of the application router.\r\n\r\n**Note**: Be sure that your main route in your xs-app.json resource that matches the path is not cached by browser. Therefore, the best practice here would be to model cacheControl accordingly:\r\n\r\n```json\r\n{\r\n  \"routes\": [\r\n    {\r\n      \"source\": \"^/ui/index.html\",\r\n      \"target\": \"index.html\",\r\n      \"localDir\": \"web\",\r\n      \"cacheControl\": \"no-cache, no-store, must-revalidate\"\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n- Absolute http(s) URL - the UAA will redirect the user to a page (or application) different from the application router. \r\nFor example:\r\n\r\n```json\r\n\"logout\": {\r\n  \"logoutEndpoint\": \"/my/logout\",\r\n  \"logoutPage\": \"http://employees.portal\"\r\n}\r\n```\r\n\r\n**Note**: UAA will execute redirect only in case redirect URL is a valid redirect-uri in xs-security.json - redirect-uris are maintained as part of the oauth2-configuration section in the UAA application security descriptor JSON file given at the creation of the service instance. For example:\r\n\r\nUAA application security descriptor:\r\n```\r\n\"oauth2-configuration\": {    \r\n    \"redirect-uris\":\r\n    [\r\n     \"http://employees.portal\"\r\n    ]    \r\n}\r\n```\r\n\r\nUsing POST method for Logout\r\n\r\nFor security reasons it is recommended to model the logout flow using \"POST\" method and enable CSRF protection. \r\n\r\nIn that case, logoutMethod and csrfProtection parameters should be added in logout property:\r\n```json\r\n  \"logout\": {\r\n    \"logoutEndpoint\": \"/my/logout\",\r\n    \"logoutPage\": \"/logout-page.html\",\r\n    \"logoutMethod\": \"POST\",\r\n    \"csrfProtection\": true\r\n}\r\n```\r\n**Note**: For backward compatibility reasons logoutMethod default value is GET. \r\nThe csrfProtection property can only be set if logoutMethod is POST. \r\nIf logoutMethod is POST and csrfProtection property is not set, csrfProtection will be enabled by default.\r\n\r\nConsumption example:\r\nThe POST request should be an AJAX request and include CSRF token.\r\n```\r\nasync function getToken() {\r\n  return new Promise((resolve) => {\r\n  jQuery.ajax({\r\n    type: \"GET\",\r\n    url: 'my/logout',\r\n    headers: {\r\n      \"X-CSRF-Token\": 'fetch',\r\n      contentType: \"application/json\",\r\n    },\r\n    success: function(data, textStatus, request){\r\n      resolve(request.getResponseHeader('X-CSRF-Token'));\r\n    },\r\n   });\r\n });\r\n};\r\n```\r\nPOST request example:\r\n```\r\nconst token = await getToken();\r\njQuery.ajax({\r\n  type: \"POST\",\r\n  url: \"my/logout\",\r\n  headers: {\r\n    \"X-CSRF-Token\": token,\r\n    contentType: \"application/json\",\r\n  },\r\n  success: function (data) {\r\n    window.location.href = data;\r\n  }\r\n});\r\n```\r\n**Note**:  Make sure that url field matches logoutEndpoint.\r\n\r\n### *destinations* property\r\n\r\nLet's say you have a destination called `node-backend`. You can specify options for it by adding the `destinations` property in your xs-app.json:\r\n```json\r\n\"destinations\": {\r\n  \"node-backend\": {}\r\n}\r\n```\r\nThe value of `node-backend` should be an object with the following properties:\r\n\r\nProperty | Type | Optional | Description\r\n-------- | ---- |:--------:| -----------\r\nlogoutPath | String | x | The logout endpoint for your destination.\r\nlogoutMethod | String | x | Could be POST, PUT, GET. The default value is POST.\r\n\r\nThe `logoutPath` will be called when [Central Logout](#central-logout) is triggered or a session is deleted due to timeout.\r\nThe request to the `logoutPath` will contain additional headers, including the JWT token.\r\nThe `logoutMethod` property specifies the HTTP method with which the `logoutPath` will be requested. For example:\r\n```json\r\n{\r\n  \"destinations\": {\r\n    \"node-backend\": {\r\n      \"logoutPath\": \"/ui5logout\",\r\n      \"logoutMethod\": \"GET\"\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n### *services* property\r\n\r\nLet's say you have a service called `com.sap.appbasic.country`. You can specify options for it by adding the `services` property in your xs-app.json:\r\n```json\r\n\"services\": {\r\n  \"com.sap.appbasic.country\": {}\r\n}\r\n```\r\nThe value of `com.sap.appbasic.country` should be an object with the following properties:\r\n\r\nProperty | Type | Optional | Description\r\n-------- | ---- |:--------:| -----------\r\nendpoint | String | x | The name of the attribute in the VCAP_SERVICES that contains the URL of the service.  \r\nlogoutPath | String | x | The path to be used when logging out from the service.\r\nlogoutMethod | String | x | Could be POST, PUT, GET. The default value is POST.\r\n\r\nThe `logoutPath` will be called when [Central Logout](#central-logout) is triggered or a session is deleted due to timeout.\r\nThe request to the `logoutPath` will contain additional headers, including the JWT token in header `authorization` and approuter host in header `x-approuter-host`.\r\nThe `logoutMethod` property specifies the HTTP method with which the `logoutPath` will be requested. For example:\r\n```json\r\n{\r\n  \"services\": {\r\n    \"com.sap.appbasic.country\": {\r\n      \"endpoint\": \"countryservice\",\r\n      \"logoutPath\": \"/countrieslogout\",\r\n      \"logoutMethod\": \"GET\"\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n### *responseHeaders* property\r\n\r\nWith the custom response header property, you can add headers, which the application router returns to the client in its responses.<br> \r\nThe property is an array of objects, each object having the following properties:\r\n\r\nProperty | Type         | Optional | Description\r\n-------- | ------------ |:--------:| -----------\r\nname     | String       |          | response header name\r\nvalue    | String       |          | response header value\r\n\r\n\r\nExample:\r\n```json\r\n{ \"responseHeaders\" : [\r\n    {\"name\": \"header1\", \"value\": \"value1\"},\r\n    {\"name\": \"header2\", \"value\": \"value2\"}\r\n  ]\r\n}\r\n```\r\n\r\n### *compression* property\r\nBy default text resources are compressed before being sent to the client.\r\nThe default threshold for using compression is 1K. Text resources under this size will not be compressed.\r\nIf you need to change the compression size threshold, you can add the optional property `minSize`.\r\n\r\nHere is an example of a compression section (2048 bytes):\r\n```json\r\n{\r\n  \"compression\": {\r\n      \"minSize\": 2048\r\n  }\r\n}\r\n```\r\n\r\nProperty | Type | Optional | Description\r\n-------- | ---- |:--------:| -----------\r\nminSize | Number | x | Text resources larger than this size will be compressed.\r\nenabled | Boolean | x | Globally disables or enables compression. Default value is true.\r\ncompressResponseMixedTypeContent | Boolean | x | Determines whether response content of multipart/mixed content type should be compressed. The default value is false.\r\n\r\n**Note:** There are 3 ways to disable compression:\r\n* Global - within the compression section add ```\"enabled\": false```\r\n* Front-End - the client sends a header Accept-Encoding which omits gzip\r\n* Backend  - the application sends a header Cache-Control with the 'no-transform' directive\r\n\r\nExample of globally disabling compression using the environment variable `COMPRESSION`:\r\n```json\r\n{\r\n  \"enabled\": false\r\n}\r\n```\r\n\r\n**Note:** The header field `Content-Length` is used to determine the resource size.\r\nIf `Content-Length` is missing, the chunk size is used to determine whether to compress the resource.\r\nFor more information, see the npm module compression.\r\n\r\nHere is a complete example of the compression environment variable:\r\n```json\r\n  env:\r\n   COMPRESSION: >\r\n        { \r\n\t  \"enabled\": true,\r\n\t  \"minSize\": 2048,\r\n\t  \"compressResponseMixedTypeContent\": true\r\n\t  }\r\n```\r\n\r\n### *pluginMetadataEndpoint* property\r\n\r\nExample:\r\n```json\r\n{\r\n  \"pluginMetadataEndpoint\": \"/metadata\"\r\n}\r\n```\r\n\r\n**Note**: If you request relative path `/metadata` of your application, you will receive a JSON with configured plugins.\r\n\r\n### *whitelistService* property\r\n\r\nThe *whitelistService* property is used for enabling the allowlist service that prevents clickjack attacks.\r\nAn endpoint accepting GET requests will be opened at the relative path configured in the `endpoint` property.\r\nFor more details see [Allowlist service](#whitelist-service) section.\r\n\r\nExample:\r\n```json\r\n{\r\n  \"whitelistService\": {\r\n    \"endpoint\": \"/whitelist/service\"\r\n  }\r\n}\r\n```\r\n\r\n### *websockets* property\r\n\r\nFor more details about the web socket communication see [Web sockets](#web-sockets) section.\r\n\r\nExample:\r\n```json\r\n{\r\n  \"websockets\": {\r\n    \"enabled\": true\r\n  }\r\n}\r\n```\r\n\r\nTo use Websockets when approuter is integrated with HTML5 Application Repository, this property should be added to the xs-app.json of the deployed HTML5 application. When an incoming request for an application in the repository goes through approuter, approuter retrieves the application's configuration from the repository. If this flag is set, approuter creates a websockets connection with the backend (the target url of the request) and acts as a proxy which delivers messages on top of ws protocol from the backend to the user and vice versa.\r\n\r\n### *errorPage* property\r\n\r\nBy default, errors originating in the application router are shown the [status code](https://nodejs.org/api/http.html#http_http_status_codes) of the error.\r\nIt is also possible to display a custom error page using the `errorPage` property.\r\n\r\nThe property is an array of objects, each object having the following properties:\r\n\r\nProperty | Type         | Optional | Description\r\n-------- | ------------ |:--------:| -----------\r\nstatus   | Number/Array |          | HTTP status code\r\nfile     | String       |          | File path relative to the working directory of the application router\r\n\r\n\r\nExample:\r\n```json\r\n{ \"errorPage\" : [\r\n    {\"status\": [400,401,402], \"file\": \"./custom-err-40x.html\"},\r\n    {\"status\": 501, \"file\": \"./http_resources/custom-err-501.html\"}\r\n  ]\r\n}\r\n```\r\nIn the example above 400, 401 and 402 errors would be shown the content of  `./custom-err-4xx.html` and for 501 errors the user would see `./http_resources/custom-err-501.html`.\r\n\r\n**Note:** The errorPage conifiguration section has no effect on errors generated outside of the application router.\r\n\r\n### *cors* property\r\n\r\nWith the cors property, you can support cross-origin requests.<br> \r\nIf a cross-origin resource sharing (CORS) configuration exists in both the environment variables and the application router configuration file (xs-app.json), the application router gives priority to the CORS configuration in the application router configuration file.<br> \r\nFor more information about the CORS configuration see [Cross-Origin Resource Sharing configuration](#cross-origin-resource-sharing-configuration).\r\n\r\n### Complete example of an *xs-app.json* configuration file \r\n#### Without HTML5 Application Repository integration:\r\n```json\r\n{\r\n  \"welcomeFile\": \"index.html\",\r\n  \"authenticationMethod\": \"route\",\r\n  \"sessionTimeout\": 10,\r\n  \"pluginMetadataEndpoint\": \"/metadata\",\r\n  \"routes\": [\r\n    {\r\n      \"source\": \"^/sap/ui5/1(.*)$\",\r\n      \"target\": \"$1\",\r\n      \"destination\": \"ui5\",\r\n      \"csrfProtection\": false\r\n    },\r\n    {\r\n      \"source\": \"/employeeData/(.*)\",\r\n      \"target\": \"/services/employeeService/$1\",\r\n      \"destination\": \"employeeServices\",\r\n      \"authenticationType\": \"xsuaa\",\r\n      \"scope\": [\"$XSAPPNAME.viewer\", \"$XSAPPNAME.writer\"],\r\n      \"csrfProtection\": true\r\n    },\r\n    {\r\n      \"source\": \"^/(.*)$\",\r\n      \"target\": \"/web/$1\",\r\n      \"localDir\": \"static-content\",\r\n      \"replace\": {\r\n        \"pathSuffixes\": [\"/abc/index.html\"],\r\n        \"vars\": [\"NAME\"]\r\n      }\r\n    }\r\n  ],\r\n  \"login\": {\r\n    \"callbackEndpoint\": \"/custom/login/callback\"\r\n  },\r\n  \"logout\": {\r\n    \"logoutEndpoint\": \"/my/logout\",\r\n    \"logoutPage\": \"/logout-page.html\"\r\n  },\r\n  \"destinations\": {\r\n    \"employeeServices\": {\r\n      \"logoutPath\": \"/services/employeeService/logout\",\r\n      \"logoutMethod\": \"GET\"\r\n    }\r\n  },\r\n  \"compression\": {\r\n    \"minSize\": 2048\r\n  },\r\n  \"whitelistService\": {\r\n    \"endpoint\": \"/whitelist/service\"\r\n  },\r\n  \"websockets\": {\r\n    \"enabled\": true\r\n  },\r\n  \"errorPage\": [\r\n    {\"status\": [400,401,402], \"file\": \"/custom-err-4xx.html\"},\r\n    {\"status\": 501, \"file\": \"/custom-err-501.html\"}\r\n  ]\r\n}\r\n```\r\n#### With HTML5 Application Repository integration (xs-app.json file stored in HTML5 Application Repository):\r\n```json\r\n{\r\n  \"welcomeFile\": \"index.html\",\r\n  \"authenticationMethod\": \"route\",\r\n  \"routes\": [\r\n    {\r\n      \"source\": \"/employeeData/(.*)\",\r\n      \"target\": \"/services/employeeService/$1\",\r\n      \"destination\": \"employeeServices\",\r\n      \"authenticationType\": \"xsuaa\",\r\n      \"scope\": [\"$XSAPPNAME.viewer\", \"$XSAPPNAME.writer\"],\r\n      \"csrfProtection\": true\r\n    },\r\n    {\r\n       \"source\": \"^/odata/v2/(.*)$\",\r\n       \"target\": \"$1\",\r\n       \"service\": \"com.sap.appbasic.country\",\r\n       \"endpoint\": \"countryservice\"\r\n    },\r\n    {\r\n      \"source\": \"^(/.*)$\",\r\n      \"target\": \"$1\",\r\n      \"service\": \"html5-apps-repo-rt\",\r\n      \"authenticationType\": \"xsuaa\"\r\n    }\r\n  ],\r\n  \"logout\": {\r\n    \"logoutEndpoint\": \"/my/logout\",\r\n    \"logoutPage\": \"/logout-page.html\"\r\n  },\r\n  \"destinations\": {\r\n    \"employeeServices\": {\r\n      \"logoutPath\": \"/services/employeeService/logout\",\r\n      \"logoutMethod\": \"GET\"\r\n    }\r\n  },\r\n  \"services\": {\r\n    \"com.sap.appbasic.country\": {\r\n      \"logoutPath\": \"/countryService/logout\",\r\n      \"endpoint\": \"countryservice\",\r\n      \"logoutMethod\": \"GET\"\r\n    }\r\n  }\r\n}\r\n```\r\n**Note:** The route in bold is the route that provides access to the HTML5 Application Repository service.\r\n\r\n## Headers\r\n\r\n### Forwarding Headers\r\n\r\nThe application router passes the following x-forwarding-* headers to the route targets:\r\n\r\nHeader Name | Description\r\n----------- | -----------\r\nx-forwarded-host | Contains the *Host* header which was sent by the client to the application router.\r\nx-forwarded-proto | Contains the protocol which was used by the client to connect to the application router.\r\nx-forwarded-for | Contains the address of the client which connects to the application router.\r\nx-forwarded-path | Contains the original path which was requested by the client.\r\n\r\nIf a client performs a path rewriting, it sends the x-forwarded-proto, x-forwarded-host, and the x-forwarded-path headers to the application router. The values of these headers are forwarded to the route targets without modifications instead of being generated from the application router request URL. The x-forwarded-path header of a request does not impact the source pattern of routes in the xs-app.json.\r\n\r\n### Hop-by-hop Headers\r\n\r\nHop-by-hop headers are meaningful only for a single transport-level connection and therefore are not forwarded by the application router.\r\nThese headers are:\r\n* Connection\r\n* Keep-Alive\r\n* Public\r\n* Proxy-Authenticate\r\n* Transfer-Encoding\r\n* Upgrade\r\n\r\n### Custom Headers\r\n\r\n* x-custom-host: Contains the internal reverse proxy host. Relevant only if the application router is used behind an internal reverse proxy as well as an external reverse proxy (EXTERNAL_REVERSE_PROXY  environment variable is set to true). Add this header to the request to internal reverse proxy.\r\n\r\nIn a multi-tenancy landscape, the application router will calculate the tenant id based on the value of a certain request header as follows:\r\n - x-custom-host header or host if EXTERNAL_REVERSE_PROXY is true\r\n - x-forwarded-host header or host if EXTERNAL_REVERSE_PROXY is false or not specified\r\n\r\n### Authorization Header\r\n* x-approuter-authorization: Contains the JSON Web Token (JWT) or Open ID Connect (OIDC) access token to support the [Service to Application Router](#service-to-application-router-beta-version) scenario.\r\n\r\n## CSRF Protection\r\n\r\nBy default the application router enables CSRF protection for any HTTP method that is not `HEAD` or `GET` and the route is not public.\r\nA path is considered _public_, if it does not require authentication. This is the case for routes with `authenticationType: none` or if authentication is disabled completely via the top level property `authenticationMethod: none`.\r\n\r\nTo obtain a CSRF token one must send a `GET` or `HEAD` request with a `x-csrf-token: fetch` header to the application router.\r\nThe application router will return the created token in a `x-csrf-token: <token>` header, where `<token>` will be the value of the CSRF token.\r\n\r\nIf a CSRF protected route is requested with any of the above mentioned methods,\r\n`x-csrf-token: <token>` header should be present in the request with the previously obtained token.\r\nThis request must use the same session as the fetch token request.\r\nIf the `x-csrf-token` header is not present or invalid, the application router will return status code *403 Forbidden* and a response header `x-csrf-token: Required`.\r\n\r\n## Support of SAP Statistics\r\n\r\nThe application router provides performance statistics in an HTTP response header in the following cases:\r\n- The HTTP request contains an HTTP query parameter (URL parameter) sap-statistics=true.\r\n- The HTTP request contains an HTTP header field sap-statistics:true.\r\n\r\nIf an HTTP request that contains a header field or query parameter with \"sap-statistics=true\" reaches the application router, the application router forwards an \"sap-statistics\" header to the corresponding backend.\r\nIf SAP statistics is implemented for the backend, the backend returns to the application router a response header containing the statistics information from the backend.\r\n\r\nThe application router returns the following statistics information in an sap-statistics-approuter response header:\r\n- total: The time that has passed between the moment when the request entered into the application router and the moment when the application router started writing the response\r\n- ext (in case of destination forwarding): The time spent in the backend\r\n\r\nEach backend sub-component can add its own response header with the duration measurements when it receives the HTTP header sap-statistics:true.\r\n\r\n## Connectivity\r\n\r\nThe application router supports integration with SAP Cloud Platform connectivity service. The connectivity service handles proxy access to SAP Cloud Platform cloud connector, which tunnels connections to private network systems. In order to use connectivity, a connectivity service instance should be created and bound to the Approuter application. In addition, the relevant destination configurations should have `proxyType=OnPremise`. Also, a valid XSUAA login token should be obtained via the login flow.\r\n\r\n## SaaS Application Registration in Cloud Foundry\r\n\r\nThe application router supports SaaS registration. A SaaS business application based on application router may be registered in the SaaS registry  by creating and binding a SaaS Registry service instance.\r\nAfter fulfilling the CIS process to enable application subscription, the SaaS business application will be visible in the SAP Cloud Platform cockpit in the Cloud Foundry environment for all entitled customers. \r\nOnce a customer is entitled to the SaaS business application, the subaccounts (tenants) created under the global account will be able to view, subscribe to, and unsubscribe from the application. \r\nWhen a tenant is subscribed/unsubscribed to/from an application, the tenant will be subscribed/unsubscribed: \r\n* In the XSUAA instance of the application itself \r\n* In the reuse services (e.g.: destination ), if the application is dependent on the reuse service. \r\nAlso, onboarding and offboarding callbacks will be triggered for the subscribed/unsubscribed application and for the reuse services.\r\n\r\nIf you use IAS by binding a multi-tenant application router to an identity service instance, the subscription manager service (SMS) should be used to enable the subscription to a subscriber zone and an IAS tenant.\r\n\r\n\r\n### How To Expose Approuter for SaaS Subscription\r\n\r\n#### Multi-tenancy\r\nThe application router should be configured to handle multi-tenant access by maintaining the TENANT_HOST_PATTERN environment configuration.\r\n\r\n#### Entitle org for SaaS Application consumption\r\nThe SaaS Registry service and / or the Subscription Manager service should be available in your space marketplace.\r\n\r\n#### Authorize LPS for invoking callbacks\r\nSaaS business applications should grant LPS the authorization to invoke the application's callbacks. Callback scope should be granted to LPS in the application routerâ€™s xs-security.json file:\r\n\r\n*xs-security.json:*\r\n```\r\n...\r\n {  \r\n    \"name\":\"$XSAPPNAME.Callback\",\r\n    \"description\":\"With this scope set, the callbacks for tenant onboarding, \r\n     offboarding and getDependencies can be called.\",\r\n         \"grant-as-authority-to-apps\":[  \r\n            \"$XSAPPNAME(application,sap-provisioning,tenant-onboarding)\"\r\n         ]\r\n  }\r\n...  \r\n```\r\n\r\n## Authentication with Identity Service (IAS)\r\nTo use IAS authentication an identity service instance of plan application should be created with the following configuration:\r\n```\r\n{\r\n   \"oauth2-configuration\": {\r\n     \"redirect-uris\": [\"https://*.<landscapeDomain>/login/callback?authType=ias\"],  //Enable redirect after login\r\n     \"post-logout-redirect-uris\": [\"https://*.<landscapeDomain>/*/logout.html\" ]    //Enable redirect after logout\r\n   },\r\n   \"xsuaa-cross-consumption\":true, //Enable xsuaa trust\r\n   \"multi-tenant\":true //enable multitenancy\r\n}\r\n```\r\nAuthentication with IAS should be performed using X.509 certificates. To achieve this the identity service should be bound to approuter using the following configuration:\r\n```\r\n{\r\n  \"credential-type\": \"X509_GENERATED\"\r\n }\r\n```\r\n\r\n#### Register an application in SaaS Registry (SaaS Registry Configuration)\r\nFor a customer to be able to subscribe to an application through the SAP Cloud Platform cockpit, each SaaS business application should register itself on all CF landscapes where it is deployed.\r\n\r\nTo register a SaaS application in LPS, a service instance of saas-registry should be created and the SaaS business application should be bound to it.\r\nThe instance of saas-registry is created with a configuration json - *saas-config.json:*.\r\nIn the configuration.json file a url for the getDependencies and onSubscription callbacks must be provided. \r\nNote that the path segment of these urls are configurable however the tenantId url variable in onSubscription callback must be provided anyway.\r\n\r\n```\r\n{\r\n\t\"appId\" : \"<appId>\",  # xsappname generated by XSUAA - can be obtained by checking the xsuaa-> xsappname by executing: cf env <application name>\r\n\t\"appName\" : \"<appName>\",  # Business application name to be shown to subscribers \r\n\t\"appUrls\": { \r\n\t\t\"getDependencies\" : \"<approuter-host>/callback/v1.0/dependencies\",\r\n\t    \"onSubscription\" : \"<approuter-host>/callback/v1.0/tenants/{tenantId}\" \r\n\t},\r\n\t\"providerTenantId\" : \"<tenant>\"  # Approuter provider account tenant ID.\r\n}   \r\n\r\n```\r\n\r\n#### Register an application in Subscription Manager  (Subscription Manager Configuration)\r\nTo register an SaaS application in the subscription manager service, a service instance of the subscription manager has to be created and the SaaS business application has to be bound to it. \r\nThe instance of subscription manager is created with a configuration json file - sms-config.json:. In the configuration.json file, a url for the getDependencies callbacks and the onSubscription callbacks must be provided. \r\nNote that the path segments of these urls are configurable.\r\n\r\n```\r\n{\r\n  \"iasServiceInstanceName\" : [\"ias-provider-ias\"], #Name of the related IAS instance\r\n  \"applicationType\": \"application\",\r\n  \"xsuaaSaasApplicationServiceInstanceId\": \"88afb2a5-5ab3-409a-9c0c-b70e2b86b1cf\", #SaaS Registry service instance id\r\n  \"appCallbacks\" : {\r\n    \"dependenciesCallbacks\" : {\r\n      \"url\" : \"https://<providerZoneId>--<providerIASTenantId>.<approuterHost>.cert.<landscapeDomain>/v1.0/callback/zones/{zoneId}/dependencies\"\r\n    },\r\n    \"subscriptionCallbacks\" : {\r\n      \"url\" : \"https://<providerZoneId>--<providerIASTenantId>.<approuterHost>.cert.<landscapeDomain>/v1.0/callback/zones/{zoneId}\"\r\n    }\r\n  }\r\n}\r\n```\r\nNote that in order to provide certificates the url domain should contain a \"cert\" segment.\r\nIn addition the TENANT_HOST_PATTERN environment variable should be modified to support requests with the \"cert\" segment. \r\nFor example:\r\n```\r\n^(.*).<approuterHost>.(cert.)?<landscapeDomain>\r\n```\r\n\r\n## Mutual TLS Authentication (mTLS) and Certificates Handling\r\nApplication router supports certificates usage for token creation and mTLS handshake in backend connections. To enable that the XSUAA or IAS instance bound to the application router should provide in its credentials a certificates chain and a private key\r\n\r\nNote that application router also supports providing private key via environment variables: XSUAA_PRIVATE_KEY (XSUAA) and IAS_PRIVATE_KEY (IAS).\r\n\r\nIn case certificates and private key exists, application router fetches XSUAA/IAS tokens providing certificates chain and private key.\r\nWhen forwarding request to business services, application router also uses certificates to create a client_credentials token or exchange the login token.\r\n\r\nIf certificates available, HTTP connection to backend is created using private key and a concatenation of intermediate and client certificates, enabling mTLS handshake.\r\n\r\nCloud Foundry: client certificate is propagated via the x-forwarded-client-cert header. In order to enable that the backend url should contain a .cert segment in its domain.\r\n\r\n## Integration with HTML5 Application Repository\r\n\r\nThe application router supports seamless integration with the HTML5 Application Repository service. \r\nWhen the application router interacts with HTML5 Application Repository to serve HTML5 Applications, all static content and routes (xs-app.json) are retrieved from HTML5 Application Repository. \r\nIn case application router needs to route to non HTML5 Applications, it is possible to model that in the xs-app.json of the application router.\r\n\r\nTo integrate HTML5 Application Repository to an application router based it is required to create an instance of html5-apps-repo service of plan app-runtime and bind it to the application.\r\nxs-app.json routes that are used to retrieve static content from HTML5 Application Repository may be modeled in the following format:\r\n\r\n```\r\n { \r\n     \"source\": \"^(/.*)\",                                    \r\n     \"target\": \"$1\",                                        \r\n     \"service\": \"html5-apps-repo-rt\", \r\n     \"authenticationType\": \"xsuaa\"                      \r\n }\r\n```\r\n### HTML5 Application Repository Multitenancy\r\nThe HTML5 Application Repository is a multitenant service. Non-public HTML5 Applications are visible only to the application providers (with provider subaccounts) and the consumers subscribed to the applications (with consumer subaccounts).\r\n\r\nWhen a multitenant application router is subscribed to a subaccount, the HTML5 Application Repository app-runtime instance that is bound to the application router is returned as a dependency, which triggers the subscription to the app-runtime instance.\r\nYou can also bind HTML5 Application Repository app-host service instances to the application router to enable the subscription of the corresponding HTML5 applications.\r\nDuring runtime, the application router creates an HTML5 Application Repository app-runtime client_credentials token using the tenant URL that the application router determines from the TENANT_HOST_PATTERN environment variable.\r\n\r\nNote:  The creation of the token can fail if the app-runtime instance is not subscribed to the subaccount, which happens if, for example, the application router was subscribed to the subaccount before the HTML5 Application Repository became a multitenant service.\r\nIn this case the application router will create the token using the provider subaccount.\r\n\r\nYou can trigger the subscription to the HTML5 Application Repository app-runtime instance by using the SAAS Provisioning API: see https://api.sap.com/api/APISaasManagerService/resource\r\n```\r\nPATCH /saas-manager/v1/application/tenants/{tenantId}/subscriptions\r\n```\r\n\r\nNote:  If you have an old application router version, the HTML5 Application Repository app-runtime client_credentials token is created by using HTML5 application provider subaccount.\r\n\r\n### Blocked HTML5 Application Names\r\n\r\nThe following strings are used as predefined direct routing URIs, which lead the request to the routing configuration file of the application router: \"favicon.ico\", \"login\".\r\nTherefore, do not name your HTML5 applications \"favicon.ico\" or \"login\"!\r\n\r\n### Known Gaps in Integration with HTML5 Application Repository\r\n\r\nThe following limitations apply when application router is bound to HTML5 Application Repository service:\r\n\r\n1. It is not possible to implement the \"first\" middleware slot to provide routes dynamically.\r\n2. No option apart from workingDir can be provided in application router start.\r\n3. External session management via extensibility is not supported\r\n\r\n\r\n**Note:** Mixed scenario of modeling part of the static content in local resources folder and also retrieving static content from HTML5 Application Repository is not supported.</br>\r\n**Note:** This feature is only supported in Cloud Foundry. There is no HTML5 Application Repository service in XSA.\r\n\r\n### Runtime Processing\r\n\r\nDuring runtime, based on request url path (see URL Format), application router will try to fetch the xs-app.json file from the corresponding HTML5 Application in HTML5 Application Repository and use it for routing the request.\r\nThe following algorithm is applied for request processing:\r\n* If no HTML5 Application is found in HTML5 Application Repository for current request, central application router xs-app.json will be used for routing\r\n* If HTML5 Application exists in HTML5 Application Repository but no xs-app.json file is returned, an error message will be issued and request processing will be stopped.\r\n\r\n#### URL Format\r\n\r\nA valid request to application router that uses HTML5 Application Repository must have the following format:\r\n```\r\nhttps://<tenantId>.<appRouterHost>.<domain>/<bsPrefix>.<appName-appVersion>/<resourcePath>\r\n\r\n```\r\nbsPrefix (business service prefix) - Optional\r\n* It should be used in case the application is provided by a business service bound to this approuter\r\n\r\nappName (application name) - Mandatory\r\n* Used to uniquely identify the application in HTML5 Application Repository persistence\r\n* Must not contain dots or special characters\r\n\r\nappVersion (application version) - Optional\r\n* Used to uniquely identify a specific application version in HTML5 Application Repository persistence\r\n* If no version provided, default application version will be used\r\n\r\nresourcePath (path to file)\r\n* The path to the file as it was stored in HTML5 Application Repository persistence\r\n\r\nQuery Parameters:\r\n\r\nskipXSAppJsonCache - Optional\r\n* Value: true\r\n* Supports skipping the usage of cache when getting the xsApp configuration, bringing it remotely and re-setting the cache.\r\n* Note that the query parameter is removed from request url before route processing.\r\n\r\n### Cache Buster Handling\r\nA cache buster allows the application router to notify the browser to refresh the resources only when the application resources have been changed. Otherwise the resources are always fetched from the browser's cache.\r\nThis flow applies to requests that should be forwarded to HTML5 Application Repository. If requests are forwarded to backend applications that return data, cache buster handling is not applied.\r\n\r\n* When the second path segment of the request url contains the pattern â€œ~timestamp~â€, this segment is removed from the subsequent request to HTML5 Application Repository\r\n* In case the request had a cache buster segment, application router adds to corresponding response the header: Cache-Control: public, max-age=31536000\r\n\r\n**Note:** Cache buster flow is only supported in HTML5 Application Repository integration flow.\r\n\r\n### Integration with Business Services\r\n\r\nApplication router supports integration with Business Services. \r\nBusiness Services are a flavour of reuse-services that expose specific information in VCAP_SERVICES credentials block that enable application router to serve Business Service UI and/or data.\r\n* Business Service UI must be stored in HTML5 Application Repository to be accessible from application router\r\n* Business Service UI must be defined as \"public\" to be accessible from an application router in a different space than the one from where the UI was uploaded \r\n* Business Service data can be served using two grant types:\r\n  1. User Token Grant: Application router performs a token exchange between login JWT token and Business Service token and uses it to trigger a request to the Business Service endpoint\r\n  2. Client Credentials Grant: Application router generates a client_credentials token and uses it to trigger a request to the Business Service endpoint\r\n\r\n#### Business Service Credentials\r\nWhile binding a Business Service instance to application router the following information should be provided in VCAP_SERVICES credentials:\r\n\r\n* sap.cloud.service: Service name as referenced from xs-app.json route and business service prefix (if Business Service UI provided) - Mandatory\r\n* sap.cloud.service.alias: Short service name alias for user friendly URL business service prefix- Optional\r\n* endpoints: One or more endpoints that can be used to access Business Service data. \r\n* html5-apps-repo: html5-apps-repo.app_host_id contains one or more html5-apps-repo service instance GUIDs that can be used to retrieve Business Service UIs - Optional\r\n* saasregistryenabled: flag that indicates that this Business Service supports SaaS Registry subscription. If provided, application router will return this Business Service xsappname in SaaS Registry \r\n  getDependencies callback - Optional\r\n* grant_type: the grant type that should be used to trigger requests to the Business Service. Allowed values: user_token or client_credentials. \r\n  Default value, in case this attribute is not provided, user_token - Optional\r\n* forwardiastoken: flag that indicates if, in addition to the exchanged xsuaa token, the IAS token should be forwarded as well. IAS token is forwarded in request header: `x-ias-token`\r\n\r\n\r\nThe value of `endpoints` should be an object with the following properties:\r\n\r\nProperty | Type | Optional | Default |Description\r\n-------- | ---- |:--------:| ---- |-----------\r\nurl | String |   | |URL to access the Business Service data.\r\ntimeout | Number | x | 30000ms |Positive integer representing the maximum wait time for a response (in milliseconds) from the Business Service. \r\n\r\n\r\nFor example:\r\n```\r\n\"country\": [\r\n   {\r\n    ...\r\n    \"credentials\": {\r\n     \"sap.cloud.service\": \"com.sap.appbasic.country\", \r\n     \"sap.cloud.service.alias\": \"country\",            \r\n     \"endpoints\": {                                   \r\n      \"countryservice\": { \"url\": https://icf-countriesapp-test-service.cfapps.sap.hana.ondemand.com/odata/v2/countryservice\"},\r\n      \"countryconfig\":  { \r\n            \"url\": https://icf-countriesapp-test-service.cfapps.sap.hana.ondemand.com/rest/v1/countryconfig\",\r\n            \"timeout\": 120000 \r\n      }\r\n     },\r\n     \"html5-apps-repo\": {                           \r\n      \"app_host_id\": \"1bd7c044-6cf4-4c5a-b904-2d3f44cd5569, 1cd7c044-6cf4-4c5a-b904-2d3f44cd54445\"\r\n     },\r\n     \"saasregistryenabled\": true,\r\n     \"grant_type\": \"user_token\"\r\n   ....\r\n```\r\n\r\n#### Accessing Business Service Data\r\nTo access Business Service data xs-app.json configuration file should have a route referencing a specific sap.cloud.service or sap.cloud.service.alias via the service attribute.\r\nIf an endpoint attribute is also modeled, it will be used to get the service url otherwise the fallback url or uri attribute will be used.\r\n\r\nFor example:\r\n```\r\n\"routes\": [\r\n    {\r\n      \"source\": \"^/odata/v2/(.*)$\",\r\n      \"target\": \"$1\",\r\n      \"service\": \"com.sap.appbasic.country\",\r\n      \"endpoint\": \"countryservice\"\r\n    },\r\n\r\n```\r\n\r\nIn order to support JWT token exchange, the login JWT token should contain the uaa.user scope. For that the xs-security configuration must contain a role template that references the uaa.user scope.\r\nFor example:\r\n```\r\n{\r\n    \"xsappname\"   : \"simple-approuter\",\r\n    \"tenant-mode\" : \"shared\",\r\n    \"scopes\": [\r\n        {\r\n            \"name\": \"uaa.user\",\r\n            \"description\": \"UAA\"\r\n        },\r\n        {\r\n            \"name\": \"$XSAPPNAME.simple-approuter.admin\",\r\n            \"description\": \"Simple approuter administrator\"\r\n        }\r\n    ],\r\n    \"role-templates\": [\r\n        {\r\n            \"name\": \"Token_Exchange\",\r\n            \"description\": \"UAA\",\r\n            \"scope-references\": [\r\n                \"uaa.user\"\r\n            ]\r\n        },\r\n        {\r\n            \"name\": \"simple-approuter-admin\",\r\n            \"description\": \"Simple approuter administrator\",\r\n            \"scope-references\": [\r\n                \"$XSAPPNAME.simple-approuter.admin\"\r\n            ]\r\n        }\r\n    ]\r\n}\r\n```\r\n\r\n#### Accessing Business Service UI\r\nBusiness Service UI's must be stored in HTML5 Application Repository and defined in their manifest.json files as \"public: true\" in order to be accessible from an application router\r\napplication that is typically running in a different space than the Business Service space. In addition dataSources uris must be relative to base url (no slash as first character).\r\n\r\nBusiness Service manifest.json example:\r\n\r\n```\r\n{\r\n  â€œsap.appâ€: {\r\n    â€œidâ€:â€œcom.sap.appbasic.country.listâ€,\r\n    â€œapplicationVersion: {\r\n    â€œversionâ€: â€œ1.0.0â€\r\n  },\r\n  \"dataSources\": {\r\n    \"mainService\":{\r\n      \"uri\": \"odata/v2/countryservice\",\r\n      \"type\": \"OData\"\r\n    }\r\n  },\r\n  â€œsap.cloudâ€: {\r\n    \"public\": true,\r\n    â€œserviceâ€: â€œcom.sap.appbasic.countryâ€œ\r\n  }\r\n}\r\n```\r\n\r\nA Business Service that exposes UI must provide one or more app-host GUIDs in an html5-apps-repo block in VCAP_SERVICES credentials (see Business Service credentials).\r\n\r\nTo access Business Service UI the request url that hits application router must contain a business service prefix as described above.\r\n\r\nRequest URL example:\r\n```\r\n  https://approuter-repo-examples.cfapps.sap.hana.ondemand.com/comsapappbasiccountry.comsapappbasicscountrylist/test/flpSandbox.html\r\n\r\n```\r\nIn this example \"comsapappbasiccountry\" is the business service prefix which matches the sap.cloud.service attribute in country service VCAP_SERVICES credentials (without dots).\r\nThe \"comsapappbasicscountrylist\" is the name of the HTML5 Application as defined in the app.id attribute in the manifest.json (without dots).\r\n\r\n## Web Sockets\r\nThe application router is capable of forwarding web socket communication.\r\nIn order to use the web socket communication, it should be enabled through the [*websockets* property](#websockets-property).\r\nIf the backend service requires authentication then the upgrade request should contain a valid session cookie.\r\nThe destination schemas \"ws\" and \"wss\" are supported in addition to \"http\" and \"https\".\r\nWhen the application router receives an upgrade request, it verifies that the `Origin` header holds the URL of the application router.\r\nIf this is not the case, then an HTTP response with status 403 is returned to the client.\r\nThis origin verification can be further configured via the environment variable `WS_ALLOWED_ORIGINS`.\r\nIt contains the allowed origins the application router verifies against. It's structure is the same as [`CJ_PROTECT_WHITELIST`](#configuring-allowed-hostnames--domains).\r\n\r\n**Note:** A current limitation is that a web socket ping is not forwarded to the backend service.\r\n\r\n## Session Handling\r\n\r\nThe application router establishes a session with the client (browser) using a session cookie.\r\n\r\nThe application router intercepts all _session_ cookies, sent by backend services and stores them in its own session. Backend session cookies are not sent to the client in order to prevent cookie collisions. Upon subsequent requests the application router sends back the cookies to the respective backend services so they can establish their own sessions.\r\n**Note:** Non-session cookies from backend services are forwarded to the client. Cookie collisions may occur and the application should be able to handle them.\r\n\r\nIf a pending request is canceled, the request cancellation will be propagated to the backend service.\r\n\r\nIf there is no session in the application router, either because there has been a session timeout or because no session has been created yet, and if the incoming request matches a non-public route, the application router triggers a redirect to the authentication service (UAA or IAS).\r\nAfter a successful login, a redirect back to application router takes place using the login callback endpoint, which triggers the creation of a new session.\r\nIf the incoming request is an AJAX request (has the request header X-Requested-With: XMLHttpRequest) or if the HTTP verb is not GET and no session exists (there is no session cookie and the request doesnâ€™t have an x-approuter-authorization header), the application router returns the response code 401 - Unauthorized. This enables the client application to handle the 401 response before it navigates to the authentication service. For example, the application can store data entered by the user and prevent data loss.\r\nWhen the handling of the 401 response is completed, the client application should send a request without an xmlhttprequest object to trigger the application router authentication flow.\r\n\r\n### Session Contents\r\n\r\n* CSRF token - the generated CSRF token so it can be verified against the token in the request, see [CSRF Protection](#csrf-protection) above.\r\n* OAuth token - JSON Web Token (JWT) fetched from UAA and forwarded to backend services in the Authorization header. The client never gets this token.\r\nThe application router refreshes the JWT automatically before it expires (if the session is valid). By default this routine is triggered 5 minutes before the expiration of the JWT.\r\nThis can also be configured via the `JWT_REFRESH` environment variable (the value is in minutes). If `JWT_REFRESH` is set to 0 then the refresh is disabled.\r\n* OAuth scopes - scopes owned by the current user, used to check if the user has the scope required for each request. See `scope` in [Routes](#routes).\r\n* Backend session cookies - all session cookies sent by backend services.\r\n* Business Services OAuth tokens - JSON Web Token (JWT) exchanged and used to access re-use services bound to the application router\r\n\r\n**Note:** If the JWT is close to expiration and the session is still active a JWT refresh will be triggered in `JWT_REFRESH` minutes before expiration.\r\n`JWT_REFRESH` is an environment variable stating the number of minutes before the JWT expiration the refresh will be triggered. The default value is 5 minutes.\r\n\r\n## External Session Management\r\nThe application router supports a backup of user sessions in an external session store. This enables the session recovery in case the application router instance that stores a session crashes and another application router instance has to continue handling the running user session.  \r\nTo enable this capability, you must bind a service instance of a service that supports a fast persistence store, such as *Redis*. When such a service is bound, the application router backs up the in-memory session information into the external persistency store.  \r\nIf, in subsequent requests, the session information is not found in the in-memory session store, the application router tries to rebuild the in-memory session information from the external persistency store.   \r\n\r\nThe sessions are stored compressed. For capacity planning, you can assume 50 Kb per session storage in the fast persistence store. \r\n\r\n### External Session Management Configuration\r\nIn order to use this feature, you have to set the following environment variable:\r\n\r\n```EXT_SESSION_MGT```  \r\n\r\nThe variable value must be defined in the JSON format and provide the following properties:\r\n* **instanceName (mandatory)** - the name of the service instance of the storage service.\r\n* **storageType (mandatory)** - the type of the storage, for example - \"redis\". Note that if no custom storage driver is used, only â€œredisâ€ is allowed.\r\n* **sessionSecret (mandatory)** - a secret to be used to generate a session cookie. Please generate a unique string with at least 64 characters.\r\n* **defaultRetryTimeout** - the maximum duration for automatic retries of failed Redis operations in milliseconds. The default value is 2000 ms.\r\n* **backOffMultiplier** - a multiplier of the Redis-defined pause that determines the time between consecutive automatic retries of failed Redis operations. The default value is 50.\r\n\r\nFor example: \r\n```json\r\n{\r\n    \"instanceName\": \"approuter-redis\",\r\n    \"storageType\": \"redis\",\r\n    \"sessionSecret\": \"someuniquesessionsecret\",\r\n    \"defaultRetryTimeout\": 10000,\r\n    \"backOffMultiplier\": 10\r\n}\r\n```\r\n\r\n> **_NOTE:_** Currently, the application router supports only a Redis store\r\n\r\n### Configuration of a Custom Storage Driver\r\nFor information about the configuration of a custom storage driver, see [Configuring a custom storage driver](doc/sessionManagement.md#custom-storage-driver)\r\n\r\n\r\n## Service to Application Router\r\n\r\nThe application router can receive a consumer service JWT token created by the SAP Authorization and Trust Management (xsuaa) service or an OIDC access token created by Identity Authentication service and use it to access the UI and the data. The token is passed to the application router in the \"x-approuter-authorization\" header of the request. For more information, see [Authorization Header](#authorization-header-beta-version).\r\n\r\nCookie Handling:\r\nIn this flow client cookies are merged to backend cookies in case a backend cookie with the same key does not exist.\r\n\r\nIf you have configured [external session management](#external-session-management), an external session is created for each token in the external session management service (for example, in Redis). Such an external session has the same expiration time as the token for which it was created. \r\nThe application router uses the external session to store cached data, such as the exchanged tokens and destination configurations, to improve the performance by reducing roundtrips to the authentication and destination services.\r\n\r\n**Note**: The XSUAA JWT token or the OIDC token are generated with the same XSUAA service instance or the same Identity service instance that is bound to the application router. \r\n\r\n\r\n## Central Logout\r\n\r\nCentral Logout can be client initiated or can be triggered due to session timeout.\r\n* Client initiated\r\n  * Deletes the user session.\r\n  * Requests all backend services logout paths (if configured in the [destinations property](#destinations-property)).\r\n  * Request all business services logout paths (if configured in the [services property](#services-property)).\r\n  * Redirects the client to logout from UAA.\r\n  * If configured, redirects back to a custom page (for XS OnPremise Runtime only). For more information, see [logout-property](#logout-property).\r\n* Session timeout\r\n  * Deletes the user session.\r\n  * Requests all backend services logout paths (if configured in the [destinations property](#destinations-property)).\r\n  * Requests all business services logout paths (if configured in the [services property](#services-property)).\r\n\r\nThe session timeout can be configured with the [SESSION_TIMEOUT](#session-timeout) variable through the environment.\r\n\r\n## Allowlist Service\r\n\r\nA protection concept is designed in SAP that uses UI libraries and an allowlist service for proper clickjack protection of applications. The general idea is that when an html page needs to be rendered in a frame, a check is done by calling the allowlist service to validate if the parent frame is allowed to render the content in a frame. The actual check is provided by the allowlist service.\r\n\r\n### Enable the service\r\n\r\nTo enable the allowlist service and to open the service endpoint you need to configure the [whitelistService](#whitelistservice-property) property in *xs-app.json*.\r\n\r\n### Configuring allowed hostnames / domains\r\n\r\nThe allowlist service reads allowed hostnames and domains from the environment variable `CJ_PROTECT_WHITELIST`.\r\nThe content is a JSON array of object with the following properties:\r\n\r\nProperty | Type | Optional | Description\r\n-------- | ---- |:--------:| -----------\r\nprotocol | String | x | URI scheme, for example `http`.\r\nhost | String |  | Hostname / domain - valid hostname, or domain defined with a star (\\*), for example `some.concrete.hostname`, or `*.example.domain`.\r\nport | String / Number | x | Port string or number containing a valid port.\r\n\r\nExample:\r\n```json\r\n[\r\n  {\r\n    \"protocol\": \"http\",\r\n    \"host\": \"*.example.domain\",\r\n    \"port\": 12345\r\n  },\r\n  {\r\n    \"host\": \"some.concrete.hostname\",\r\n  }\r\n]\r\n```\r\n\r\nMatching is done against provided properties. For example if only host is provided then the service will return `framing: true` for all and matching will be for all schemas and protocols.\r\n\r\n### Return value\r\n\r\nThe service accepts only `GET` requests and the response is a JSON object.\r\nThe allowlist service call uses the parent origin as URI parameter (URL encoded) as follows:\r\n\r\n```\r\nGET url/to/whitelist/service?parentOrigin=https://parent.domain.com\r\n```\r\n\r\nThe response is a JSON object with following properties:\r\n\r\n```\r\n{\r\n    \"version\" : \"1.0\",\r\n    \"active\"  : true | false,                   // indicates whether framing control is switched on\r\n    \"origin\"  : \"<same as passed to service>\",\r\n    \"framing\" : true | false                    // if active, describes if framing should be allowed\r\n}\r\n```\r\n\r\nThe property `active` will have value `false` only in case `CJ_PROTECT_WHITELIST` is not provided.\r\n\r\n**Note**: Keep in mind that the application router sends by default the X-Frame-Options header with value `SAMEORIGIN`, in the case the allowlist service is enabled, this header value probably needs to be changed, see the [X-Frame-Options](#x-frame-options-configuration) header section for details how to change it.\r\n\r\n## User API Service\r\nThe application router exposes a user API that returns the details of the user who is logged in. This API supports two endpoints: `/currentUser` and `/attributes`.\r\nThe /currentUser endpoint returns all details of logged in users, while the /attributes endpoint returns the main user properties.\r\nThe user API can be implemented by modelling an xs-app.json route using service sap-approuter-userapi.\r\n\r\nNote: The following applies if the route has the authentication type â€œxsuaaâ€:\r\n*\tUser scopes from the xsuaa access token will be added to the response of both endpoints.\r\n*\tUser attributes from the identity provider (IdP) chosen for the authentication will be added to the response of the â€œ/attributesâ€ endpoint. If a custom IdP is configured for Identity Authentication Service (IAS), the custom user attributes are also added to the response of the â€œ/attributesâ€ endpoint. For more information about the definition of custom properties in IAS, see [Configure the Default Attributes Sent to the Application](https://help.sap.com/docs/IDENTITY_AUTHENTICATION/6d6d63354d1242d185ab4830fc04feb1/a2f1e4692e7d4379ab82144ab309e7b3.html) on the SAP Help Portal.\r\n\r\nExamples:\r\n\r\nHandle both endpoints\r\n```\r\n{\r\n    \"source\": \"^/user-api(.*)\",\r\n    \"target\": \"$1\",\r\n    \"service\": \"sap-approuter-userapi\"\r\n},\r\n```\r\n\r\nHandle `/currentUser` endpoint only\r\n```\r\n{\r\n    \"source\": \"^/user-api/currentUser$\",\r\n    \"target\": \"/currentUser\",\r\n    \"service\": \"sap-approuter-userapi\"\r\n},\r\n```\r\nThe /currentUser endpoint response has the following format:\r\n```\r\n{\r\n   \"firstname\": \"John\",\r\n   \"lastname\": \"Doe\",\r\n   \"email\": \"john.doe@sap.com\",\r\n   \"name\": \"john.doe@sap.com\",\r\n   \"displayName\": \"John Doe (john.doe@sap.com)\",\r\n   \"scopes\": \"openid,user_attributes,uaa.user\" (See the note above about routes with authentication type â€œxsuaaâ€.)\r\n}\r\n```\r\nThe /attributes endpoint response has the following format:\r\n```\r\n{\r\n   \"firstname\": \"John\",\r\n   \"lastname\": \"Doe\",\r\n   \"email\": \"john.doe@sap.com\",\r\n   \"name\": \"john.doe@sap.com\",\r\n   \"scopes\": \"openid,user_attributes,uaa.user\", (See the note above about routes with authentication type â€œxsuaaâ€.)\r\n   <user attributes, including custom attributes> (See the note above about routes with authentication type â€œxsuaaâ€.)\r\n}\r\n```\r\nNote that the \"name\" property is the user ID in the identity provider, which in many cases is also the email address.\r\n## Scaling\r\n\r\nThe application router keeps all established sessions in local memory and does not sync them across multiple instances.\r\nIn order to scale the application router to multiple instances, session stickiness should be enabled.\r\nThis means that each HTTP session is handled by the same application router instance.\r\n\r\nIn Cloud Foundry's router, session stickiness is enabled from version 0.1.0.\r\n\r\nIn SAP HANA XS Advanced OnPremise Runtime session stickiness is enabled, if SAP Web Dispatcher is used as a router.\r\nThis is set by default from version 0.1535 of SAP HANA XS Advanced runtime.\r\nIf your on-premise runtime uses *nginx* as router, you can switch to SAP Web Dispatcher by passing the command line option `--router=webdispatcher` to `xs-controller`.\r\n\r\n## Sizing Guide for Application Router\r\n\r\nThe memory consumption of the application router is described in the [sizing guide](doc/sizingGuide.md).\r\n\r\n## Configure server-side HTTPS\r\n\r\nYou can configure application router to accept only HTTPS connections. See `httpsOptions` option of [start](doc/extending.md#startoptions-callback) function.\r\n\r\n## Audit-Log Service\r\n\r\nThe application router logs information regarding unauthorized requests. To avoid exposure of private information such as user id and IP address,  you must bind the consuming application to an instance of the audit-log service.\r\n\r\nIf you do not bind the consuming application to the audit-log service, the application router will log this information to the console output, using asterisks to mask the user id and IP address. (This is the default behavior.)\r\n\r\n\r\n## Troubleshooting\r\n\r\nThe application router uses _@sap/logging_ package so all of its features are available to control logging.\r\nFor example to set all logging and tracing to finest level set `XS_APP_LOG_LEVEL` environment variable to `debug`.\r\n\r\nIf the application is deployed on Cloud Foundry, you can change the log level by running command:\r\n```sh\r\ncf set-env <application-name> XS_APP_LOG_LEVEL debug\r\n```\r\n\r\nIf the application is deployed on XS Advanced On-premise Runtime, you can change the log level without restarting the application.\r\nFor example this command will set all logging and tracing to finest level.\r\n```sh\r\nxs set-logging-level <application-name> \"*\" debug\r\n```\r\nSee _@sap/logging_ documentation for details.\r\n\r\nYou can enable additional traces of the incoming and outgoing requests by setting the environment variable `REQUEST_TRACE` to `true`.\r\nWhen enabled they will log basic information for every incoming and outgoing request of the application router. This could have a performance impact.\r\n\r\nSome of the libraries used by this package employ other tracing mechanisms. For example many use the popular [debug](https://www.npmjs.com/package/debug) package. This means that by setting `DEBUG` environment variable, you can enable additional traces. Set it to `*` to enable all of them, but be careful as the output may be overwhelming.\r\nIn addition internal Node.js traces can be enabled via `NODE_DEBUG` environment variable. [This post](http://www.juliengilli.com/2013/05/26/Using-Node.js-NODE_DEBUG-for-fun-and-profit/) describes it in more detail.\r\n\r\n\r\n**Warning:** Enabling some of these options may trace security sensitive data, so use with caution.\r\n\r\nThe _@sap/logging_ package sets the header 'x-request-id' in the application router's responses.\r\nThis is useful if you would like to search entries belonging to a particular request execution in the application router's logs and traces.\r\nNote that the application router does not change the headers received from the backend and being forwarded to the client.\r\nIf the backend is a Node.js application which uses the _@sap/logging_ package (and also sets the 'x-request-id' header), then the value of the header\r\nthat the client will receive will be the one coming from the backend and not the one of the application router itself.\r\n\r\n## Getting Support\r\nCreate a BCP ticket on component `BC-XS-APR`\r\n\r\n## Extending Application Router\r\nSee [extending](doc/extending.md) for information how to extend the application router\r\nwith custom logic.\r\n\r\n## Best practices\r\n\r\n### Security best practices\r\n\r\n#### Content-Security-Policy\r\nSetting the `Content-Security-Policy` header - this is a response header which informs browsers (capable of interpreting it) about the trusted sources\r\nfrom which an application expects to load resources. This mechanism allows the client to detect and block malicious scripts injected into an application.\r\nA value can be set via the `httpHeaders` environment variable in the [additional headers configuration](#additional-headers-configuration).\r\nThe value represents a security policy which contains directive-value pairs. The value of a directive is an allowlist of trusted sources.\r\nIn case content-security-policy headers are returned from backend, they will override `httpHeaders` configuration. \r\nTo enable returning both (backend and local content-security-policy headers), configure environment variable `MERGE_CSP_HEADERS`.\r\n\r\nRefer to the `Content-Security-Policy` specification for more information on the header's value.\r\n\r\n**Note:** Usage of the `Content-Security-Policy` header is considered second line of defense. An application should always provide proper input validation and output encoding.\r\n\r\n### Identity Provider Configuration Best Practices\r\n\r\n#### Modelling options:\r\n\r\n1. If you to enable login in same browser window as doctor and patient you can create 2 cf routes to same approuter:\r\n```https://approuter-doctors.cfapps.hana.com/myapp/doctors/index.html```\r\n```json\r\n{\r\n  \"source\": \"^/doctors(/.*)\",\r\n  \"target\": \"$1\",\r\n  \"service\": \"html5-apps-repo-rt\",\r\n  \"authenticationType\": \"xsuaa\",\r\n  \"identityProvider\": \"doctorsIDP\"\r\n}\r\n```\r\n\r\n```https://approuter-patients.cfapps.hana.com/myapp/patients/index.html```\r\n```json\r\n{\r\n  \"source\": \"^/patients(/.*)\",\r\n  \"target\": \"$1\",\r\n  \"service\": \"html5-apps-repo-rt\",\r\n  \"authenticationType\": \"xsuaa\",\r\n  \"identityProvider\": \"patrientsIDP\"\r\n}\r\n```\r\n\r\n2. If you to enable single access at a time (force logout from doctors idp and re-login to patients idp), create a single cf route\r\n```https://approuter-hospital.cfapps.hana.com/myapp/doctors/index.html```\r\n```json\r\n{\r\n  \"source\": \"^/doctors(/.*)\",\r\n  \"target\": \"$1\",\r\n  \"service\": \"html5-apps-repo-rt\",\r\n  \"authenticationType\": \"xsuaa\",\r\n  \"identityProvider\": \"doctorsIDP\"\r\n}\r\n```\r\n \r\n```https://approuter-hospital.cfapps.hana.com/myapp/patients/index.html```\r\n```json\r\n{\r\n  \"source\": \"^/patients(/.*)\",\r\n  \"target\": \"$1\",\r\n  \"service\": \"html5-apps-repo-rt\",\r\n  \"authenticationType\": \"xsuaa\",\r\n  \"identityProvider\": \"patrientsIDP\"\r\n}\r\n```\r\n"}]