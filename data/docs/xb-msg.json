[{"name":"CHANGELOG.md","content":"# Change Log\r\n\r\nAll notable changes to this project will be documented in this file.\r\n\r\nThis project adheres to [Semantic Versioning](http://semver.org/).\r\n\r\nThe format is based on [Keep a Changelog](http://keepachangelog.com/).\r\n\r\n## [0.9.10] - 2020-06-26\r\n\r\n- added: license file for new delivery channel\r\n- fixed: newer Node.js version for unit tests and coverage\r\n\r\n## [0.9.9] - 2019-03-28\r\n\r\n## [0.9.7] - 2019-03-27\r\n\r\n## [0.9.6] - 2019-03-27\r\n\r\n## [0.9.5] - 2019-02-11\r\n\r\n## [0.9.4] - 2019-02-11\r\n\r\n## [0.9.3] - 2019-02-11\r\n\r\n## [0.9.2] - 2019-02-06\r\n\r\n## [0.9.1] - 2019-02-06\r\n\r\n### Added\r\n- support of the amqp v100 protocol with QoS at least once\r\n\r\n### Changed\r\n\r\n### Removed\r\n"},{"name":"README.md","content":"# Message Streams\r\nProvides a client for stream-based messaging.\r\n\r\n## Table of contents\r\n* [Prerequisites](#prerequisites)\r\n* [Install](#install)\r\n* [Overview](#overview)\r\n* [Client Options](#client-options)\r\n* [Connections](#connections)\r\n* [Message Streams](#message-streams)\r\n* [Message Payload](#message-payload)\r\n* [Payload and Websocket Data Masking](#message-payload-and-websocket-data-masking)\r\n* [Examples](#examples)\r\n\r\n## Prerequisites\r\nMake sure to have a message broker available, e.g. [RabbitMQ](https://www.rabbitmq.com/download.html) installed locally, having the plugins for AMQP 1.0, MQTT 3.1.1 and WebSocket binding enabled.\r\n\r\n## Install\r\n\r\nSee also:\r\n[https://www.npmjs.com/package/@sap/xb-msg](https://www.npmjs.com/package/@sap/xb-msg)\r\n\r\nTo add it to your project run:\r\n```bash\r\nnpm i @sap/xb-msg\r\n```\r\n\r\nTo generate complete API documentation run inside the library package folder\r\n```bash\r\nnpm run doc\r\n```\r\n\r\n## Overview\r\nA messaging application shall focus on its business logic.\r\nBindings and protocol-specific settings shall move to configuration, without negative impact on performance.\r\nThe package provides a solution for that, wrapping protocol-specific client implementations from separate packages.\r\n\r\n| Library               | Protocol                                                                          |\r\n|:----------------------|:----------------------------------------------------------------------------------|\r\n| `@sap/xb-msg-amqp-v091` | [AMQP v0.9.1](http://www.amqp.org/specification/0-9-1/amqp-org-download)          |\r\n| `@sap/xb-msg-amqp-v100` | [AMQP v1.0](http://www.amqp.org/specification/1.0/amqp-org-download)              |\r\n| `@sap/xb-msg-mqtt-v311` | [MQTT v3.1.1](http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html) |\r\n\r\nDirect usage of the listed libraries provides full access to protocol-specific features.\r\nWith `@sap/xb-msg-amqp-091` the application may control channels, queues and exchanges.\r\nWith `@sap/xb-msg-amqp-100` the application may for example define sessions, attach links and control link credit dynamically.\r\nWith `@sap/xb-msg-mqtt-311` last-will-messages could be used.\r\n\r\nHowever, many messaging applications will have less specific requirements. It may come down to:\r\n* Produce messages with a writable stream\r\n* Consume messages from a readable stream\r\n* Use messages with a binary payload\r\n* Receive message at least once and acknowledge messages after successful processing\r\n* Stay flexible with regards to the used messaging protocol\r\n* But still accept the need to maintain settings on the broker side, e.g. to create queues or assign topic bindings to it\r\n\r\nWith these requirements `@sap/xb-msg` in combination with package `@sap/xb-msg-env` can be a good choice.\r\nFor example to consume messages:\r\n\r\n```javascript\r\nconst msg = require('@sap/xb-msg');\r\nconst env = require('@sap/xb-msg-env');\r\n\r\nconst options = env.msgClientOptions('my-service-instance', ['my-inp'], []);\r\nconst client = new msg.Client(options);\r\n\r\nclient.istream('my-inp')\r\n    .on('error', () => {\r\n        console.log(error);\r\n    })\r\n    .on('data', (message) => {\r\n        console.log(`message: ${message.payload.toString()}`);\r\n        message.done();\r\n    })\r\n;\r\n\r\nclient.connect();\r\n```\r\n\r\n`@sap/xb-msg-env` reads cf/xs environment variables to build up the client options (configuration).\r\nSwitching the protocol, changing the binding to queues or topics or changing the quality of service becomes possible without changing the program code.\r\n\r\nA message producer is implemented in a similar way:\r\n```javascript\r\nconst msg = require('@sap/xb-msg');\r\nconst env = require('@sap/xb-msg-env');\r\n\r\nconst options = env.msgClientOptions('my-service-instance', [], ['my-out']);\r\nconst client = new msg.Client(options);\r\n\r\nclient.ostream('my-out')\r\n    .on('ready', () => {\r\n        send();\r\n    })\r\n    .on('drain', () => {\r\n        send();\r\n    })\r\n    .on('error', (error) => {\r\n        console.log(error);\r\n    })\r\n;\r\n\r\nclient.connect();\r\n```\r\n\r\nFinally, using an own `Transform` stream (here class `Converter`) the application can also rely on fully automated flow control:\r\n```javascript\r\nconst msg = require('@sap/xb-msg');\r\nconst env = require('@sap/xb-msg-env');\r\n\r\nconst options = env.msgClientOptions('my-service-instance', ['my-inp'], ['my-out']);\r\nconst client = new msg.Client(options);\r\n\r\nclient.istream('my-inp')\r\n    .pipe(new Converter())\r\n    .pipe(client.ostream('my-out'))\r\n;\r\n\r\nclient.connect();\r\n```\r\n\r\n## Client Options\r\nThe client employs protocol-specific libraries that require protocol-specific settings, at least for stream definitions.\r\nFor example, MQTT will accept a property `qos` whereas `AMQP 1.0` accepts `sndSettleMode` and `rcvSettleMode`.\r\nHowever, these differences are restricted to the configuration.\r\nAt runtime the application will always see a unified client behavior.\r\n\r\n## Connections\r\nBased on client options one or more connections can be created, each for one of the supported protocols and each providing multiple incoming or outgoing streams.\r\nAs soon as a client instance is connected the application can produce and/or consume messages.\r\n\r\nConnections via 'net' and 'tls' are supported for all protocols.\r\nWebsocket is specified and in consequence implemented for MQTT 3.1.1 and AMQP 1.0 only. Use options attribute 'wss' or 'ws'.\r\n\r\nWebSocket connections can also be established using [OAuth 2.0](https://oauth.net/2/), for example when connecting a local application to SAP cloud.\r\nRelevant grant flows are: [ClientCredentialsFlow](https://tools.ietf.org/html/rfc6749#section-4.4) and [ResourceOwnerPasswordCredentialsFlow](https://tools.ietf.org/html/rfc6749#section-4.3).\r\n\r\nIf multiple settings are provided the preference is as follows: preferred 'tls' then 'net' then 'wss' then finally 'ws'.\r\n\r\n## Message Streams\r\n`Writable` and `Readable` streams are provided to handle outgoing and incoming messages.\r\nThese streams always run in object mode.\r\n\r\nHere, a single message is represented as a plain object with the following attributes:\r\n* `source`: defined by the incoming stream,\r\n* `target`: defined optionally by the application, similar to the source, accepted by the outgoing stream,\r\n* `payload`: message payload,\r\n* `done()`: a callback function to confirm final message processing,  \r\n* `failed(error)`: a callback function to indicate processing failure.\r\n\r\nA receiving application is expected to call either `done` or `failed` for each single message, exactly one time (maybe asynchronously) and independent from the used quality of service.\r\nA sending application can define the callbacks to get notified about the message state.\r\n \r\n```bash\r\nconst message = {\r\n    payload : Buffer.from('test'),\r\n    done : () => this._onSendDone(message),\r\n    failed : (error) => this._onSendFailed(error, message)\r\n};\r\nconst noPause = stream.write(message);\r\n```\r\n\r\nIn any case the application is expected to implement the flow control of writable streams correctly.\r\n\r\n## Message Payload\r\n\r\nThe application may provide the message payload for an outgoing message as follows:\r\n* a `Buffer` object,\r\n* an `Array` of `Buffer` objects,\r\n* a `Payload` object or a plain object with same properties as `Payload`.\r\n\r\nCommon properties of a `Payload` object (specific protocol clients add more data):\r\n* `chunks`: an Array of Buffer objects,\r\n* `type`: an optional string providing the content type (not supported with MQTT)\r\n\r\nAfter the payload was given to a sender it must not be modified by the application anymore.\r\n\r\nIncoming messages will always provide a `Payload` object, just for application convenience.\r\n\r\n## Examples\r\n\r\nIn folder `examples` there are test programs, ready to run if a broker can be reached locally at the protocol-specific default port.\r\nFolder `examples/cfg` provides sample configurations.\r\n\r\n"}]