[{"name":"CHANGELOG.md","content":"# Change Log\r\n\r\nAll notable changes to this project will be documented in this file.\r\n\r\nThis project adheres to [Semantic Versioning](http://semver.org/).\r\n\r\nThe format is based on [Keep a Changelog](http://keepachangelog.com/).\r\n\r\n## [0.7.11] - 2020-10-12\r\n\r\n- update: README after move to npmjs\r\n- added: optional parameter info at event.setUnauthorized(info) and event.setBadRequest(info)\r\n\r\n## [0.7.10] - 2020-09-23\r\n\r\n- fixed; event error responses\r\n\r\n## [0.7.9] - 2020-07-01\r\n\r\n## [0.7.8] - 2020-07-01\r\n\r\n- fixed: express route for local test run with special function names, e.g. \"fun\" and \"fun2\"\r\n- startup log lines removed, more simple log consumption\r\n\r\n## [0.7.7] - 2020-03-12\r\n\r\n## [0.7.6] - 2020-03-12\r\n\r\n## [0.7.5] - 2020-03-11\r\n\r\n- fixed: special handling for cloudevent response in function call, e.g. in unit tests\r\n## [0.7.4] - 2020-03-09\r\n\r\n## [0.7.3] - 2020-03-06\r\n\r\n## [0.7.2] - 2020-01-31\r\n\r\n- fixed: code completion for vscode and intellij\r\n\r\n## [0.7.1] - 2020-01-28\r\n\r\n- fixed: service credentials, provide only credentials content\r\n\r\n## [0.7.0] - 2020-01-24\r\n\r\n- optimized runtime (full separation of sdk support)\r\n- added: context methods for service credentials\r\n- added: event.setBadRequest()\r\n- added: event.setUnauthorized()\r\n\r\n## [0.6.3] - 2019-09-23\r\n\r\n- fixed: function codes console.log() reaches runtime log in Node.js 10 or higher\r\n\r\n## [0.6.2] - 2019-05-21\r\n\r\n- fixed: README.md, explain faas instance descriptor\r\n- fixed: cleanup dependencies for example\r\n- fixed: cleanup dependencies for project template\r\n- updated dev dependencies, e.g. nyc for code coverage\r\n\r\n## [0.6.0] - 2019-02-15\r\n\r\n## [0.5.1] - 2018-12-18\r\n\r\n### Added\r\n\r\n- initial version\r\n- documentation\r\n- command `faas-cli`\r\n- init project\r\n- init deploy values\r\n- local run support\r\n- unit test support\r\n"},{"name":"README.md","content":"# @sap/faas\r\nProvides the SAP Cloud Platform Functions runtime for Node.js and basic SDK features.\r\n\r\n## Table of contents\r\n* [Overview](#overview)\r\n* [Package](#package)\r\n* [Install](#install)\r\n* [Service Instances](#service-instances)\r\n* [Naming Rules](#naming-rules)\r\n* [Function Projects](#function-projects)\r\n  * [Project Attributes](#project-attributes)\r\n  * [Secrets and Config Maps](#secrets-and-config-maps)\r\n  * [Service References](#service-references)\r\n  * [Functions](#functions)\r\n* [Function Triggers](#function-triggers)\r\n  * [HTTP](#http-trigger)\r\n  * [Timer](#timer-trigger)\r\n  * [AMQP](#amqp-trigger)\r\n  * [CloudEvents](#cloudevents-trigger)\r\n* [Function Runtime API](#function-runtime-api)\r\n  * [Global Variables](#global-variables)\r\n  * [Handler Exceptions](#handler-exceptions)\r\n  * [Handler Parameter: event](#handler-parameter-event)\r\n  * [Handler Parameter: context](#handler-parameter-context)\r\n* [Function Test](#function-test)\r\n* [Function Debugging](#function-debugging)\r\n* [Function Unit Test](#function-unit-tests)\r\n\r\n## Overview\r\n\r\nSAP Cloud Platform Serverless Runtime provides together with other components also Functions as a service (__FaaS__).\r\nDevelopers can focus on pure application logic while writing the code,\r\nwhereas FaaS takes responsibility to run the code in a secure, reliable and cost-efficient way.\r\n\r\nTechnically, FaaS runs on Kubernetes (__K8s__).\r\nArtifact deployments are managed using a service API, also running in K8s, next to the runtime of course.\r\nThe overall architecture would allow integration of different serverless runtimes. However, currently K8s is used.\r\n\r\nIn Cloud Foundry (__CF__) service `xsf-runtime` (Extension Factory, serverless runtime) is used as entry point.\r\nEach service instance represents a K8s namespace in a shared cluster.\r\nAll artifacts deployed to a given service will end up as resource in the corresponding namespace.\r\nK8s namespaces (Faas tenants) are strictly isolated from each other.\r\n\r\nFunction development is based on projects, using file `faas.json` as manifest.\r\nAny local IDE as well as WebIDE (Wing) can be used for implementation.\r\n\r\n## Package\r\n\r\nThis package comprises two functional parts.\r\nFirst, it provides the function runtime for Node.js (version 8.11.3 or higher):\r\n* runtime components as such\r\n* http server to run (or debug) functions locally\r\n* test runner to support function unit tests\r\n\r\nSecondly, it offers basic SDK functionality by installing command ` faas-sdk`:\r\n* check project consistency\r\n* create and test deployment files (`values.yaml`)\r\n\r\nThe function code is provided with usual `js` files.\r\n```javascript\r\n'use strict';\r\n\r\n/**\r\n * @param {FaasEvent} event\r\n * @param {FaasContext} context\r\n * @return {Promise|*}\r\n */\r\nmodule.exports = function(event, context) {\r\n    const rval = context.getSecretValueJSON('my-secret-1', 'rv.json');\r\n    return rval.Info.Success;\r\n};\r\n```\r\n\r\nDifferent trigger types are supported to invoke functions under various conditions.\r\nSecrets provide an appropriate storage for credentials. Config maps can be used in addition for any further settings.\r\n\r\n## Install\r\n\r\nThere are two FaaS client tools, waiting to support local development:\r\n* __faas-sdk__: supports the development phase, checks project consistency, runs functions locally in a similar environments like in __K8s__, enables unit test implementation\r\n* __faas-cli__: used to manage artifact deployment into __K8s__, uses FaaS instances in the Cloud Foundry as entry point\r\n\r\nLet's start:\r\n* Install __Cloud Foundry CLI__:\r\n  * Download latest release: [https://github.com/cloudfoundry/cli/releases](https://github.com/cloudfoundry/cli/releases)\r\n  * Install binaries, test via `cf version`\r\n* Install __xfsrt-cli__:\r\n  * Go to [https://tools.hana.ondemand.com/#cloud](https://tools.hana.ondemand.com/#cloud)\r\n  * Search for \"SAP Cloud Platform Serverless Runtime CLI\"\r\n  * Install one binary, test via `xfsrt-cli version`\r\n* Install __Node.js__ (version 8.12.0 or higher):\r\n  * Download from [https://nodejs.org/en/download/](https://nodejs.org/en/download/)\r\n  * Install Node.js runtime\r\n  * Test installation with `node -v` and `npm -v`\r\n* To define devDependency to `@sap/faas` in your function projects\r\n  * Run inside a project folder `npm i @sap/faas`\r\n  * `xfsrt-cli faas project run` will also guide you here\r\n\r\nUpdate the local IDE of your choice and install plugins for Node.js.\r\nFinally, enable language support for Node.js and JavaScript (ECMAScript 6):\r\nYou may also find these links helpful: [Javascript Reference](https://developer.mozilla.org/bm/docs/Web/JavaScript) and [NodeJS Reference](https://nodejs.org/en/docs/)\r\n\r\nThe natural home of a FaaS project is a git repository.\r\nBased on that you can later easily switch between local IDE and SAP Web IDE.\r\nHence, we recommend to set up a git repository for your project from the beginning.\r\n\r\n## Naming Rules\r\nAll runtime artifacts need a name that matches the following constraints:\r\n* Only lower case characters `[a-z]` and numbers `[0-9]` and `-` can be used.\r\n* Separator `-` must not appear at the begin or the end of the name.\r\n* Maximum length is restricted to 60 characters.\r\n\r\nThis applies to:\r\n* secrets\r\n* config maps\r\n* service references\r\n* functions\r\n* triggers\r\n* project names and\r\n* project version identifiers\r\n\r\nSecret and config map __keys__ (names of its entries) are usually based on file names.\r\nThat's why it may contain `.` as well, but not at the beginning or the end.\r\n\r\n## Function Projects\r\nWe recommend using FaaS projects, as this simplifies development tasks.\r\nEach project is defined with just one file, called `faas.json`.\r\nUsually, it will reside next to a `package.json` file.\r\n\r\nA first project can easily be created with an empty folder and the following command:\r\n```bash\r\nfaas-sdk init -p ./my-test\r\n```\r\nIt will create a simple project with one function, one secret, one http trigger and simple unit tests.\r\nAfter `npm install` all unit tests, local test run and __K8s__ deployment will work immediately.\r\nContinue with renaming artifacts and modifying the function code.\r\n\r\nA first example defines one single function `build-qrcode`.\r\nThe source code is provided with file `.\\lib\\iso-time.js`.\r\nAnd the `HTTP` trigger `build-qrcode` will invoke the function.\r\n```json\r\n{\r\n  \"project\": \"qrcode-producer\",\r\n  \"version\": \"0.0.1\",\r\n\r\n  \"runtime\": \"nodejs8\",\r\n  \"library\": \"./lib\",\r\n\r\n  \"functions\": {\r\n    \"build-qrcode\": {\r\n      \"module\": \"iso-time.js\"\r\n    }\r\n  },\r\n\r\n  \"triggers\": {\r\n    \"build-qrcode\": {\r\n      \"type\": \"HTTP\",\r\n      \"function\": \"build-qrcode\"\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nA second example shows one project defining two functions, both implemented in the same module file.\r\nIn this case the module file `main.js` exports two function handlers `f1` and `f2`.\r\n```json\r\n{\r\n  \"project\": \"chain\",\r\n  \"version\": \"0.0.1\",\r\n\r\n  \"runtime\": \"nodejs8\",\r\n  \"library\": \"./lib\",\r\n\r\n  \"functions\": {\r\n    \"chain-func1\": {\r\n      \"module\": \"main.js\",\r\n      \"handler\": \"f1\"\r\n    },\r\n    \"chain-func2\": {\r\n      \"module\": \"main.js\",\r\n      \"handler\": \"f2\"\r\n    }\r\n  },\r\n\r\n  \"triggers\": {\r\n    \"chain-simple\": {\r\n      \"type\": \"HTTP\",\r\n      \"function\": \"chain-func1\"\r\n    }\r\n  }\r\n}\r\n```\r\n### Project Attributes\r\nAt the top level of `faas.json` the following fields can be defined:\r\n* __`project`__: used as label for all runtime artifacts (see restrictions to [naming rules](#naming-rules))\r\n* __`version`__: used as label for all runtime artifacts (see restrictions to [naming rules](#naming-rules))\r\n\r\nSpecific to the runtime:\r\n* __`runtime`__: used to select the runtime, currently only `nodejs8` is supported\r\n* __`library`__: base directory for all source code file references, just to reduce redundancy\r\n\r\nRuntime artifacts:\r\n* __`secrets`__: collection of secrets, used to store credentials, api keys and the like\r\n* __`configs`__: collection of config maps, used for less critical, configuration-like settings, that shall not be hard-coded\r\n* __`functions`__: collection of functions that this project defines\r\n* __`triggers`__: collection of triggers, different types with individual settings\r\n\r\nEach runtime artifact collection uses the [object name](#object-names) as json key field.\r\nThe name must be unique per artifact type in the scope of one __K8s__ namespace (that is, service instance).\r\n\r\nFor example:\r\n* Multiple namespaces may define their own secret `test1`.\r\n* In one namespace there might be a function `test1` and a secret `test1` in parallel.\r\n* However, there will be only one secret `test1` in one namespace at a time, even if two different projects are used to deploy it.\r\n\r\nNo assumptions are made regarding the separation of projects.\r\nIn particular, __FaaS__ runtime will __not__ prevent multiple projects from deploying any artifacts concurrently.\r\n\r\n### Secrets and Config Maps\r\nTechnically, secrets and config maps share the same structure.\r\nA local directory containing one or more files is used for declaration.\r\nAll files together must not exceed a total size of 1Mb.\r\n```json\r\n{\r\n  \"project\": \"example\",\r\n  \"version\": \"0.0.1\",\r\n\r\n  \"runtime\": \"nodejs8\",\r\n  \"library\": \"./lib\",\r\n\r\n  \"secrets\": {\r\n    \"sec1\": {\r\n      \"source\" : \"./data/sec1\"\r\n    }\r\n  },\r\n\r\n  \"configs\": {\r\n    \"cfg1\": {\r\n      \"source\" : \"./data/cfg1\"\r\n    }\r\n  }\r\n}\r\n```\r\nIn addition to the unique object name, for example, `sec1` or `cfg1`, only one attribute is required:\r\n* __`source`__: relative path to the data directory\r\n\r\nThe data directory and its contained files define the data model and default values.\r\nAs the files will most likely show up in a git repository you may wish to see placeholder values first, later replaced (dynamically) by valid credentials, for instance.\r\n\r\nBoth tools, `faas-sdk` and `faas-cli`, support a simple mechanism for that: a deployment file with a predefined structure.\r\nTake this as an example:\r\n```yaml\r\nsecret-values:\r\n  sec1:\r\n    rv.json:\r\n      Info:\r\n        Success: Demo\r\n        Failure: Todo\r\n      Code:\r\n        Success: A\r\n        Failure: X\r\n    text: Nice Test!\r\n```\r\nHere, values are defined for secret `sec1`, and its two files `rv.json` and `text`.\r\nFor `json` or `yaml` files also single object attributes inside the file can be replaced. Arrays are handled as one value only.\r\nIn the case of other files e.g. text or binary data, the whole file content can be replaced.\r\n\r\nTo initialize such a deployment file based on specific secret definitions run inside the project:\r\n```bash\r\nfaas-sdk init-values -y values.yaml\r\n```\r\nThe command will search `faas.json` starting from the current working directory.\r\nOnce found it will add the content of secret and config map files to the deployment file `values.yaml`.\r\nAs no directory is specified it will be stored in folder `deploy` (to be ignored by git) next to `faas.json`.\r\n\r\nAfter adjusting the deployment file content you can start a local test run:\r\n```bash\r\nfaas-sdk run -y values.yaml\r\n```\r\n\r\nAnd for cloud deployment it can be used as well:\r\n```bash\r\nfaas-cli project deploy -y ./deploy/values.yaml -s my-cf-service -k my-cf-service-key\r\n```\r\n\r\nThese deployment files can also be used to define mock data for [function unit tests](#function-unit-tests).\r\n\r\n### Service References\r\n\r\nBesides the option to use secrets there is a more simple way to provide credentials of SAP CP platform services to functions or triggers.\r\nFirst, you can use the command line tool to transfer service keys to a secure store in the faas runtime:\r\n* Run ```cf login```\r\n* Run ```faas-cli login```\r\n* Run ```faas-cli service register -s <service-name> -b <service-key>```\r\n\r\nTo list all registered services (for your faas tenant, means service instance):\r\n* Run ```faas-cli service list```\r\n\r\nThen you can define in your project a service reference, for example to an enterprise messaging instance:\r\n```json\r\n{\r\n  \"services\": {\r\n    \"my-ems\": {\r\n      \"type\": \"enterprise-messaging\",\r\n      \"instance\": \"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\",\r\n      \"key\": \"xxx\"\r\n    }\r\n  }\r\n}\r\n```\r\nFinally, use the alias `my-ems` inside `faas.json` at trigger definitions and/or within function code.\r\nThe specific values of the reference can be provided with deploy values as well.\r\n\r\n### Functions\r\nLet's start with an example again:\r\n```json\r\n{\r\n  \"project\": \"example\",\r\n  \"version\": \"0.0.1\",\r\n\r\n  \"runtime\": \"nodejs8\",\r\n  \"library\": \"./lib\",\r\n\r\n  \"functions\": {\r\n    \"my-new-fnc\": {\r\n      \"module\" : \"index.js\",\r\n      \"handler\": \"\",\r\n      \"secrets\": [ \"sec-xbem\", \"sec-ebaas\" ],\r\n      \"configs\": [],\r\n      \"timeout\": 180,\r\n      \"maxBody\": \"1MiB\"\r\n    }\r\n  }\r\n}\r\n```\r\nIn addition to the unique object name `my-new-fnc` the following attributes can be provided:\r\n* __`module`__: source code file that exports the function handler (it may require other files of course)\r\n* __`handler`__: only needed if `module.exports` appears as an object where handler can be found as attribute\r\n* __`httpApi`__: indicates whether or not HTTP request and response are required by the function handler\r\n* __`secrets`__: array of secrets used by the function\r\n* __`configs`__: array of config maps used by the function\r\n* __`timeout`__: seconds the function can run, minimum between 10 and 180 seconds\r\n* __`maxBody`__: limit for body size (payload) of incoming requests provided to the function, default `1MiB`\r\n\r\nThe function handler may require built-in modules, further local module files or external packages.\r\nExternal dependencies (or devDependencies, for example for unit testing) are defined as usual in `package.json`.\r\n\r\nAn important entry in devDependencies is `@sap/faas`.\r\nIt allows the implementation of function unit tests.\r\nFurthermore, it offers type definitions that your local IDE may use for code proposals.\r\n```json\r\n{\r\n  \"dependencies\": {\r\n  },\r\n  \"devDependencies\": {\r\n    \"@sap/faas\": \">=0.7.6\"\r\n  }\r\n}\r\n```\r\n\r\nThe function handler in file `ìndex.js` may look like this:\r\n```javascript\r\n'use strict';\r\n\r\n/**\r\n * @namespace Faas\r\n * @typedef {import(\"@sap/faas\").Faas.Event} Faas.Event\r\n * @typedef {import(\"@sap/faas\").Faas.Context} Faas.Context\r\n */\r\n\r\n/**\r\n * @param {Faas.Event} event\r\n * @param {Faas.Context} context\r\n * @return {Promise<*>|*}\r\n */\r\nmodule.exports = function(event, context) {\r\n    const rval = context.getSecretValueJSON('sec1', 'rv.json');\r\n    return rval.Info.Success;\r\n};\r\n```\r\nPlease note how jsdoc annotations are used to declare the types.\r\nWith that IDE shall support you in finding methods and attributes of `event` and `context` while typing.\r\n\r\n## Function Triggers\r\nFunctions are invoked by triggers.\r\nA single function may be referenced by multiple trigger instances of different types.\r\nIn principle a single trigger may also invoke different functions, e.g. an AMQP trigger with multiple rules.\r\n\r\nThe following types are supported:\r\n* HTTP\r\n* Timer\r\n* AMQP\r\n* CloudEvents\r\n\r\nA first example shows how triggers are defined in principle within `faas.json`:\r\n```json\r\n{\r\n  \"project\": \"example\",\r\n  \"version\": \"0.0.1\",\r\n\r\n  \"runtime\": \"nodejs8\",\r\n  \"library\": \"./lib\",\r\n\r\n  \"functions\": {\r\n    \"my-new-fnc\": {\r\n      \"module\" : \"index.js\"\r\n    }\r\n  },\r\n\r\n  \"triggers\": {\r\n    \"demo\": {\r\n      \"type\": \"HTTP\",\r\n      \"function\": \"my-fnc-01\"\r\n    },\r\n    \"job1\": {\r\n      \"type\": \"Timer\",\r\n      \"schedule\": \"0/15 * * * *\",\r\n      \"function\": \"my-fnc-02\"\r\n    }\r\n  }\r\n\r\n}\r\n```\r\nTrigger `demo` will provide an HTTP endpoint.\r\nFor each received HTTP request the function `my-fnc-01` will be invoked.\r\nIn parallel trigger `job1` will call function `my-fnc-02` each quarter of an hour.\r\n\r\n### HTTP Trigger\r\n\r\nFor each trigger instance an external `HTTP` endpoint will be created.\r\nEach incoming request will be forwarded to the function, except those for method 'OPTIONS'.\r\nThe result of the function will be returned as response.\r\n\r\n__Attributes__:\r\n* __`function`__: the function to call\r\n\r\n__Example__:\r\n```json\r\n{\r\n  \r\n  \"triggers\": {\r\n    \"demo\": {\r\n      \"type\": \"HTTP\",\r\n      \"function\": \"my-new-fnc\"\r\n    }\r\n  }\r\n  \r\n}\r\n```\r\n\r\nBe aware that the endpoint is public visible.\r\nSo far authentication/authorization has to be handled by the function code.\r\nIt is planned to support automated oauth token validation in future.\r\n\r\n### Timer Trigger\r\n\r\nA single `Timer` trigger defines a schedule, optionally with timezone to call a selected function.\r\nDifferent schedule formats are supported:\r\n\r\n* simple duration\r\n  - every 1 minute and 30 seconds: `1m30s`,\r\n  - every 15 seconds `15s`,\r\n  - every 1 hour 30 minutes and 15 seconds: `1h30m15s`\r\n\r\n* cron expression, [spec conform](https://en.wikipedia.org/wiki/Cron), 5 fields\r\n  ```\r\n  ┌───────────── minute (0 - 59)\r\n  │ ┌───────────── hour (0 - 23)\r\n  │ │ ┌───────────── day of the month (1 - 31)\r\n  │ │ │ ┌───────────── month (1 - 12)\r\n  │ │ │ │ ┌───────────── day of the week (0 - 6) (Sunday to Saturday; 7 is also Sunday on some systems)\r\n  │ │ │ │ │\r\n\r\n  * * * * *\r\n  ```\r\n\r\n* cron expression, additional field for seconds, 6 fields\r\n  ```\r\n  ┌───────────── second (0 - 59)\r\n  │ ┌───────────── minute (0 - 59)\r\n  │ │ ┌───────────── hour (0 - 23)\r\n  │ │ │ ┌───────────── day of the month (1 - 31)\r\n  │ │ │ │ ┌───────────── month (1 - 12)\r\n  │ │ │ │ │ ┌───────────── day of the week (0 - 6) (Sunday to Saturday; 7 is also Sunday on some systems)\r\n  │ │ │ │ │ │\r\n\r\n  * * * * * *\r\n  ```\r\n\r\nTogether with cron expressions also a timezone can be of importance, typically when scheduling for hours.\r\nValid timezone values follow [Iana timezone database](https://www.iana.org/time-zones).\r\n\r\n__Attributes__:\r\n* __`schedule`__: duration or cron expression, which defines the execution interval\r\n* __`timezone`__: optional, timezone\r\n* __`function`__: the function to call\r\n\r\n__Examples for schedule and timezone__:\r\n\r\n| schedule | timezone | execution |\r\n|---|---|---|\r\n|`30s`            |             | every 30 seconds, start immediately, 10:15:12, 10:15:42, 10:16:12 ... |\r\n|`1h30m`          |             | every one and a half hour, 10:12:10, 11:42:10, 13:12:10, 14:42:10 ... |\r\n|`0 * * * *`      |             | each full hour                                                        |\r\n|`0/15 * * * *`   |             | each quarter of an hour                                               |\r\n|`0/15 * * * * *` |             | each 15 seconds, 10:00:00, 10:00:15, 10:00:30, 10:00:45, 10:01:00 ... |\r\n|`30 4 * * *`     |Asia/Tokyo   | each day 04:30, Tokyo time                                            |\r\n|`15 8 * * *`     |Europe/Berlin| each day 08:15, Berlin time                                           |\r\n|`20-24/2 * * * *`|             | each hour the 20th, 22nd and 24th minute                              |\r\n\r\nThe minimum interval of a timer is 1 second, runtime will either round up or raise an error if syntax is wrong.\r\nIf a function call takes longer than the scheduled interval, the timer will skip those calls and log this accordingly.\r\nIf a function can not be reached, the timer will repeat to try this a defined number of times with a growing delay.\r\n\r\nUpdates to timer definitions may require a timer restart, which may be of importance when scheduling hours or longer intervals.\r\nFor example, if you define a timer schedule of `1h` and change the timer 5 minutes before execution to `1h30m` you will have to wait full `1h30m` for the next call.\r\n\r\nA timer is restarted if `schedule` or `timezone` change, otherwise it is only updated, keeping the calculated point in time for the next execution.\r\n\r\n### AMQP Trigger\r\n\r\nThis trigger type invokes functions as message consumers.\r\nAs long business events are transported via messages the trigger can also be seen as a business event trigger.\r\n\r\nDepending on rules functions are selected based on message properties.\r\nThe function results can optionally be sent as new messages.\r\nIf the function execution fails the corresponding message can also be forwarded to an error topic.\r\n\r\nTechnically the trigger behaves like an [AMQP 1.0](https://www.amqp.org/resources/specifications) client.\r\nIt will connect to any peer either via WebSocket (with or without OAuth credentials flow) or via plain TCP, most likely using SASL credentials. \r\nUsually, the peer will be a message broker like Enterprise Messaging provides it for example.\r\n\r\n__Attributes__:\r\n* __`service`__: a service alias, it must be defined in the same project\r\n* __`secret`__: a secret that provides credentials to connect if no service reference is provided\r\n* __`config`__: a config map that provides the amqp link settings and binding rules\r\n\r\nUsually, the secret can be re-used by multiple triggers as it provides just connection data for a messaging broker.\r\nThe config map will be trigger specific, providing link settings (to address queues or topics) as well as binding rules.\r\n\r\n__Secret Entries__:\r\n* `dial` or `dial.json`: destination data like host, port, use of websocket or not, oauth credentials if needed\r\n* `sasl` or `sasl.json`: SASL mechanism (ANONYMOUS, PLAIN), corresponding parameters if plain TCP connections are used\r\n\r\n__Config Entries__:\r\n* `amqp` or `amqp.json`: definition of AMQP links and sessions to use, addresses, settle modes and so on \r\n* `bind` or `bind.json`: rules to select functions based on message properties and to specify result and error handling\r\n\r\nIt will be important to use a deployment file (values.yaml) to provide real credentials and settings for a specific deployment.\r\nThose data must not be stored in the secret and config defintion fields directly, as you probably will not wish to see it on git.\r\n\r\n### CloudEvents Trigger\r\n\r\nThis trigger allows you to subscribe CloudEvents and to define a rule-based function invocation.\r\nIt works similar to an AMQP trigger, but does not require secret or config map.\r\nInstead it is completely defined within `faas.json`.\r\nFurthermore, it will configure the messaging service automatically with the project deployment.\r\n\r\n```json\r\n{\r\n  \"functions\": {\r\n    \"ce-coffee-handler\": {\r\n      \"module\": \"index.js\",\r\n      \"services\": []\r\n    }\r\n  },\r\n  \"triggers\": {\r\n    \"my-ce\": {\r\n      \"type\": \"CloudEvents\",\r\n      \"service\": \"my-ems\",\r\n      \"rules\": [\r\n        {\r\n          \"ce-source\": \"\",\r\n          \"ce-type\": \"com.sap.coffee.required\",\r\n          \"function\": \"ce-coffee-handler\",\r\n          \"failure\": \"accept\"\r\n        },\r\n        {\r\n          \"ce-source\": \"\",\r\n          \"ce-type\": \"com.sap.coffee.produced\",\r\n          \"function\": \"ce-coffee-handler\",\r\n          \"failure\": \"accept\"\r\n        },\r\n        {\r\n          \"ce-source\": \"\",\r\n          \"ce-type\": \"com.sap.coffee.consumed\",\r\n          \"function\": \"ce-coffee-handler\",\r\n          \"failure\": \"accept\"\r\n        }\r\n      ]\r\n    }\r\n  }\r\n}\r\n```\r\nWhile deployment the referenced messaging service will be called to create a queue and topic subscriptions according to the given rules.\r\nFor one single message only one single rule is applied, the first that matches.\r\nCurrently SAP Enterprise Messaging is supported. The list may be extended according to development requests you raise.\r\n\r\n## Function Runtime API\r\nThe function handler is implemented as usual (anonymous) function, receiving two parameters: `event` and `context`.\r\nIt may return a simple value directly or a `Promise` to handle asynchronous execution.\r\nAs a consequence, `async` and `await` may be used as well.\r\n\r\n### Global Variables\r\nMultiple calls may arrive in parallel in one Node.js instance.\r\nEach call will be handled in a [sandbox](https://nodejs.org/docs/latest-v8.x/api/vm.html#vm_vm_runinnewcontext_code_sandbox_options).\r\nThis means global variables of the main file are never shared and never reused.\r\n\r\nHowever, the sandbox does not cover globals of any dependent file.\r\nHence, global variables in required modules must be handled with care if it cannot be avoided.\r\nValid examples for those globals could be:\r\n* A cache for access tokens, not retrieved for each single call\r\n* Protocol clients that manage a permanent network connection, e.g. to a message broker\r\n\r\nStill, there is no guarantee that a Node.js instance is running for a certain time,\r\nbut in fact such a cache or reused client will be reused many times and will improve overall performance significantly.\r\n\r\n### Handler Exceptions\r\nThe function code can throw an exception at any point in time to stop processing unexpected internal state.\r\nIn this case an HTTP caller for example will receive response status code 500 (internal server error) only.\r\nError details will be added to the function log.\r\n`faas-cli` can be used to retrieve log entries.\r\n\r\n### Handler Parameter: __event__\r\nProvides attributes and methods related to a single function invocation.\r\n\r\n__Attributes__:\r\n* __`auth`__: authorization data\r\n  * __`type`__: first part of HTTP authorization header, e.g. `Basic`, `Bearer`, ..: \r\n  * __`credentials`__: plain data corresponding to `type`\r\n* __`ce`__: [cloud event context attributes](https://github.com/cloudevents/spec/blob/v0.2/spec.md#context-attributes), only defined if available\r\n  * __`specVersion`__: version of the CloudEvents specification which the event uses\r\n  * __`source`__: event producer `\"sap/app/01\"`\r\n  * __`type`__: event type, e.g. `\"sap.common.alert\"`\r\n  * __`id`__: ID of the event\r\n  * __`subject`__: subject of the event\r\n  * __`time`__: timestamp of when the event happened\r\n  * __`dataContentType`__: data encoding format\r\n  * __`dataSchema`__: link to the schema that the data attribute adheres to\r\n  * __`data`__: event payload, please note `event.ce.data` will always be equal to `event.data`\r\n  * __`extensions`__: additional metadata not covered by the specification\r\n* __`data`__: payload data (HTTP body) related to invocation, depending on the received content type, either `string`, `Buffer` or `Object`, data can always be found here, with or without cloud event.\r\n* __`http`__: only defined if explicitly requested, provides access to HTTP `request` and `response` if available\r\n\r\n__Methods__:\r\n* __`decodeJsonWebToken():{ header: object, payload: object, signature: string }`__:\r\nDecodes event credentials as JSON WebToken (JWT).\r\nReturns `null` if the mechanism is not 'Bearer' or if the token has no valid JWT structure.\r\nDoes not validate the token signature, as this has been done by the calling trigger already.\r\nThe token itself is provided in field `event.auth.credentials`.\r\n* __`decodeUserPassword():{ user: string, password: string }`__:\r\nDecodes event credentials as basic authentication data.\r\nReturns `null` if the mechanism is not 'Basic' or if the credentials do not match the expected structure.\r\nDoes not validate the credentials against any provider, as this will be function logic already.\r\n* __`setBadRequest()`__:\r\nSets the event status to `bad request`.\r\nEvent will not be processed, handler may still add data to the response, for example as hint. \r\nIn contrast, throwing any error would be treated as internal error.\r\n* __`setUnauthorized()`__:\r\nSets the event status to `unauthorized`.\r\nEvent will not be processed, handler may still add data to the response, for example as hint.\r\nIn contrast, throwing any error would be treated as internal error.\r\n* __`getContentType():string`__:\r\nProvides the received content type.\r\nIn the case of cloud events it will be taken from the event itself.\r\nData are provided accordingly, this means as object in case of `json`-format or as string or Buffer otherwise.\r\n* __`setResponseType(string)`__:\r\nDefines the response content type explicitly.\r\nOtherwise callers' accepted types will be compared with the return data type and best matches will be used.\r\nFallback strategy is based on the returned data type only.\r\n* __`getResponseStream(contentType):WritableStream`__:\r\nThe response content type is defined and the corresponding stream is returned.\r\nIt is possible to write data directly to the stream or to pipe data from other streams.\r\nThe function handler shall return a `Promise` to the runtime to indicate the asynchronous end of processing.\r\n* __`sendResponseEvent(ce)`__:\r\nThe cloud event is returned as result of function execution.\r\nHttp-Triggers would return it to the caller.\r\nAMQP or CE trigger can send the event, depending on its configuration. Source will be adjusted.\r\n\r\nIf the function returns a simple value without defining the content type, a matching response content type will be selected automatically.\r\nAnd if the client was sending an HTTP request with `Accept` header this will also be taken into account.\r\n\r\n### Handler Parameter: __context__\r\nProvides attributes and methods related to the current process.\r\n\r\n__Attributes__:\r\n* __`funcName`__: function name\r\n* __`timeoutMS`__: milliseconds that the function is allowed to run\r\n\r\n__Methods__: (runtime nodejs8 provides the same methods, but __not__ async)\r\n* __`async getServiceCredentials(faas-json-alias)`__: provides service credentials as binary data (Buffer)`\r\n* __`async getServiceCredentialsString(faas-json-alias)`__: provides service credentials as text`\r\n* __`async getServiceCredentialsJSON(faas-json-alias)`__: provides service credentials as parsed JSON data`\r\n* __`async getSecretValueStream(name, key)`__: provides secret value stream\r\n* __`async getSecretValue(name, key)`__: provides secret value as binary data (Buffer)\r\n* __`async getSecretValueString(name, key)`__: provides secret value as text\r\n* __`async getSecretValueJSON(name, key)`__: provides secret value as parsed JSON data\r\n* __`async getSecretValueYAML(name, key)`__: provides secret value as parsed YAML data\r\n* __`async getConfigValueStream(name, key)`__: provides config value stream\r\n* __`async getConfigValue(name, key)`__: provides config value as binary data (Buffer)\r\n* __`async getConfigValueString(name, key)`__: provides config value as text\r\n* __`async getConfigValueJSON(name, key)`__: provides config value as parsed JSON data\r\n* __`async getConfigValueYAML(name, key)`__: provides config value as parsed YAML data\r\n* __`async callFunction(name, content): response`__:\r\nCalls another function by `name` within the same __K8s__ namespace,\r\n`content.data` provides the request payload, `content.type` the request content type.\r\n`response.data` contains the received payload, `response.type` the received content type.\r\nSpecial handling with runtime `nodejs8`: the method accepts a JsCallback as third parameter or returns a promise otherwise.\r\n* __`getFunctionEndpoint(name):string`__: Only available with enabled HTTP API,\r\nexpects a function name (inside the same __K8s__ namespace) and returns the corresponding HTTP endpoint.\r\n\r\nThe object is reused for all function calls within the current Node.js instance,\r\nbut attributes must not be changed.\r\n\r\n## Function Test\r\nThe following command runs all functions of a project locally:\r\n```bash\r\nfaas-sdk run -r 7777 -y values.yaml\r\n```\r\nIt will search `faas.json` starting from the current working directory.\r\nAfter reading all declarations one HTTP server starts listening at the given port.\r\nThe URL for each function is printed to the console.\r\n\r\nEach function will find the same environment like in the cloud later on.\r\nUse any HTTP client or just a Web browser to call it.\r\n\r\n## Function Debugging\r\nTo debug function code in a local IDE, usually a debug configuration is needed:\r\n* Install `@sap/faas` as devDependency.\r\n* Create a debug configuration in your local IDE for Node.js.\r\n* Use `./node_modules/@sap/faas/lib/cli.js` as file to execute.\r\n* Use `run` as cli argument.\r\n* Use this directory or just another underneath `faas.json` as working directory.\r\n* Set break points and invoke a function via browser or HTTP client.\r\n\r\n## Function Unit Tests\r\nFinally, also unit tests for functions can be implemented. Here, `@sap/faas` provides a test method.\r\nIt will do the following:\r\n* Start an HTTP server as described before.\r\n* Execute the provided test callback.\r\n* Shut down the server afterwards.\r\n\r\nAs entry point the same [`context`](#handler-parameter:-context) object is provided that functions see at runtime.\r\nIt allows to call functions and to read secret or config map values, at this point of course starting from the local files.\r\nA deployment file can be provided to apply mock data.\r\n\r\nThe following example uses a well-known test framework, even if `@sap/faas` does not enforce its usage.\r\n```javascript\r\n/*jshint mocha:true*/\r\n'use strict';\r\n\r\nconst assert = require('assert');\r\nconst faas = require('@sap/faas');\r\n\r\ndescribe('hello secret example', () => {\r\n\r\n//  ************************************************************************************************\r\n\r\n    it('using default values', (done) => {\r\n        faas.test(done,\r\n            {\r\n            },\r\n            async (context) => {\r\n                const result = await context.callFunction('hello-secret', {});\r\n                assert.equal(result.type, 'text/plain; charset=utf-8');\r\n                assert.equal(result.data, 'Demo');\r\n            }\r\n        );\r\n    });\r\n\r\n//  ************************************************************************************************\r\n\r\n    it('using deploy values', (done) => {\r\n        faas.test(done,\r\n            {\r\n                'deploy-values': '../mock/values.yaml'\r\n            },\r\n            async (context) => {\r\n                const result = await context.callFunction('hello-secret', {});\r\n                assert.equal(result.type, 'text/plain; charset=utf-8');\r\n                assert.equal(result.data, 'Nice Test!');\r\n            }\r\n        );\r\n    });\r\n\r\n//  ************************************************************************************************\r\n\r\n    it('read secret text', (done) => {\r\n        faas.test(done,\r\n            {\r\n            },\r\n            async (context) => {\r\n                assert.equal(context.getSecretValueString('sec1', 'text'), 'Hello World!');\r\n            }\r\n        );\r\n    });\r\n\r\n//  ************************************************************************************************\r\n\r\n    it('read secret json', (done) => {\r\n        faas.test(done,\r\n            {\r\n            },\r\n            async (context) => {\r\n                assert.deepStrictEqual(context.getSecretValueJSON('sec1', 'rv.json'), {\r\n                    \"Info\": {\r\n                        \"Success\": \"Demo\",\r\n                        \"Failure\": \"Todo\"\r\n                    },\r\n                    \"Code\": {\r\n                        \"Success\": \"A\",\r\n                        \"Failure\": \"X\"\r\n                    }\r\n                });\r\n            }\r\n        );\r\n    });\r\n\r\n//  ************************************************************************************************\r\n\r\n});\r\n```\r\n\r\n"}]