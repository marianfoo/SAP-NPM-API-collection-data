[{"name":"CHANGELOG.md","content":"# Change Log\r\nAll notable changes to this project will be documented in this file.\r\n\r\n## 3.2.13 - 2022-02-15\r\n- hofix in keycache implementation if you turn off to use the cache\r\n- upgrade to newer axios library\r\n\r\n## 3.2.12 - 2022-01-19\r\n- add support for UAA system plan \r\n- upgrade to newer axios library\r\n\r\n## 3.2.11 - 2021-11-30\r\n- add support for timeout setting for all requests-calls \r\n- support for password token flow in requests module\r\n- support for setting scopes for all requests to XSUAA\r\n## 3.2.10 - 2021-11-02\r\n- fix correlationID header names to \"x-vcap-request-id\" or \"x-correlationid\"\r\n\r\n## 3.2.9 - 2021-10-22\r\n- custom domain support for IAS\r\n- support for \"x-correlation-id\" header to be set for createSecurityContext and tokenexchange-calls\r\n- support to turn off the internal cache for a createSecurityContext call\r\n\r\n## 3.2.8 - 2021-10-18\r\n- add additional getter for user properties on XSUAA context\r\n- remove deed and unneeded code for IAS context\r\n- fix token flows in requests if subdomain is provided using certificate\r\n\r\n## 3.2.7 - 2021-09-15\r\n- replace got with axios library because of a bug in got lib during https get\r\n\r\n## 3.2.5 - 2021-09-07\r\n- fix to be backward-compatible for tokenFlow-APIs\r\n\r\n## 3.2.4 - 2021-09-03\r\n- fix an issue with IAS multitenancy support\r\n- remove the deprecated request library with got library\r\n\r\n## 3.2.3 - 2021-08-23\r\n- add checkFollowingInstanceScope to SecurityContext to retrieve instance specific scope without need to build scope string on your own\r\n- fix a reference error in key verification\r\n- support for multitenance IAS applications using 'x-zone_uuid' Header in jwks call\r\n\r\n## 3.2.2 - 2021-06-16\r\n- Support for tokenexchanges with X.509 certificates managed by XSUAA\r\n- Support for tokenexchanges with manually managed X.509 certificates\r\n- support for configuration objects that does not provide a clientsecret (but a certificate)\r\n\r\n## 3.2.1 - 2021-06-01\r\n- Add some more error and tracing information\r\n\r\n## 3.2.0 - 2021-04-20\r\n- Support for IAS token validation. ([more details](doc/IAS.md))\r\n\r\n## 3.1.2 - 2021-03-01\r\n- Feature: Support for IAS to XSUAA token exchange ([more details](doc/IAStoXSUAA.md))\r\n- Feature: Support for ZoneID enabled token flows ([more details](doc/TokenFlows.md))\r\n\r\n\r\n## 3.1.1 - 2021-02-11\r\n- Bugfix: Tokenexchange with additional attributes may result in a wrong formatted url\r\n- Feature: The passport middleware allows to provide scopes to be validated at authentication time. Details [here](http://www.passportjs.org/docs/oauth/#scope)\r\n\r\n## 3.1.0 - 2021-02-10\r\n- Support for multiple configurations for one security context ([more details here](doc/MultiConfiguration.md))\r\n- Bugfix: support for additional attributes in token exchange\r\n- Bugfix: authorization now in payload for better XSUAA support\r\n- correct support for azp (clientid) in token payload\r\n- method to identify an XSUAA token\r\n\r\n## 3.0.10 - 2021-10-01\r\n- The requests to the XSUAA are now available using the requests module also if you do not have a securityContext\r\n\r\n## 3.0.9 - 2020-08-06\r\n- Set request library to version 2.88.2 because of security vulnerability\r\n\r\n## 3.0.8 - 2020-08-06\r\n- Increase timeout for jwt-bearer token flow to reduce of timeouts with very big tokens.\r\n\r\n## 3.0.7 - 2020-07-24\r\n- Move the token to the request body for jwt-bearer token flow, because of problems with very big tokens\r\n\r\n## 3.0.6 - 2020-07-01\r\n- Audience Validation validates to true when the derived client_id of broker-clone token matches the trusted client. This is relevant to support tokens of grant type user_token that contains no scopes.\r\n\r\n## 3.0.5 - 2020-06-26\r\n- Audience Validation accepts tokens of grant type user_token that does not provide aud claim. In that case the audience is derived from the audiences from the scopes.\r\n- Audience Validation is skipped when cid of token matches the trusted client.\r\n- Use getSubaccountId() method only to fetch the subaccount id, e.g. for calling the metering API for user-based pricing.\r\n- In case you are interested in the customers tenant GUID make use of getZoneId method instead!\r\n- A new [TokenInfo](/doc/TokenInfo.md) class is introduced for better logging capabilities.\r\n\r\n## 3.0.3 - 2020-05-25\r\n\r\n- Fix jwt-bearer flow to take the right token as uri parameter.\r\n\r\n## 3.0.2 - 2020-05-20\r\n\r\n- Fix get verification key from keycache.\r\n\r\n## 3.0.1 - 2020-05-19\r\n\r\n- HotFix missing debugTrace in verification key\r\n- Fix RetryStrategy\r\n\r\n## 3.0.0 - 2020-05-15\r\n\r\n- Replace grant type user_token in method requestToken (TYPE_USER_TOKEN) in favor of urn:ietf:params:oauth:grant-type:jwt-bearer\r\n- Remove obsolete method getToken (use getHdbToken or getAppToken))\r\n- Remove obsolete method requestTokenForClient (use requestToken)\r\n- Remove obsolete method getIdentityZone (use getZoneId() instead, or getSubaccountId() for metering purposes) \r\n- Support for audience validation in token\r\n- remove of SAP_JWT_TRUST_ACL environment variable support (functionality now comes with audience validation); see also [here](https://jam4.sapjam.com/blogs/show/oEdyQO183plBoQdrvcPw2w).\r\n- remove depencency to node-jwt (ALPINE support)\r\n- restructure internal code for better maintainability\r\n\r\n## 2.2.5 - 2020-02-28\r\n\r\n- Update to node-jwt version 1.6.6\r\n\r\n## 2.2.4 - 2019-08-14\r\n\r\n- Support for API methods getUserName and getUniquePrincipalName\r\n \r\n## 2.2.3 - 2019-08-07\r\n\r\n- Add retry for recieving keys\r\n\r\n## 2.2.2 - 2019-06-24\r\n\r\n- Use verification key from binding as backup if online key retrieval fails\r\n\r\n## 2.2.1 - 2019-06-17\r\n\r\n- Fix uaaDomain comparison in key cache\r\n\r\n## 2.2.0 - 2019-06-17\r\n\r\n- Align key cache implementation with other container security libraries\r\n\r\n## 2.1.17 - 2019-05-17\r\n\r\n- Introduce http timeout of two seconds\r\n- Update version of module debug, lru-cache and @sap/xsenv\r\n- Fix token verification for broker master instance subscriptions\r\n\r\n## 2.1.16 - 2019-01-28\r\n\r\n- Fix token parser: switch ASCII to Utf8 decode\r\n\r\n## 2.1.15 - 2018-08-13\r\n\r\n- Update version of module request\r\n\r\n## 2.1.14 - 2018-07-24\r\n\r\n- Evaluate SAP_JWT_TRUST_ACL if trustedclientidsuffix is present but not matching\r\n\r\n## 2.1.13 - 2018-07-18\r\n\r\n- Update version of module request\r\n\r\n## 2.1.12 - 2018-06-01\r\n\r\n- Support for API methods getSubaccountId and getOrigin\r\n- Mark API method getIdentityZone as deprecated\r\n\r\n## 2.1.11 - 2018-05-18\r\n\r\n- Update version of module request\r\n\r\n## 2.1.10 - 2018-04-20\r\n\r\n- Fixes for keycache\r\n\r\n## 2.1.9 - 2018-04-18\r\n\r\n- Update version of module @sap/node-jwt (1.4.8)\r\n- Fixes for keycache\r\n- Update version of module request\r\n\r\n## 2.1.8 - 2018-03-14\r\n\r\n- Support for API method getAppToken\r\n\r\n## 2.1.7 - 2018-03-05\r\n\r\n- Support for API method requestToken\r\n\r\n## 2.1.6 - 2018-02-19\r\n\r\n- Update version of module @sap/node-jwt\r\n\r\n## 2.1.5 - 2018-02-07\r\n\r\n- Update version of module request\r\n\r\n## 2.1.4 - 2017-12-04\r\n\r\n- Support new JWT structure (attribute location ext_cxt)\r\n- First implementation for keycache\r\n\r\n## 2.1.3 - 2017-11-29\r\n\r\n- Support for API method getClientId\r\n\r\n## 2.1.2 - 2017-10-23\r\n\r\n- Support for API method getSubdomain\r\n\r\n## 2.1.1 - 2017-10-09\r\n\r\n- Update version of modules @sap/node-jwt, @sap/xsenv and debug\r\n\r\n## 2.1.0 - 2017-07-06\r\n\r\n- Support of API method requestTokenForClient\r\n- Update version of module @sap/node-jwt\r\n\r\n## 2.0.0 - 2017-06-26\r\n\r\n- Removal of deprecated constructor method createSecurityContextCc\r\n- Removal of API method method getUserInfo\r\n\r\n## 1.3.0 - 2017-06-23\r\n\r\n- Revert removal of API method method getUserInfo\r\n\r\n## 1.2.0 - 2017-06-22\r\n\r\n- Support for API methods getLogonName, getGivenName, getFamilyName, getEmail\r\n- Removal of API method method getUserInfo\r\n- Fix identity zone validation (only relevant for tenants created with SAP Cloud Cockpit)\r\n\r\n## 1.1.1 - 2017-05-30\r\n- Update version of dependent modules\r\n\r\n## 1.1.0 - 2017-05-22\r\n- Mark API method createSecurityContextCC as deprecated\r\n\r\n## 1.0.4 - 2017-05-17\r\n\r\n- Support for validation of XSUAA broker plan tokens\r\n- Support for API methods getCloneServiceInstanceId and getAdditionalAuthAttribute\r\n- Support for validation of XSUAA application plan tokens in arbitrary identity zones\r\n\r\n## 1.0.3 - 2017-03-29\r\n\r\n- Update version of dependent modules\r\n\r\n## 1.0.2 - 2017-02-22\r\n\r\n- Support for validation of SAML Bearer tokens\r\n\r\n## 1.0.1 - 2017-02-02\r\n\r\n- Support for client credentials tokens in JWT strategy\r\n\r\n## 1.0.0 - 2017-01-25\r\n\r\n- Introduction of scopeing, module name changed to @sap/xssec\r\n"},{"name":"doc","nodes":[{"name":"doc","nodes":[{"name":"IAS.md","content":"# IAS Support\r\n\r\nSince version 3.2.0 you can configure a security context with an IAS configuration and validate IAS tokens.\r\nBut keep in mind that IAS tokens do NOT have all features of an XSUAA token. For example there is NO scope checks possible with an IAS token.\r\n\r\n\r\n### How to use this feature\r\nThe integration of IAS support is straightforward\r\n\r\n#### If you create the SecurityContext on your own\r\n```js\r\nconst config_ias = xsenv.getServices({ias:{tag:'ias'}}).ias;\r\n\r\nxssec.createSecurityContext(access_token, config_ias, \"IAS\", function(error, securityContext, tokenInfo) {\r\n    //...\r\n});\r\n\r\n//the string \"IAS\" as the third parameter is optional. \r\n//But then you make sure, that only a valid IAS configuration can be configured!\r\n//you can also do this:\r\n\r\nxssec.createSecurityContext(access_token, config_ias, function(error, securityContext, tokenInfo) {\r\n    //...\r\n});\r\n\r\n//now the library checks if there is a \"xsappname\" entry in the configuration to identify an XSUAA config.\r\n//otherwise it will considered to be an IAS config.\r\n\r\n```\r\n\r\n#### If you use the passport library. \r\nFor the passport library the integration is also very simple.\r\n\r\n```js\r\nconst config_ias = xsenv.getServices({ias:{tag:'ias'}}).ias;\r\n\r\npassport.use(new JWTStrategy(config_ias, \"IAS\"));\r\n\r\n//or (same as mentioned above)\r\npassport.use(new JWTStrategy(config_ias));\r\n\r\n\r\napp.use(passport.initialize());\r\n\r\n//and so on\r\n```\r\n\r\n#### Support for both configurations in ONE context\r\nCurrently there is no support to configure the security context for XSUAA andd IAS together and then decide which config to used based on the token.\r\nIf you need such feature feel free to open an issue, so we can discuss the details.\r\n"},{"name":"IAStoXSUAA.md","content":"# IAS to XSUAA Token exchange\r\n\r\nWith version 3.1.2 we support the automatic exchange of an IAS token to a XSUAA token.\r\nThis happens inside the creation of the security context.\r\nCurrently there is no cache functionality implemented. This is planned for the next release. \r\n\r\nClick [here](https://github.com/SAP/cloud-security-xsuaa-integration/blob/master/docs/IAS-XSUAA-token-xchange.md) for more details about this.\r\n\r\n### How to use this feature\r\n\r\nThis feature is turned on by default, there are no additional steps required to set it up.\r\nIf you create a securityContext with an IAS token, this will be exchanged to an XSUAA token internally.\r\nFor this an extra REST call to the XSUAA is needed. (currently there is no cache. But will come soon)\r\n\r\n### How to disable this feature \r\nIf you don't want to convert an IAS token to a XSUAA token, you can simply disable token exchange by setting flag 'IAS_XSUAA_XCHANGE_ENABLED' to false.\r\nKeep in mind, that this configuration setting is application wide. You can't turn this off only for a specific security context.\r\n\r\nSo this flag will also work for the passport integration.\r\n\r\n```js\r\nconst xssec = require('@sap/xssec');\r\n\r\n//turn off the automatic exchange\r\nxssec.config[\"IAS_XSUAA_XCHANGE_ENABLED\"] = false;\r\n\r\n//and so on\r\n```\r\n\r\n### Full IAS support\r\nSince version 3.2.0 the library can validate and verify IAS tokens directly. Have a look [here](IAS.md) for more details."},{"name":"MultiConfiguration.md","content":"# SecurityContext with multiple configurations\r\n\r\nThere are scenarios, where you need to \"feed\" the audience validator with 2 or more different configurations.\r\nFor example if you have a REST API that is called from two different XSUAA bindings.\r\n\r\nSince version 3.1.0 we support to have 2 or ServiceBinding configurations for one SecurityContext.\r\n\r\n\r\n### How to use this feature\r\nJust pass an array of configuration objects to the method instead of a single object.\r\nThis feature is fully backward compatible. So you can pass an array or a simple object to the method.\r\n\r\n#### If you create the SecurityContext on your own\r\n```js\r\nconst config1 = xsenv.getServices({xsuaa:{tag:'xsuaa'}}).xsuaa;\r\nconst config2 = xsenv.getServices({xsuaa:{tag:'xsuaaB'}}).xsuaaB;\r\n\r\nxssec.createSecurityContext(access_token, [config1, config2], function(error, securityContext, tokenInfo) {\r\n    //...\r\n});\r\n```\r\n\r\n#### If you use the passport library. \r\nFor the passport library the integration is also very simple.\r\n\r\n```js\r\nconst config1 = xsenv.getServices({xsuaa:{tag:'xsuaa'}}).xsuaa;\r\nconst config2 = xsenv.getServices({xsuaa:{tag:'xsuaaB'}}).xsuaaB;\r\n\r\npassport.use(new JWTStrategy([config, config2]));\r\n\r\napp.use(passport.initialize());\r\n\r\n//and so on\r\n```\r\n"},{"name":"TokenFlows.md","content":"# How to directly intiate token flows\r\n\r\nThere is a method ```requestToken()``` in the securityContext object. \r\nWith this you can call ClientCredentials or the JWT Bearer tokenflow in the scope of the securityContext.\r\n\r\nBut sometimes you want to do a ClientCredentials or a JWT Bearer tokenflow without creating a SecurityContext first. Since version 3.1.0 this is possible.\r\n\r\n### Obtaining the request object\r\nThe library now exports the request object.\r\n\r\n```js\r\nconst xssec = require('@sap/xssec');\r\nconst requests = xssec.requests;\r\n```\r\n\r\n#### JWT Bearer token flow\r\n```js\r\nrequests.requestUserToken(appToken, serviceCredentials, additionalAttributes, scopes, subdomain, zoneId, cb);\r\n// appToken: your current token \r\n// serviceCredentials: the service credentials. (the config object from environment)\r\n// additionalAttributes: object if you need to set additional attributes (or null)\r\n// scopes: object if you need to set scopes (or null)\r\n// subdomain: The subdomain of the xsuaa instance (or null)\r\n// ?zoneId: sometimes you do not know the subdomain. Then you have to set the zoneID (optional)\r\n// cb: the callback function cb(err, encodedTokenAsString)\r\n```\r\n\r\n#### Client Credentials flow\r\n```js\r\nrequests.requestClientCredentialsToken(subdomain, serviceCredentials, additionalAttributes, zoneId, cb);\r\n// subdomain: The subdomain of the xsuaa instance (or null)\r\n// serviceCredentials: the service credentials. (the config object from environment)\r\n// additionalAttributes: object if you need to set additional attributes (or null)\r\n// ?zoneId: sometimes you do not know the subdomain. Then you have to set the zoneID (optional)\r\n// cb: the callback function cb(err, encodedTokenAsString)\r\n```\r\n\r\n#### Password Token flow\r\n```js\r\nrequests.requestPasswordUserToken(subdomain, serviceCredentials, additionalAttributes, cb);\r\n// subdomain: The subdomain of the xsuaa instance (or null)\r\n// serviceCredentials: the service credentials. (the config object from environment)\r\n// additionalAttributes: object if you need to set additional attributes (or null)\r\n// cb: the callback function cb(err, encodedTokenAsString)\r\n```"},{"name":"TokenInfo.md","content":"# TokenInfo\r\n\r\nSince version 3.0.4 we have the TokenInfo object in the xssec library.\r\nThis is a wrapper around all the information the token contains.\r\n\r\n## Security Note\r\n\r\nDo not simply rely on the information within the token!\r\nThe webapplication normally receives the token with the HTTP Request from \"outside\" the application.\r\nSo there is a deep parameter validation needed! \r\n\r\n*Also if the token is signed, it may also contain dangerous information.*\r\n\r\n### How to get the TokenInfo object\r\nThere are several ways to get the TokenInfo.\r\nIf an error occurs NO security context is created. But the [TokenInfo](doc/TokenInfo.md) object is available, so you can do some logging.\r\n\r\n#### If you create the SecurityContext on your own\r\n```js\r\nxssec.createSecurityContext(access_token, config, function(error, securityContext, tokenInfo) {\r\n    if (error) {\r\n        console.log('tokenInfo is also available if you have an error', tokenInfo.getPayload())\r\n        return;\r\n    }\r\n    console.log('Security Context created successfully', tokenInfo.getPayload());\r\n    console.log('You can also retrieve it from the SecurityContext', securityContext.getTokenInfo());\r\n});\r\n```\r\n\r\n#### If you use the passport library. \r\nThe ``tokenInfo`` object is attached to the ``request`` object in the JWTStrategy middleware. ([more here](../README.md#api-description))\r\nOnly if the middleware could not find a bearer token in the HTTP header, there is no ``tokenInfo`` object created.\r\n\r\nThe documentation for a default error handler in express you find [here](https://expressjs.com/en/guide/error-handling.html)\r\n\r\n```js\r\npassport.use(new JWTStrategy(config));\r\n\r\napp.use(passport.initialize());\r\n\r\n//don't forget to set failWithError to true.\r\n//Otherwise the errorHandler will not be called\r\napp.use(passport.authenticate('JWT', { session: false, failWithError: true })); \r\n\r\n// simple express Error Handler\r\napp.use(function(err, req, res, next) {\r\n  //be aware that the error handler is not only for the passport errors!\r\n  var tokenInfo = req.tokenInfo;\r\n  if(tokenInfo) {\r\n    //err is exception thrown but not the error of the tokenValidation\r\n    //to get the errorObject from xsuaa\r\n    var xserror = tokenInfo.getErrorObject()  \r\n    \r\n    //to the logging\r\n    console.error(xserr, tokenInfo.getPayload());\r\n  }\r\n  \r\n  res.status(err.status);\r\n  res.send(err.message);\r\n});\r\n```\r\n\r\n## API Description\r\n\r\n### TokenInfo(encoded_token)\r\n\r\nCode says more than words :-)\r\n\r\n```js\r\nvar tokenInfo = new TokenInfo(encodedTokenAsString);\r\n\r\n///// Get the Token-information as a whole\r\nvar payload = tokenInfo.getPayload(); //Get the token payload\r\nvar header = tokenInfo.getHeader();   //Get the token header\r\nvar encoded = tokenInfo.getTokenValue(); //returns the encoded token string\r\n\r\nvar exp = tokenInfo.getExpirationDate(); //returns a Date object or null if not available\r\nvar iat = tokenInfo.getIssuedAt(); //returns a Date object or null if not available\r\nvar iss = tokenInfo.getIssuer(); //returns a string or null if not available\r\n\r\nvar is_xsuaa = tokenInfo.isTokenIssuedByXSUAA(); //returns true, if the token is a XSUAA token\r\n\r\n///// Error Handling\r\ntokenInfo.isDecoded(); //returns true, if a token could be decoded\r\ntokenInfo.isValid();    //returns true, if no error object is attached\r\n\r\ntokenInfo.getErrorObject(); //return the error object if there is one\r\n\r\n\r\n///// Verification of an encoded token\r\n\r\n//you can pass a key Callback to retrieve the key asyncronously\r\nfunction getKeyCB(header, callback) {\r\n  client.getSigningKey(header.kid, function(err, key) {\r\n    var signingKey = key.publicKey || key.rsaPublicKey;\r\n    callback(null, signingKey);\r\n  });\r\n}\r\n\r\ntokenInfo.verify(getKeyCB, function(err, tokenInfo) {\r\n    if(err) {\r\n        console.error(err.errorCode, err.message);\r\n        console.error(err.stack);\r\n\r\n        //tokenInfo is also available, if there was a verification error.\r\n        console.log(tokenInfo.getPayload());\r\n    } else {\r\n        //yeah, it was verified\r\n        ...\r\n    }\r\n});\r\n\r\n//instead of a callback you can directly give the verification key to the function\r\ntokenInfo.verify(\"123456\", function(err, tokenInfo) {\r\n    ...\r\n});\r\n\r\n```\r\n\r\n### Future Plans\r\nWe have plans to provide some more functionality here in the future:\r\n\r\n* provide not only verify, but also sign functionality\r\n* easy create tokens for unittesting"}]},{"name":"IAS.md","content":"# IAS Support\r\n\r\nSince version 3.2.0 you can configure a security context with an IAS configuration and validate IAS tokens.\r\nBut keep in mind that IAS tokens do NOT have all features of an XSUAA token. For example there is NO scope checks possible with an IAS token.\r\n\r\n\r\n### How to use this feature\r\nThe integration of IAS support is straightforward\r\n\r\n#### If you create the SecurityContext on your own\r\n```js\r\nconst config_ias = xsenv.getServices({ias:{tag:'ias'}}).ias;\r\n\r\nxssec.createSecurityContext(access_token, config_ias, \"IAS\", function(error, securityContext, tokenInfo) {\r\n    //...\r\n});\r\n\r\n//the string \"IAS\" as the third parameter is optional. \r\n//But then you make sure, that only a valid IAS configuration can be configured!\r\n//you can also do this:\r\n\r\nxssec.createSecurityContext(access_token, config_ias, function(error, securityContext, tokenInfo) {\r\n    //...\r\n});\r\n\r\n//now the library checks if there is a \"xsappname\" entry in the configuration to identify an XSUAA config.\r\n//otherwise it will considered to be an IAS config.\r\n\r\n```\r\n\r\n#### If you use the passport library. \r\nFor the passport library the integration is also very simple.\r\n\r\n```js\r\nconst config_ias = xsenv.getServices({ias:{tag:'ias'}}).ias;\r\n\r\npassport.use(new JWTStrategy(config_ias, \"IAS\"));\r\n\r\n//or (same as mentioned above)\r\npassport.use(new JWTStrategy(config_ias));\r\n\r\n\r\napp.use(passport.initialize());\r\n\r\n//and so on\r\n```\r\n\r\n#### Support for both configurations in ONE context\r\nCurrently there is no support to configure the security context for XSUAA andd IAS together and then decide which config to used based on the token.\r\nIf you need such feature feel free to open an issue, so we can discuss the details.\r\n"},{"name":"IAStoXSUAA.md","content":"# IAS to XSUAA Token exchange\r\n\r\nWith version 3.1.2 we support the automatic exchange of an IAS token to a XSUAA token.\r\nThis happens inside the creation of the security context.\r\nCurrently there is no cache functionality implemented. This is planned for the next release. \r\n\r\nClick [here](https://github.com/SAP/cloud-security-xsuaa-integration/blob/master/docs/IAS-XSUAA-token-xchange.md) for more details about this.\r\n\r\n### How to use this feature\r\n\r\nThis feature is turned on by default, there are no additional steps required to set it up.\r\nIf you create a securityContext with an IAS token, this will be exchanged to an XSUAA token internally.\r\nFor this an extra REST call to the XSUAA is needed. (currently there is no cache. But will come soon)\r\n\r\n### How to disable this feature \r\nIf you don't want to convert an IAS token to a XSUAA token, you can simply disable token exchange by setting flag 'IAS_XSUAA_XCHANGE_ENABLED' to false.\r\nKeep in mind, that this configuration setting is application wide. You can't turn this off only for a specific security context.\r\n\r\nSo this flag will also work for the passport integration.\r\n\r\n```js\r\nconst xssec = require('@sap/xssec');\r\n\r\n//turn off the automatic exchange\r\nxssec.config[\"IAS_XSUAA_XCHANGE_ENABLED\"] = false;\r\n\r\n//and so on\r\n```\r\n\r\n### Full IAS support\r\nSince version 3.2.0 the library can validate and verify IAS tokens directly. Have a look [here](IAS.md) for more details."},{"name":"MultiConfiguration.md","content":"# SecurityContext with multiple configurations\r\n\r\nThere are scenarios, where you need to \"feed\" the audience validator with 2 or more different configurations.\r\nFor example if you have a REST API that is called from two different XSUAA bindings.\r\n\r\nSince version 3.1.0 we support to have 2 or ServiceBinding configurations for one SecurityContext.\r\n\r\n\r\n### How to use this feature\r\nJust pass an array of configuration objects to the method instead of a single object.\r\nThis feature is fully backward compatible. So you can pass an array or a simple object to the method.\r\n\r\n#### If you create the SecurityContext on your own\r\n```js\r\nconst config1 = xsenv.getServices({xsuaa:{tag:'xsuaa'}}).xsuaa;\r\nconst config2 = xsenv.getServices({xsuaa:{tag:'xsuaaB'}}).xsuaaB;\r\n\r\nxssec.createSecurityContext(access_token, [config1, config2], function(error, securityContext, tokenInfo) {\r\n    //...\r\n});\r\n```\r\n\r\n#### If you use the passport library. \r\nFor the passport library the integration is also very simple.\r\n\r\n```js\r\nconst config1 = xsenv.getServices({xsuaa:{tag:'xsuaa'}}).xsuaa;\r\nconst config2 = xsenv.getServices({xsuaa:{tag:'xsuaaB'}}).xsuaaB;\r\n\r\npassport.use(new JWTStrategy([config, config2]));\r\n\r\napp.use(passport.initialize());\r\n\r\n//and so on\r\n```\r\n"},{"name":"TokenFlows.md","content":"# How to directly intiate token flows\r\n\r\nThere is a method ```requestToken()``` in the securityContext object. \r\nWith this you can call ClientCredentials or the JWT Bearer tokenflow in the scope of the securityContext.\r\n\r\nBut sometimes you want to do a ClientCredentials or a JWT Bearer tokenflow without creating a SecurityContext first. Since version 3.1.0 this is possible.\r\n\r\n### Obtaining the request object\r\nThe library now exports the request object.\r\n\r\n```js\r\nconst xssec = require('@sap/xssec');\r\nconst requests = xssec.requests;\r\n```\r\n\r\n#### JWT Bearer token flow\r\n```js\r\nrequests.requestUserToken(appToken, serviceCredentials, additionalAttributes, scopes, subdomain, zoneId, cb);\r\n// appToken: your current token \r\n// serviceCredentials: the service credentials. (the config object from environment)\r\n// additionalAttributes: object if you need to set additional attributes (or null)\r\n// scopes: object if you need to set scopes (or null)\r\n// subdomain: The subdomain of the xsuaa instance (or null)\r\n// ?zoneId: sometimes you do not know the subdomain. Then you have to set the zoneID (optional)\r\n// cb: the callback function cb(err, encodedTokenAsString)\r\n```\r\n\r\n#### Client Credentials flow\r\n```js\r\nrequests.requestClientCredentialsToken(subdomain, serviceCredentials, additionalAttributes, zoneId, cb);\r\n// subdomain: The subdomain of the xsuaa instance (or null)\r\n// serviceCredentials: the service credentials. (the config object from environment)\r\n// additionalAttributes: object if you need to set additional attributes (or null)\r\n// ?zoneId: sometimes you do not know the subdomain. Then you have to set the zoneID (optional)\r\n// cb: the callback function cb(err, encodedTokenAsString)\r\n```\r\n\r\n#### Password Token flow\r\n```js\r\nrequests.requestPasswordUserToken(subdomain, serviceCredentials, additionalAttributes, cb);\r\n// subdomain: The subdomain of the xsuaa instance (or null)\r\n// serviceCredentials: the service credentials. (the config object from environment)\r\n// additionalAttributes: object if you need to set additional attributes (or null)\r\n// cb: the callback function cb(err, encodedTokenAsString)\r\n```"},{"name":"TokenInfo.md","content":"# TokenInfo\r\n\r\nSince version 3.0.4 we have the TokenInfo object in the xssec library.\r\nThis is a wrapper around all the information the token contains.\r\n\r\n## Security Note\r\n\r\nDo not simply rely on the information within the token!\r\nThe webapplication normally receives the token with the HTTP Request from \"outside\" the application.\r\nSo there is a deep parameter validation needed! \r\n\r\n*Also if the token is signed, it may also contain dangerous information.*\r\n\r\n### How to get the TokenInfo object\r\nThere are several ways to get the TokenInfo.\r\nIf an error occurs NO security context is created. But the [TokenInfo](doc/TokenInfo.md) object is available, so you can do some logging.\r\n\r\n#### If you create the SecurityContext on your own\r\n```js\r\nxssec.createSecurityContext(access_token, config, function(error, securityContext, tokenInfo) {\r\n    if (error) {\r\n        console.log('tokenInfo is also available if you have an error', tokenInfo.getPayload())\r\n        return;\r\n    }\r\n    console.log('Security Context created successfully', tokenInfo.getPayload());\r\n    console.log('You can also retrieve it from the SecurityContext', securityContext.getTokenInfo());\r\n});\r\n```\r\n\r\n#### If you use the passport library. \r\nThe ``tokenInfo`` object is attached to the ``request`` object in the JWTStrategy middleware. ([more here](../README.md#api-description))\r\nOnly if the middleware could not find a bearer token in the HTTP header, there is no ``tokenInfo`` object created.\r\n\r\nThe documentation for a default error handler in express you find [here](https://expressjs.com/en/guide/error-handling.html)\r\n\r\n```js\r\npassport.use(new JWTStrategy(config));\r\n\r\napp.use(passport.initialize());\r\n\r\n//don't forget to set failWithError to true.\r\n//Otherwise the errorHandler will not be called\r\napp.use(passport.authenticate('JWT', { session: false, failWithError: true })); \r\n\r\n// simple express Error Handler\r\napp.use(function(err, req, res, next) {\r\n  //be aware that the error handler is not only for the passport errors!\r\n  var tokenInfo = req.tokenInfo;\r\n  if(tokenInfo) {\r\n    //err is exception thrown but not the error of the tokenValidation\r\n    //to get the errorObject from xsuaa\r\n    var xserror = tokenInfo.getErrorObject()  \r\n    \r\n    //to the logging\r\n    console.error(xserr, tokenInfo.getPayload());\r\n  }\r\n  \r\n  res.status(err.status);\r\n  res.send(err.message);\r\n});\r\n```\r\n\r\n## API Description\r\n\r\n### TokenInfo(encoded_token)\r\n\r\nCode says more than words :-)\r\n\r\n```js\r\nvar tokenInfo = new TokenInfo(encodedTokenAsString);\r\n\r\n///// Get the Token-information as a whole\r\nvar payload = tokenInfo.getPayload(); //Get the token payload\r\nvar header = tokenInfo.getHeader();   //Get the token header\r\nvar encoded = tokenInfo.getTokenValue(); //returns the encoded token string\r\n\r\nvar exp = tokenInfo.getExpirationDate(); //returns a Date object or null if not available\r\nvar iat = tokenInfo.getIssuedAt(); //returns a Date object or null if not available\r\nvar iss = tokenInfo.getIssuer(); //returns a string or null if not available\r\n\r\nvar is_xsuaa = tokenInfo.isTokenIssuedByXSUAA(); //returns true, if the token is a XSUAA token\r\n\r\n///// Error Handling\r\ntokenInfo.isDecoded(); //returns true, if a token could be decoded\r\ntokenInfo.isValid();    //returns true, if no error object is attached\r\n\r\ntokenInfo.getErrorObject(); //return the error object if there is one\r\n\r\n\r\n///// Verification of an encoded token\r\n\r\n//you can pass a key Callback to retrieve the key asyncronously\r\nfunction getKeyCB(header, callback) {\r\n  client.getSigningKey(header.kid, function(err, key) {\r\n    var signingKey = key.publicKey || key.rsaPublicKey;\r\n    callback(null, signingKey);\r\n  });\r\n}\r\n\r\ntokenInfo.verify(getKeyCB, function(err, tokenInfo) {\r\n    if(err) {\r\n        console.error(err.errorCode, err.message);\r\n        console.error(err.stack);\r\n\r\n        //tokenInfo is also available, if there was a verification error.\r\n        console.log(tokenInfo.getPayload());\r\n    } else {\r\n        //yeah, it was verified\r\n        ...\r\n    }\r\n});\r\n\r\n//instead of a callback you can directly give the verification key to the function\r\ntokenInfo.verify(\"123456\", function(err, tokenInfo) {\r\n    ...\r\n});\r\n\r\n```\r\n\r\n### Future Plans\r\nWe have plans to provide some more functionality here in the future:\r\n\r\n* provide not only verify, but also sign functionality\r\n* easy create tokens for unittesting"}]},{"name":"README.md","content":"@sap/xssec: XS Advanced Container Security API for node.js\r\n==========================================================\r\n\r\n## XS Advanced Authentication Primer\r\n\r\nAuthentication for node applications in XS Advanced relies on a special usage of the OAuth 2.0 protocol, which is based on central authentication at the UAA server that then vouches for the authenticated user's identity via a so-called OAuth Access Token. The current implementation uses as access token a JSON web token (JWT), which is a signed text-based token following the JSON syntax.\r\n\r\nNormally, your node application will consist of several parts, that appear as separate applications in your manifest file, e.g. one application part that is responsible for the HANA database content, one application part for your application logic written e.g. in node.js (this is the one that can make use of this XS Advanced Container Security API for node.js), and finally one application part that is responsible for the UI layer (this is the one that may make use of the application router functionality). The latter two applications (the application logic in node.js and the application router) should be bound to one and the same UAA service instance. This has the effect, that these two parts can use the same OAuth client credentials.\r\n\r\nWhen your business users access your application UI with their browser, the application router redirects the browser to the UAA where your business users need to authenticate. After successful authentication, the UAA sends - again via the business user's browser - an OAuth authorization code back to the application router. Now the application router sends this authorization code directly (not via the browser) to the UAA to exchange it into an OAuth access token. If the access token is obtained successfully, the business user has logged on to the UI part of your application already. In order to enable your UI to pass this authentication on to the node.js application part, you need to ensure that the destination to your node.js application part is configured such that the access token is actually sent to the node.js part (\"forwardAuthToken\": true).\r\n\r\nIn order to authenticate this request, which arrives at the node.js backend, sap-xssec offers two mechanisms: Firstly, you can use the XS Advanced Container Security API directly to validate the access token. Secondly, you can make use of the passport strategy that is contained in module sap-xssec as another convenient way how to handle the access token. In the following, both options are described followed by the sap-xssec API description.\r\n\r\nsap-xssec offers an offline validation of the access token, which requires no additional call to the UAA. The trust for this offline validation is created by binding the XS UAA service instance to your application. Inside the credentials section in the environment variable VCAP_SERVICES, the key for validation of tokens is included. By default, the offline validation check will only accept tokens intended for the same OAuth2 client in the same UAA identity zone. This makes sense and will cover the vast majority of use cases. \r\n\r\nIf you want to enable another (foreign) application to use some of your application's scopes, you can add a ```granted-apps``` marker to your scope in the ```xs-security.json``` file (as in the following example). The value of the marker is a list of applications that is allowed to request a token with the denoted scope.\r\n\r\n```JSON\r\n{\r\n  \"xsappname\"     : \"sample-leave-request-app\",\r\n  \"description\"   : \"This sample application demos leave requests\",\r\n  \"scopes\"        : [ { \"name\"                : \"$XSAPPNAME.createLR\",\r\n                        \"description\"         : \"create leave requests\" },\r\n                      { \"name\"                : \"$XSAPPNAME.approveLR\",\r\n                        \"description\"         : \"approve leave requests\",\r\n                        \"granted-apps\"        : [\"MobileApprovals\"] }\r\n                    ],\r\n  \"attributes\"    : [ { \"name\"                : \"costcenter\",\r\n                        \"description\"         : \"costcenter\",\r\n                        \"valueType\"           : \"string\"\r\n                    } ],\r\n  \"role-templates\": [ { \"name\"                : \"employee\",\r\n                        \"description\"         : \"Role for creating leave requests\",\r\n                        \"scope-references\"    : [ \"$XSAPPNAME.createLR\",\"JobScheduler.scheduleJobs\" ],\r\n                        \"attribute-references\": [ \"costcenter\"] },\r\n                      { \"name\"                : \"manager\",\r\n                        \"description\"         : \"Role for creating and approving leave requests\",\r\n                        \"scope-references\"    : [ \"$XSAPPNAME.createLR\",\"$XSAPPNAME.approveLR\",\"JobScheduler.scheduleJobs\" ],\r\n                        \"attribute-references\": [ \"costcenter\" ] }\r\n                    ]\r\n}\r\n```\r\n\r\n## Usage of the XS Advanced Container Security API in your node.js Application\r\n\r\nIn order to use the capabilities of the XS Advanced container security API, add the module \"sap-xssec\" to the dependencies section of your application's package.json.\r\n\r\nTo enable tracing, you can set the environment variable DEBUG as follows: `DEBUG=xssec:*`.\r\n\r\n### Direct Usage with existing Access Token\r\n\r\nFor the usage of the XS Advanced Container Security API it is necessary to pass a JWT token. If you have such a token, you may use the API as follows. The examples below rely on users and credentials that you should substitute with the ones in your context. The code below is based on version v0.0.9 (if you use another version, the coding might differ).\r\n\r\nThe typical use case for calling this API lies from within a container when an HTTP request is received. In an authorization header (with keyword `bearer`) an access token is contained already. You can remove the prefix `bearer` and pass the remaining string (just as in the following example as `access_token`) to the API.\r\n\r\n```js\r\nxssec.createSecurityContext(access_token, xsenv.getServices({xsuaa:{tag:'xsuaa'}}).xsuaa, function(error, securityContext, tokenInfo) {\r\n    if (error) {\r\n        console.log('Security Context creation failed');\r\n        return;\r\n    }\r\n    console.log('Security Context created successfully');\r\n    console.log(tokenInfo.getPublicClaims());\r\n});\r\n```\r\n\r\nNote that the example above uses module `xsenv` to retrieve the configuration of the default services (which are read from environment variable `VCAP_SERVICES` or if not set, from the default configuration file). However, it passes only the required `uaa` configuration to the method `createSecurityContext`. As default the UAA configuration is searched with tag `xsuaa` by `xsenv`. For details we refer to module @sap/xsenv. The `xsenv` documentation also helps if you want to provide the credentials from e.g. a user provided service.\r\n\r\nThe creation function `xssec.createSecurityContext` is to be used for an end-user token (e.g. for grant_type `password` or grant_type `authorization_code`) where user information is expected to be available within the token and thus within the security context.\r\n\r\n`createSecurityContext` also accepts a token of grant_type `client_credentials`. This leads to the creation of a limited SecurityContext where certain functions are not available. For more details please consult the API description below or your documentation.\r\n\r\nWith version 3.1.0 there is a support for multiple configuration objects for one SecurityContext. For more details have a look [here](doc/MultiConfiguration.md).\r\n\r\n### Support for X-Correlation-ID header\r\n\r\nThe xssec library internally calls REST APIs of the XSUAA.\r\nNow it's possible to set a `correlationId` during context creation and for token exchange calls.\r\nFor this you have to restructe the configuration object.\r\n\r\n```js\r\nconst config = {\r\n  credentials: xsenv.getServices({xsuaa:{tag:'xsuaa'}}).xsuaa,\r\n  correlationId: \"1111-1111-11111111\"\r\n};\r\n\r\n//now you can call the createSecurityContext method as always\r\nxssec.createSecurityContext(access_token, config, function(error, securityContext, tokenInfo) {\r\n    if (error) {\r\n        console.log('Security Context creation failed');\r\n        return;\r\n    }\r\n    console.log('Security Context created successfully');\r\n    console.log(tokenInfo.getPublicClaims());\r\n});\r\n```\r\n\r\n### Disable the cache for the current call (ONLY FOR TESTING!)\r\nThe xssec library internally calls REST APIs to fetch the public verification keys from XSUAA/IAS.\r\nFor performance reasons there is a cache, so not all calls have to fetch the key again.\r\n\r\nNow it's possible to turn off the cache using the  `disableCache` option during context creation.\r\nFor this you have to restructe the configuration object.\r\n\r\n```js\r\nconst config = {\r\n  credentials: xsenv.getServices({xsuaa:{tag:'xsuaa'}}).xsuaa,\r\n  correlationId: \"1111-1111-11111111\"\r\n  disableCache: true\r\n};\r\n\r\n//now you can call the createSecurityContext method as always\r\n//internally no Cache will be used!\r\nxssec.createSecurityContext(access_token, config, function(error, securityContext, tokenInfo) {\r\n    if (error) {\r\n        console.log('Security Context creation failed');\r\n        return;\r\n    }\r\n    console.log('Security Context created successfully');\r\n    console.log(tokenInfo.getPublicClaims());\r\n});\r\n```\r\n\r\nThis also works for the Tokenexchange methods!\r\n\r\n### Usage with Passport Strategy\r\n\r\nIf you use [express](https://www.npmjs.com/package/express) and [passport](https://www.npmjs.com/package/passport), you can easily plug a ready-made authentication strategy.\r\n\r\nSince version 3.1.1 the JWTStratgy also supports the scope validation specified in [passport](http://www.passportjs.org/docs/oauth/#scope).\r\n\r\n```js\r\nvar express = require('express');\r\nvar passport = require('passport');\r\nvar JWTStrategy = require('@sap/xssec').JWTStrategy;\r\nvar xsenv = require('@sap/xsenv');\r\n\r\n...\r\n\r\nvar app = express();\r\n\r\n...\r\n\r\npassport.use(new JWTStrategy(xsenv.getServices({xsuaa:{tag:'xsuaa'}}).xsuaa));\r\n\r\napp.use(passport.initialize());\r\napp.use(passport.authenticate('JWT', { session: false }));\r\n```\r\n\r\nIf JWT token is present in the request and it is successfully verified, following objects are created:\r\n* request.user - according to [User Profile](http://passportjs.org/docs/profile) convention\r\n  * id\r\n  * name\r\n    * givenName\r\n    * familyName\r\n  * emails `[ { value: <email> } ]`\r\n* request.authInfo - the [Security Context](#api-description)\r\n* request.tokenInfo - the [TokenInfo](doc/TokenInfo.md) object\r\n\r\nIf the `client_credentials` JWT token is present in the request and it is successfully verified, following objects are created:\r\n* request.user - empty object\r\n* request.authInfo - the [Security Context](#api-description)\r\n* request.tokenInfo - the [TokenInfo](doc/TokenInfo.md) object\r\n\r\n\r\n#### Session\r\n\r\nIt is recommended to _disable the session_ as in the example above.\r\nIn XSA each request comes with a JWT token so it is authenticated explicitly and identifies the user.\r\nIf you still need the session, you can enable it but then you should also implement [user serialization/deserialization](http://passportjs.org/guide/configure/) and some sort of [session persistency](https://github.com/expressjs/session).\r\n\r\n\r\n### Configure the cache of Verificationkeys\r\nFor token verification the library needs a so called `public key`. This key can be requested from the XSUAA server.\r\nThe library caches these keys to reduce the load to the XSUAA. (And for better performance!)\r\nThere are two values that are used to control the cache. The number of cache entries and an expiration time of each item. The latter is important to easily support key rotation scenarios and should not be too high.\r\n:exclamation: **Normally you don't need to overwrite the default values!**\r\n\r\nBut in rare situations there is a need to change them.\r\n\r\n**Conditions:**\r\nThe cacheSize value has to be >=1000\r\nThe expirationTime is measured in minutes and has to be a number >= 10 \r\n\r\n**Currently the default values are:**\r\n```json\r\n{\r\n  \"cacheSize\": 1000,\r\n  \"expirationTime\": 10\r\n}\r\n```\r\n\r\n**Here are some codesnippets how to do this:**\r\n\r\n```js\r\n//just add the keyCache object into the config object and pass it to the constructor functions\r\n\r\nvar config = xsenv.getServices({xsuaa:{tag:'xsuaa'}}).xsuaa;\r\nconfig.keyCache = {\r\n  cacheSize: 5000,\r\n  expirationTime: 10\r\n};\r\n\r\n//if you only want to overwrite one value you can also:\r\nvar config = xsenv.getServices({xsuaa:{tag:'xsuaa'}}).xsuaa;\r\nconfig.keyCache = {\r\n  cacheSize: 10000\r\n};\r\n\r\n//then pass the config object to createSecurityConfig\r\nxssec.createSecurityContext(access_token, config, function(error, securityContext, tokenInfo) {\r\n   ...\r\n});\r\n\r\n//if you use passport:\r\nvar config = xsenv.getServices({xsuaa:{tag:'xsuaa'}}).xsuaa;\r\nconfig.keyCache = {\r\n  cacheSize: 10000\r\n};\r\npassport.use(new JWTStrategy(config));\r\n...\r\n```\r\n\r\n### Test Usage without having an Access Token\r\n\r\nFor test purposes, you may retrieve the token for a certain user (whose credentials you know) from the UAA as in the following code-snippet.\r\n\r\n```js\r\nvar http = require(\"http\");\r\nvar xssec = require(\"@sap/xssec\");\r\nvar xsenv = require('@sap/xsenv');\r\nvar request = require('request');\r\n\r\nvar uaaService = xsenv.getServices( { uaa: 'uaa' } ).uaa;\r\nvar testService = xsenv.getServices( { test : { label : 'test' } } ).test;\r\nprocess.env.XSAPPNAME = testService.test.xsappname;\r\n\r\nvar options = {\r\n    url : uaaService.url + '/oauth/token?client_id=' + uaaService.clientid\r\n            + '&grant_type=password&username=' + testService.userid + '&password='\r\n            + testService.usersecret\r\n};\r\nrequest.get(\r\n    options,\r\n    function(error, response, body) {\r\n        if (error || response.statusCode !== 200) {\r\n            console.log('Token request failed');\r\n            return;\r\n        }\r\n\r\n        var json = null;\r\n        try {\r\n            json = JSON.parse(body);\r\n        } catch (e) {\r\n        \treturn callback(e);\r\n        }\r\n\r\n        xssec.createSecurityContext(json.access_token, uaaService, function(error, securityContext, tokenInfo) {\r\n            if (error) {\r\n                console.log('Security Context creation failed');\r\n                return;\r\n            }\r\n            console.log('Security Context created successfully');\r\n            console.log(tokenInfo.getPublicClaims());\r\n        });\r\n    }\r\n).auth(uaaService.clientid, uaaService.clientsecret, false);\r\n```\r\nNote that this example assumes additional test configuration in the file `default-services.json`.\r\n\r\n```json\r\n{\r\n  \"uaa\": {\r\n    \"url\"             : \"<UAA URL>\",\r\n    \"clientid\"        : \"<your application's OAuth client id>\",\r\n    \"clientsecret\"    : \"<your application's OAuth client secret>\",\r\n    \"xsappname\"       : \"<your application's name>\",\r\n    \"identityzone\"    : \"<desired UAA identity zone>\",\r\n    \"tags\"            : [\"xsuaa\"],\r\n    \"verificationkey\" : \"<verification key for offline validation>\"\r\n  },\r\n  \"test\": {\r\n    \"userid\"          : \"marissa\",\r\n    \"usersecret\"      : \"koala\"\r\n  }\r\n}\r\n```\r\n\r\n\r\n\r\n### Support for X.509 authentication for token exchange\r\nXSUAA offers the possibility to use X.509 authentication.\r\nSince version 3.2.2 the node-xssec library supports to use this.\r\n\r\nAs a developer you normally do not need to do something differently. You create a SecurityContext with the configuration object you get from the environment.\r\nIf the XSUAA is configured to use X.509 the config object does not contain a `clientsecret`. Instead of this, there are a `certificate` and a `key` attributes.\r\nThe library will use these attributes during token exchanges to fetch the tokens from xsuaa using mtls.\r\n\r\n#### X.509 with XSUAA managed certificates\r\nIf your XSUAA instance is configured to manage certificates and keys on its own, you can take the configuration object from VCAP services and pass it to the `createSecurityContext` method.\r\nThe needed `certificate` and `key` attributes are already filled.\r\n\r\nThere is no difference to client-credential based token exchange.\r\n\r\n#### X.509 with external certificates\r\nIf you configured your XSUAA instance to use an external managed certificate/key you need to provide the `key` attribute to the configuration object.\r\n\r\nFor this you take the JSON from VCAP-Services and add the PEM encoded key as a string to the configuration.\r\n```js\r\n//read xsuaa config from VCAP\r\nconst config = xsenv.getServices({xsuaa:{tag:'xsuaa'}}).xsuaa;\r\n\r\nconst myExternalManagedKey = \"-----BEGIN RSA PRIVATE KEY-----...-----END RSA PRIVATE KEY-----\\n\";\r\nconfig.key = myExternalManagedKey;\r\n\r\n//if using passport\r\npassport.use(new JWTStrategy(config));\r\n\r\n//or create a security context directly\r\nxssec.createSecurityContext(access_token, config, function(error, securityContext, tokenInfo) {\r\n    //now you can run a tokenExchange with the provided key    \r\n    xssec.requestToken(config, constants.TYPE_USER_TOKEN, null, function(err, data) {\r\n\r\n    })    \r\n});\r\n```\r\n\r\n### Usage in Docker\r\n\r\nIn versions <= 3.0.0 there was **no** support for alpine base images.\r\nBut since verion >= 3.0.0 the xssec library has no dependency to a native library anymore. So it is now **fully compatible** with alpine images.\r\n\r\n## API Description\r\n\r\n### createSecurityContext\r\n\r\nThis function creates the Security Context by validating the received access token against credentials put into the application's environment via the UAA service binding.\r\n\r\nUsually, the received token must be intended for the current application. More clearly, the OAuth client id in the access token needs to be equal to the OAuth client id of the application (from the application's environment).\r\n\r\nParameters:\r\n\r\n* `access token` ... the access token as received from UAA in the \"authorization Bearer\" HTTP header\r\n* `config` ... a structure with mandatory elements url, clientid and clientsecret or cache configuration. Since version 3.1.0 it may also be an array of these structures (have a look [here](doc/MultiConfiguration.md))\r\n* `callback(error, securityContext, tokenInfo)`\r\n\r\n### getLogonName\r\n\r\nnot available for tokens of grant_type `client_credentials`, returns the logon name\r\n\r\n### getGivenName\r\n\r\nnot available for tokens of grant_type `client_credentials`, returns the given name\r\n\r\n### getFamilyName\r\n\r\nnot available for tokens of grant_type `client_credentials`, returns the family name\r\n\r\n### getEmail\r\n\r\nnot available for tokens of grant_type `client_credentials`, returns the email\r\n\r\n### getUserName\r\n\r\nreturns unique principal name of a user `user/<origin>/<logon name>` or client id that the access token has been issued for `client/<client id>`\r\n\r\n### getUniquePrincipalName\r\n\r\nnot available for tokens of grant_type `client_credentials`, returns unique principal name of a user. `user/<origin>/<logon name>`\r\n\r\n### getOrigin\r\n\r\n* returns the user origin. The origin is an alias that refers to a user store in which the user is persisted. For example, users that are authenticated by the UAA itself with a username/password combination have their origin set to the value uaa.\r\n\r\n### checkLocalScope\r\n\r\nchecks a scope that is published by the current application in the xs-security.json file.\r\n\r\nParameters:\r\n\r\n* `scope` ... the scope whose existence is checked against the available scopes of the current user. Here, no prefix is required.\r\n* returns `true` if the scope is contained in the user's scopes, `false` otherwise\r\n\r\n### checkFollowingInstanceScope\r\n\r\nchecks a instance specific scope that is published by the current application in the xs-security.json file. Use this to check a scope from a service instance.\r\n\r\nParameters:\r\n\r\n* `scope` ... the scope whose existence is checked against the available scopes of the current user. Here, no prefix is required.\r\n* returns `true` if the scope is contained in the user's scopes, `false` otherwise\r\n\r\n### checkScope\r\n\r\nchecks a scope that is published by an application.\r\n\r\nParameters:\r\n\r\n* `scope` ... the scope whose existence is checked against the available scopes of the current user.  Here, the prefix is required, thus the scope string is \"globally unique\".\r\n* returns `true` if the scope is contained in the user's scopes, `false` otherwise\r\n\r\n### getAppToken\r\n\r\n* returns the token of the application that can be used e.g. for token forwarding to another app.\r\n\r\n### getHdbToken\r\n\r\n* returns a token that can be used for contacting the HANA database. If the token, that the security context has been instantiated with, is a foreign token (meaning that the OAuth client contained in the token and the OAuth client of the current application do not match), `null` is returned instead of a token.\r\n\r\n### getTokenInfo\r\n* returns the [TokenInfo](doc/TokenInfo.md) object, containing all information received from token.\r\n\r\n### requestToken\r\n\r\nRequests a token based on the given type. The type can be `constants.TYPE_USER_TOKEN` or `constants.TYPE_CLIENT_CREDENTIALS_TOKEN`.\r\n\r\n* `serviceCredentials` ... the credentials of the service as JSON object. The attributes `clientid`, `clientsecret` and `url` (UAA) are mandatory. Note that the subdomain of the `url` will be adapted to the subdomain of the application token if necessary.\r\n* `type` ... allowed values are `constants.TYPE_USER_TOKEN` and `constants.TYPE_CLIENT_CREDENTIALS_TOKEN`\r\n* `additionalAttributes` ... the attributes that should be included into the JWT token as JSON object (key-value list), e.g. `{\"attr1\" : \"value1\", \"attr2\" : \"value2\"}` \r\n* `cb(error, token)` ... callback function\r\n\r\nalso have a look on how to initiate the [token flows](doc/TokenFlows.md) directly\r\n### hasAttributes\r\n\r\nnot available for tokens of grant_type `client_credentials`.\r\n\r\n* returns `true` if the token contains any xs user attributes, `false` otherwise.\r\n\r\n### getAttribute\r\n\r\nnot available for tokens of grant_type `client_credentials`.\r\n\r\nParameters:\r\n\r\n* `name` ... The name of the attribute that is requested.\r\n* returns the attribute exactly as it is contained in the access token. If no attribute with the given name is contained in the access token, `null` is returned. If the token, that the security context has been instantiated with, is a foreign token (meaning that the OAuth client contained in the token and the OAuth client of the current application do not match), `null` is returned regardless of whether the requested attribute is contained in the token or not.\r\n\r\n### getAdditionalAuthAttribute\r\n\r\nParameters:\r\n\r\n* `name` ... The name of the additional authentication attribute that is requested.\r\n* returns the additional authentication attribute exactly as it is contained in the access token. If no attribute with the given name is contained in the access token, `null` is returned. Note that additional authentication attributes are also returned in foreign mode (in contrast to getAttribute).\r\n\r\n### isInForeignMode\r\n\r\n* returns `true` if the token, that the security context has been instantiated with, is a foreign token that was not originally issued for the current application, `false` otherwise.\r\n\r\n### getSubdomain\r\n\r\n* returns the subdomain that the access token has been issued for.\r\n\r\n### getClientId\r\n\r\n* returns the client id that the access token has been issued for.\r\n\r\n### getSubaccountId\r\n\r\n* returns the subaccount id that the access token has been issued for.\r\n\r\n### getZoneId\r\n\r\n* returns the identity zone that the access token has been issued for.\r\n\r\n### getExpirationDate\r\n\r\n* returns the expiration date of the access token as javascript Date object.\r\n\r\n### getCloneServiceInstanceId\r\n\r\n* returns the service instance id of the clone if the XSUAA broker plan is used.\r\n\r\n### getGrantType\r\n\r\n* returns the grant type of the JWT token, e.g. `authorization_code`, `password`, `client_credentials` or `urn:ietf:params:oauth:grant-type:saml2-bearer`.\r\n\r\n## Latest published Version\r\nUse this command to check for the latest version that is published to the NPM repository:\r\n\r\n```\r\nnpm view --registry https://npm.sap.com @sap/xssec versions\r\n```\r\n"}]